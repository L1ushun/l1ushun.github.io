<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>chrome-devtools 实践分享</title>
    <link href="/2026/01/23/chrome-devtools/"/>
    <url>/2026/01/23/chrome-devtools/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要分享使用 <a href="https://github.com/ChromeDevTools/chrome-devtools-mcp/?tab=readme-ov-file#chrome-devtools-mcp">chrome-devtools-mcp</a> 在日常开发的使用，使用该 mcp 相当于你可以直接和 chrome 对话，他可以帮助你完成你希望在 chrome 上完成的各种操作。</p><p>我主要使用该 mcp 在一下几个方面：</p><ol><li>辅助还原页面&#x2F;设计稿、修改样式</li><li>配合 apifox-mcp 快速联调接口</li><li>辅助测试页面功能</li><li>获取网页性能数据</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>需要注意的是，该 mcp 需要 node 版本在 22.12.0 及以上</p><p>如果因为项目需要，node版本较低，可以通过以下脚本来使用 nvm 来切换 node 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">export</span> NVM_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.nvm&quot;</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span><br>nvm use 20.19.2 &gt; /dev/null 2&gt;&amp;1<br><span class="hljs-built_in">exec</span> npx chrome-devtools-mcp@latest <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></td></tr></table></figure><p>然后在你的 mcp.json 配置里 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;chrome-devtools&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;上面脚本的位置，一般放在 ~/.cursor/scripts/chrome-devtools-mcp.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="还原设计稿、修改样式"><a href="#还原设计稿、修改样式" class="headerlink" title="还原设计稿、修改样式"></a>还原设计稿、修改样式</h2><p>其实严格来说，该 chrome-devtools-mcp 主要还是来获取你当前页面的状态，这样相当于让你的模型根据图片还原设计稿时有了一双眼睛，可以对比当前页面和你提供给他的设计稿之间的差异。</p><p>（目前蓝湖还没有官方的mcp，如果希望使用蓝湖专门的mcp可以尝试下<a href="https://github.com/dsphper/lanhu-mcp">lanhu-mcp</a>这个开源的项目。）</p><p>实际体验下来，把设计稿导出图片喂给 AI 加上 chrome-devtools-mcp 的加持，页面还原度也只能到 70%～80%，并且也和使用的模型有关。想要完全还原设计稿还需要多轮对话，补充一些细节的修改点。</p><h2 id="配合-apifox-mcp-快速联调接口"><a href="#配合-apifox-mcp-快速联调接口" class="headerlink" title="配合 apifox-mcp 快速联调接口"></a>配合 apifox-mcp 快速联调接口</h2><p>prompt 如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">@src<span class="hljs-regexp">/js/</span>new_merchandise/create.js <br><br>新品创建的接口为 xxxxxx ，任务清单如下：<br><span class="hljs-number">1</span>. 使用 apifox-mcp查询这个接口的文档，完善表单字段名<br><span class="hljs-number">2</span>. 使用 chrome-devtools-mcp 在该页面填入表单数据创建<span class="hljs-number">2</span>条数据<br></code></pre></td></tr></table></figure><p>首先会使用 apifox-mcp 会找到这个后端维护的这个接口文档，然后帮助我们根据文档的字段来修改我们表单对应的字段，然后 chrome-devtools-mcp 会打开一个测试浏览器页面，输入表单数据并调用接口，完成联调。</p><h2 id="自动化测试页面功能"><a href="#自动化测试页面功能" class="headerlink" title="自动化测试页面功能"></a>自动化测试页面功能</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md">使用 chrome-dev-tools 测试下http://localhost:8080/#/new<span class="hljs-emphasis">_merchandise 这个页面，测试的功能清单如下</span><br><span class="hljs-emphasis">1. 测试商品名称搜索、提交时间、状态、商户筛选是否生效</span><br><span class="hljs-emphasis">2. 测试页面滚动加载功能是否生效</span><br><span class="hljs-emphasis">3. 是否有控制台error或者接口报错</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">并将测试项和结果列出</span><br></code></pre></td></tr></table></figure><p>测试中实际效果<br><img src="/img/chrome-test.png" alt="测试效果"></p><p>测试结果<br><img src="/img/chrome-test-res.png" alt="测试结果反馈"></p><p>缺点：只能处理一些基础的交互功能，</p><h2 id="测试网页性能和SEO"><a href="#测试网页性能和SEO" class="headerlink" title="测试网页性能和SEO"></a>测试网页性能和SEO</h2><p>传统我们想要获取一个网页例如某官网的性能指标数据，还需要手动打开控制台的 performance 来人工操作</p><p>利用 chrome-devtools-mcp 的的话，可以直接把网址丢给他来获取。</p><p><img src="/img/performance.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>mcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>patch-package 给 npm 包打补丁</title>
    <link href="/2025/12/25/patch-package/"/>
    <url>/2025/12/25/patch-package/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从实际遇到的问题出发，使用 patch-package 如何给 npm 包打补丁。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>使用 react-pdf 时，版本<code>4.2.0</code>，在预览某pdf时，pdf上的盖章看不见</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>注释掉 pdfjs-dist 下 build&#x2F;pdf.worker.js 的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (data.<span class="hljs-property">fieldType</span> === <span class="hljs-string">&#x27;Sig&#x27;</span>) &#123;<br>    data.<span class="hljs-property">fieldValue</span> = <span class="hljs-literal">null</span>;<br><br>    _this2.<span class="hljs-title function_">setFlags</span>(_util.<span class="hljs-property">AnnotationFlag</span>.<span class="hljs-property">HIDDEN</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那想要修复类似这样的问题，有几种方案</p><ol><li>将源码拉下来修改代码推送到私有仓库</li><li>升级版本（如果在新版本有修复你的问题）</li><li>使用 patch-package</li></ol><p>每个的优缺点就不说了，如果对源码改动不大并且想快速解决问题，使用 patch-package 是性价比最高的</p><h2 id="使用-patch-package"><a href="#使用-patch-package" class="headerlink" title="使用 patch-package"></a>使用 patch-package</h2><p>如上文，我们就解决这个问题当作示例</p><ol><li>首先要安装 patch-package </li><li>直接跑到 node_modules 改源码</li><li>执行 npx patch-package xxx 你改的包，这里是 npx patch-package-pdfjs-dist<br><img src="/img/patch-package.png" alt="执行结果"></li><li>可以看到项目里多了一个patch<br><img src="/img/patch-package-demo.png" alt="目录"></li></ol><p><img src="/img/cursor-patch.png" alt="patch 文件内容"><br>5. 在 <code>package.json</code> 加入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;postinstall&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;patch-package&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>postinstall 是 npm&#x2F;yarn 的生命周期钩子，在 npm install 或 yarn install 完成后自动执行，确保每次 install 会执行 patch-package</p><h2 id="pnpm-自带-patch"><a href="#pnpm-自带-patch" class="headerlink" title="pnpm 自带 patch"></a>pnpm 自带 patch</h2><p>pnpm 是自带 patch 功能的，具体流程如下：</p><ol><li>首先执行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">pnpm patch 你要修改的包<br><br><span class="hljs-comment"># 如果是上面的例子就是</span><br>pnpm patch pdfjs-dist@2.1.266<br></code></pre></td></tr></table></figure><img src="/img/pnpm-patch.png" alt="执行结果"></li><li>然后 pnpm 会返回一个临时目录路径，例如：&#x2F;xxx&#x2F;…&#x2F;node_modules&#x2F;pdfjs-dist</li><li>在返回路径的文件手动修改代码</li><li>提交补丁，执行第一步返回的提示命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pnpm patch-commit 路径xxx<br></code></pre></td></tr></table></figure>这样补丁会在每次 pnpm install 时自动应用</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cursor编程</title>
    <link href="/2025/11/10/cursor/"/>
    <url>/2025/11/10/cursor/</url>
    
    <content type="html"><![CDATA[<h1 id="Cursor实践指南"><a href="#Cursor实践指南" class="headerlink" title="Cursor实践指南"></a>Cursor实践指南</h1><p>Cursor作为一款AI驱动的代码编辑器，正在改变我们的编程方式。本文将分享如何有效地使用Cursor进行开发，从基础使用到高级技巧，帮助你提升编程效率。</p><h2 id="Cursor基础使用"><a href="#Cursor基础使用" class="headerlink" title="Cursor基础使用"></a>Cursor基础使用</h2><h3 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h3><p>Cursor可以从<a href="https://cursor.sh/">官方网站</a>下载安装。支持Windows、macOS和Linux系统。安装后，你需要：</p><ol><li>创建或登录账号</li><li>连接你的OpenAI账号（如果你想使用GPT-4等高级功能）</li><li>设置你的工作区</li></ol><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><table><thead><tr><th>模式</th><th>适用场景</th><th>功能</th><th>工具</th></tr></thead><tbody><tr><td>Agent</td><td>复杂功能、重构</td><td>自主探索、多文件编辑</td><td>启用所有工具</td></tr><tr><td>Ask</td><td>学习、规划、提问</td><td>只读探索，不做自动更改</td><td>仅搜索工具</td></tr><tr><td>Plan</td><td>需规划的复杂功能</td><td>执行前生成详细计划，提出澄清性问题</td><td>启用所有工具</td></tr></tbody></table><p>这里官方文档已经写的很清楚了，不同模式对应不同场景。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>cursor 支持多种命令模式：</p><ol><li>项目命令：存放在项目的 .cursor&#x2F;commands 目录</li><li>全局命令：存放在主目录的 ~&#x2F;.cursor&#x2F;commands 目录</li><li>团队命令：由团队管理员在 Cursor Dashboard 中创建，自动向所有团队成员提供</li></ol><p>可以通过跨界见 command + p 输入 &gt;</p><p><img src="/img/command.png"></p><p>即可设置项目命令和全局命令，暂时没用过团队版，不做展示</p><p>我这里设置了一个 code-review 的全局命令</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-section"># code-review</span><br><br><span class="hljs-section">## 概述</span><br><br>在批准任何变更之前，执行彻底的代码评审，以验证其功能性、可维护性和安全性。重点关注架构、可读性、性能影响，并提供可操作的改进建议。<br><br><span class="hljs-section">## 步骤</span><br><br><span class="hljs-bullet">1.</span> <span class="hljs-strong">**理解变更**</span><br><span class="hljs-bullet">   -</span> 阅读 PR 描述和相关议题以获取上下文<br><span class="hljs-bullet">   -</span> 确定受影响的文件和功能范围<br><span class="hljs-bullet">   -</span> 记录任何假设或需要与作者澄清的问题<br><span class="hljs-bullet">2.</span> <span class="hljs-strong">**验证功能性**</span><br><span class="hljs-bullet">   -</span> 确认代码实现了预期行为<br><br><span class="hljs-bullet">-</span> 在本地运行或通过脑力演练检查边界情况或保护条件<br><span class="hljs-bullet">-</span> 检查错误处理路径与日志是否清晰<br><br><span class="hljs-bullet">3.</span> <span class="hljs-strong">**评估质量**</span><br><span class="hljs-bullet">   -</span> 确保函数职责单一、命名具描述性、代码可读<br><span class="hljs-bullet">   -</span> 注意是否存在重复、无用代码或缺失测试<br><span class="hljs-bullet">   -</span> 验证文档和注释是否反映最新变更<br><span class="hljs-bullet">4.</span> <span class="hljs-strong">**审查安全与风险**</span><br><span class="hljs-bullet">   -</span> 查找注入点、不安全默认设置或缺失的校验<br><span class="hljs-bullet">   -</span> 确认未暴露秘密或凭证<br><span class="hljs-bullet">   -</span> 评估变更对性能或可扩展性的影响<br><br><span class="hljs-section">## 评审清单</span><br><br><span class="hljs-section">### 功能性</span><br><br><span class="hljs-bullet">-</span> [ ] 预期行为正常工作且符合需求<br><span class="hljs-bullet">-</span> [ ] 边界情况得到妥善处理<br><span class="hljs-bullet">-</span> [ ] 错误处理合理且信息充分<br><span class="hljs-bullet">-</span> [ ] 无明显错误或逻辑问题<br><br><span class="hljs-section">### 代码质量</span><br><br><span class="hljs-bullet">-</span> [ ] 代码可读且结构良好<br><span class="hljs-bullet">-</span> [ ] 函数小而专注<br><span class="hljs-bullet">-</span> [ ] 变量名具有描述性<br><span class="hljs-bullet">-</span> [ ] 遵循项目约定<br><span class="hljs-bullet">-</span> [ ] 无不必要的重复或无用代码<br><span class="hljs-bullet">-</span> [ ] 不对公共组件或方法进行破坏性修改<br><span class="hljs-bullet">-</span> [ ] 除提示文案外，减少代码中的存在含义的字符串，定义成常量<br><br><span class="hljs-section">### 安全与安全性</span><br><br><span class="hljs-bullet">-</span> [ ] 未引入明显的安全漏洞<br><span class="hljs-bullet">-</span> [ ] 输入已校验，输出已净化<br><span class="hljs-bullet">-</span> [ ] 敏感数据处理得当<br><span class="hljs-bullet">-</span> [ ] 无硬编码密钥<br><br><span class="hljs-section">## 其他评审备注</span><br><br><span class="hljs-bullet">-</span> 考量架构和设计决策<br><span class="hljs-bullet">-</span> 评估性能瓶颈或回归<br><span class="hljs-bullet">-</span> 审查编码规范与最佳实践<br><span class="hljs-bullet">-</span> 检查资源管理、错误处理和日志记录<br><span class="hljs-bullet">-</span> 给出可替代方案、额外测试用例或文档更新建议<br><br>提供具有建设性的反馈，附带具体示例与可执行指导，帮助作者改进。<br></code></pre></td></tr></table></figure><p>设置好命令后，在 chat 对话框输入 &#x2F; 就会提示，而且还提供预览 command</p><p><img src="/img/use-command.png"></p><p>关于如何写 command 可以在 github 寻找参考，例如:<br><a href="https://github.com/hamzafer/cursor-commands">command的参考：https://github.com/hamzafer/cursor-commands</a></p><h5 id="cursorignore"><a href="#cursorignore" class="headerlink" title=".cursorignore"></a>.cursorignore</h5><p> .cursorignore 和 .gitignore 类似，用来指定 cursor 屏蔽哪些文件</p><h4 id="auto-run"><a href="#auto-run" class="headerlink" title="auto run"></a>auto run</h4><p> <img src="/img/auto-run.png" alt="auto run"></p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li><code>Cmd/Ctrl + K</code>：打开命令面板</li><li><code>Cmd/Ctrl + I</code>：打开AI聊天</li><li><code>Cmd/Ctrl + L</code>：生成代码</li><li><code>Cmd/Ctrl + Shift + L</code>：解释选中的代码</li><li><code>Cmd/Ctrl + Shift + I</code>：编辑选中的代码</li></ul><h3 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h3><h4 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h4><p>MCP 全称 <a href="https://modelcontextprotocol.io/docs/getting-started/intro">Model Context Protocol</a>，模型上下文协议。</p><p>MCP 可以简单理解为是 AI 和外部工具间的一座桥梁，通过 MCP 我们的AI可以读取到外部工具的一些信息例如 apifox  figma</p><p><a href="https://docs.apifox.com/apifox-mcp-server">Apifox 帮助文档</a></p><p><a href="https://www.framelink.ai/docs/quickstart?utm_source=github&utm_medium=referral&utm_campaign=readme">Figma</a></p><p><a href="https://modelscope.cn/mcp">MCP 广场</a></p><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p>Cursor 可以配置自定义 Hooks，在某些时刻执行</p><p>配置：<br>创建 <code>~/.cursor/hooks.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;hooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;afterFileEdit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./hooks/format.sh&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>afterFileEdit</code> 就是一个钩子，在编辑文件后会运行 <code>./hooks/format.sh</code> 脚本</p><p>Cursor 支持以下几类 hooks 钩子，在对应时机自动执行你指定的脚本或命令：</p><ul><li><code>beforeShellExecution</code>: 在执行shell命令前调用，可以控制权限</li><li><code>beforeMCPExecution</code>: 在执行MCP工具前调用，可以控制权限</li><li><code>afterShellExecution</code>: 在shell命令执行后触发，可用于审计或收集指标</li><li><code>afterMCPExecution</code>: 在MCP工具执行后触发，包含工具的输入参数和结果</li><li><code>afterFileEdit</code>: 在文件编辑后触发，适用于代码格式化或记录生成的代码</li><li><code>beforeReadFile</code>: 在读取文件前启用内容脱敏或访问控制</li><li><code>beforeSubmitPrompt</code>: 在用户点击发送后、发起后端请求之前调用，可阻止提交</li><li><code>afterAgentResponse</code>: 在代理完成一条助理消息后调用</li><li><code>stop</code>: 在代理循环结束时调用，可选地自动提交后续用户消息以继续迭代</li></ul><h3 id="function-call"><a href="#function-call" class="headerlink" title="function call"></a>function call</h3><p>在开始和AI对话前会有一些预定的的函数列表，通过 <a href="https://json-schema.org/learn#get-started">json-schema</a>格式存储，每个函数都有明确的名称、描述、参数类型和用途说明。当用户和 AI 进行对话时，AI 会分析用户输入内容，从已注册的 function 列表中选择适合完成用户请求的函数，将用户输入转换成合适的参数，调用函数，函数再去调用其他API或者查询数据库返回结果，结果给到模型也是结构化JSON数据，模型对结果进行整合回答用户。</p><h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><h4 id="结构化提示词"><a href="#结构化提示词" class="headerlink" title="结构化提示词"></a>结构化提示词</h4><p>将提示词拆分成几个模块，</p><p>角色定位：先给大模型做角色定位，例如：你是一个资深的软件开发工程师，你熟练掌握xxxxx<br>任务需求：然后将你需要让ai帮你实现的需求分条罗列出来，尽可能详细和明确<br>依赖：如果你的任务需要依赖一些工具或者素材，可以提供给ai<br>约束：对大模型进行限制或者明确一些错误边界，让他按照你的想法进行，规避大模型做一些不期望的动作，<code>避免说不要做什么，尽量明确要做什么</code></p><p>写示例：给大模型一个示例，让他根据给出的示例来解决问题，给出的示例要保证准确性，尽可能在多方面给出不同的示例</p><h4 id="加要求"><a href="#加要求" class="headerlink" title="加要求"></a>加要求</h4><p><a href="https://www.promptingguide.ai/zh/introduction/tips">提示技巧</a></p><p><a href="https://prompt.com/metaprompt/">优化你的 prompt</a></p><h3 id="RAG-fine-turning、workflow、agent"><a href="#RAG-fine-turning、workflow、agent" class="headerlink" title="RAG fine turning、workflow、agent"></a>RAG fine turning、workflow、agent</h3><p>loading….</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端文件格式转换</title>
    <link href="/2024/12/02/img-file/"/>
    <url>/2024/12/02/img-file/</url>
    
    <content type="html"><![CDATA[<h1 id="Blob-File"><a href="#Blob-File" class="headerlink" title="Blob &amp; File"></a>Blob &amp; File</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">Blob</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File">File</a> 都是是一个文件对象，File 在 Blob 的基础上进行了功能扩展，两者可以通过 new 实例的方式获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(blobParts, options);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">File</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(fileBits, fileName, options)<br></code></pre></td></tr></table></figure><p>在参数上，File 多了一个文件名的参数，另外在 options 里还多了一个可选的 lastModified 上次修改时间。</p><p><img src="https://s21.ax1x.com/2024/12/02/pAI0qXt.png" alt="blob file"></p><p>通过打印同一个图片的 Blob 和 File 更嫩直观的看出属性上的差异，另外还可以看到 File 继承了 Blob。</p><h1 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h1><p>读取文件对象的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>()<br></code></pre></td></tr></table></figure><p>实例上有几个方法</p><ol><li>readAsDataURL(blob)： 读取文件对象的内容，将内容用 data:URL 的形式表示，比较常用，例如读取图片文件复制给 img 的 src。</li><li>readAsArrayBuffer(blob)：将内容用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffer</a> 的形式表示</li><li>readAsText(blob)：将内容用字符串形式表示</li><li>abort()： 终止文件的读取</li></ol><p>还有几个事件，也可以理解为读取文件的声明周期</p><ol><li>abort 终止时触发</li><li>error 读取跑出错误触发</li><li>load 读取成功触发</li><li>loadend 读取完成时触发，无论成功还是失败</li><li>loadstart 开始读取时触发</li><li>progress 定期触发</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>reader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;;<br>reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br></code></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/12/02/pAIBIbV.png"><br>可以看到使用 readAsDataURL 转换出的结果在 onload 事件入参的 target.result 属性</p><h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Base64">Base64</a> 是将二进制转化成 ASCII 字符的编码方式</p><h2 id="window-atob-window-btoa"><a href="#window-atob-window-btoa" class="headerlink" title="window.atob window.btoa"></a>window.atob window.btoa</h2><p>浏览器提供了两个方法用于 Base64 的编码和解码<br><img src="https://s21.ax1x.com/2024/12/02/pAIDaIU.png"></p><h1 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL"></a>URL.createObjectURL</h1><p>URL 提供了一个静态方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL_static">createObjectURL</a>，通过该方法可以对象创建一个临时的 URL 用来访问，浏览器卸载时会自动释放这个 url，当然还可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL_static">revokeObjectURL</a>来手动卸载。</p><h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(file);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(url);<br><span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url);<br></code></pre></td></tr></table></figure><p>通过 createObjectURL 给图片文件创建一个临时 url 然后在浏览器访问地址实现预览</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(file);<br><span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>a.<span class="hljs-property">href</span> = url;<br>a.<span class="hljs-property">download</span> = <span class="hljs-string">&quot;download.png&quot;</span>;<br>a.<span class="hljs-title function_">click</span>();<br><span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url);<br></code></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="将-DOM-上的-svg-转换成各种格式文件"><a href="#将-DOM-上的-svg-转换成各种格式文件" class="headerlink" title="将 DOM 上的 svg 转换成各种格式文件"></a>将 DOM 上的 svg 转换成各种格式文件</h2><p>思路就是先拿到 DOM 节点，然后通过 XMLSerializer 的 serializeToString 方法将 DOM 节点转为 string</p><p>然后通过 window.btoa 进行编码，</p><p>拼接成 dataURL 的格式，就可以传给 image 的 src 了</p><p>通过 image 的加载使用 canvas 画图，借助 toBlob 方法就可以转成 Blob 的格式，Blob 再转换成 File 就非常简单了。</p><blockquote><p>用以下代码需要有一个 svg</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> svgNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;svg&quot;</span>);<br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLSerializer</span>().<span class="hljs-title function_">serializeToString</span>(svgNode);<br><span class="hljs-comment">// base64</span><br><span class="hljs-keyword">const</span> base64 = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">btoa</span>(s)<br><span class="hljs-comment">// dataURL 格式</span><br><span class="hljs-keyword">const</span> encodedData = <span class="hljs-string">`data:image/svg+xml;base64,<span class="hljs-subst">$&#123;base64&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br><br>img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>  canvas.<span class="hljs-property">height</span> = img.<span class="hljs-property">height</span>;<br>  canvas.<span class="hljs-property">width</span> = img.<span class="hljs-property">width</span>;<br>  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// Blog 格式</span><br>  canvas.<span class="hljs-title function_">toBlob</span>(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// File 格式</span><br>    <span class="hljs-keyword">const</span> file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>([blob], <span class="hljs-string">&quot;image.png&quot;</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;image/png&quot;</span> &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(file);<br>    <span class="hljs-comment">// 图片下载</span><br>    <span class="hljs-keyword">const</span> url = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(file);<br>    <span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>    a.<span class="hljs-property">download</span> = <span class="hljs-string">&quot;img.png&quot;</span>;<br>    a.<span class="hljs-property">href</span> = url;<br>    a.<span class="hljs-title function_">click</span>();<br>  &#125;);<br>&#125;;<br>img.<span class="hljs-property">src</span> = encodedData;<br></code></pre></td></tr></table></figure><h2 id="修改上传图片的宽高"><a href="#修改上传图片的宽高" class="headerlink" title="修改上传图片的宽高"></a>修改上传图片的宽高</h2><p>这个思路和上个差不多，区别在于拿到的是 File 格式文件，需要先使用 FileReader 读取，然后在 canvas 画图时要使用新的宽高，这样画出来的图才是新的宽高。</p><blockquote><p>用以下代码需要有一个 type 为 file id 为 upload 的 input，一个 id 为 btn 的 button</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newWidth = <span class="hljs-number">200</span>;<br><span class="hljs-keyword">const</span> newHeight = <span class="hljs-number">200</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#btn&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> file = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#upload&quot;</span>).<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>  reader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    img.<span class="hljs-property">src</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>    img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>      canvas.<span class="hljs-property">width</span> = newWidth;<br>      canvas.<span class="hljs-property">height</span> = newHeight;<br>      <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>      ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, newWidth, newHeight);<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(canvas);<br>    &#125;;<br>  &#125;;<br>  <span class="hljs-comment">// 读取文件对象</span><br>  reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="canvas-drawImage"><a href="#canvas-drawImage" class="headerlink" title="canvas.drawImage"></a>canvas.drawImage</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">drawImage</span>(image, dx, dy)<br><span class="hljs-title function_">drawImage</span>(image, dx, dy, dWidth, dHeight)<br><span class="hljs-title function_">drawImage</span>(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)<br></code></pre></td></tr></table></figure><p>这个方法参数巨多，一般情况下只传三个就行了，但是遇到上文要修改图片宽高时，或者截取图片的某一部份时，其他参数就有作用了，下图来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage">MDN</a> 可以很直观的看到各个参数的含义。</p><p><img src="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage/canvas_drawimage.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>file</tag>
      
      <tag>blob</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识 Svelte</title>
    <link href="/2024/10/26/svelte/"/>
    <url>/2024/10/26/svelte/</url>
    
    <content type="html"><![CDATA[<h1 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h1><h2 id="state"><a href="#state" class="headerlink" title="#state"></a>#state</h2><p>svelte 的状态，横向对比 Vue 的 ref，react 的 state</p><p>和 Vue React 不同的是 svelte 的值可以直接修改，UI即可响应，并且 $state 深度响应，你可以使用对象或者数组的 api 来更改值，如果不想深度响应就用 $state.raw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs svelte">let a = $state([1,2,3])<br>let b = $state.snapshot([1,2,3])<br>console.log(&quot;代理的&quot;, a);<br>console.log(&quot;静态的&quot;, b);<br></code></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/12/06/pATsiu9.png"></p><p>使用 $state.snapshot 不会被代理</p><h2 id="derived"><a href="#derived" class="headerlink" title="$derived"></a>$derived</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script&gt;<br>let count = $state(0);<br>let doubled = $derived(count * 2);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>计算属性，当计算过程中的 state 值发生变化会重新计算，使用 $derived 计算不能传入带有副作用的计算表达式，并且在传入的计算表达式中不能修改 state 的值</p><p>如果计算过程有点复杂，无法用一个表达式解决问题，还可以使用 $derived.by 支持传入一个有返回值 function，</p><h2 id="effect"><a href="#effect" class="headerlink" title="$effect"></a>$effect</h2><p>$effect 会在组件安装到 DOM 后执行，$effect 不是必须放在最顶层，他可以放在任何地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script&gt;<br>let count = $state(0);<br>let milliseconds = $state(1000);<br><br><br>  function testEffect () &#123;<br>    $effect(() =&gt; &#123;<br>const interval = setInterval(() =&gt; &#123;<br>count += 1;<br>&#125;, milliseconds);<br><br>return () =&gt; &#123;<br>clearInterval(interval);<br>&#125;;<br>&#125;);<br>  &#125;<br>  testEffect()<br>&lt;/script&gt;<br><br>&lt;h1&gt;&#123;count&#125;&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>这么写虽然没什么意义，但可以证明 $effect 即使在一个 function 里也不会有任何问题</p><p>$effect 会自动识别内部的 $state、$props、$derived 并作为依赖项，当他们更新时 $effect 会重新执行</p><p>$effect 可以返回一个 function，该 function 会在销毁时执行，不过以下这种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script&gt;<br>let count = $state(&#123;<br>    name: &#x27;jack&#x27;<br>  &#125;);<br><br>  $effect(() =&gt; &#123;<br>    console.log(count);<br>  &#125;)<br>&lt;/script&gt;<br><br>&lt;h1&gt;&#123;count.name&#125;&lt;/h1&gt;<br>&lt;button onclick=&#123;() =&gt; count.name = &#x27;lucy&#x27;&#125;&gt;click&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>当点击 button 更改 state 的 name 时，$effect 是没办法识别到深层的更新的，处理这个问题有两种方式，第一种就是直接在 $effect 使用 count.name ，另外一种就是使用 $derived 计算属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script&gt;<br>let count = $state(&#123;<br>    name: &#x27;jack&#x27;<br>  &#125;);<br>  let name = $derived(count.name)<br>  $effect(() =&gt; &#123;<br>    console.log(name);<br>  &#125;)<br>&lt;/script&gt;<br><br>&lt;h1&gt;&#123;count.name&#125;&lt;/h1&gt;<br>&lt;button onclick=&#123;() =&gt; count.name = &#x27;lucy&#x27;&#125;&gt;click&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>还有一种情况是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script&gt;<br>  $effect(() =&gt; &#123;<br>    if (a || b) &#123;<br>      console.log(&#x27;inside if block&#x27;);<br>    &#125;<br>  &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>分别将 a 和 b 修改为 true ，但是打印只会执行一次，文档给出的解释是 effect 的执行效果取决于上次读到的值，大概就是说 a 已经为 true， b 不会对 effect 的执行产生更改，所以更改 b 不会触发 effect 执行</p><p>如果想在 DOM 更新前做点事，可以使用 $effect.pre，用法和 $effect 完全一致</p><p>另外 svelte 不建议直接在 $effect 同步状态，也就是修改 state 的值。</p><h2 id="props"><a href="#props" class="headerlink" title="$props"></a>$props</h2><p>用来接收父组件传来的值，该值一般来说不希望被修改，并且修改一般是没作用的，唯一特殊的情况是传来的值是 $state 值虽然被修改但是会抛出警告该值不是属于你的</p><h2 id="bindable"><a href="#bindable" class="headerlink" title="$bindable"></a>$bindable</h2><p>想允许自组件修改父组件的值，需要使用 $bindable</p><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script lang=&quot;ts&quot;&gt;<br>let &#123; value = $bindable() &#125; = $props();<br>&lt;/script&gt;<br><br>&lt;input bind:value=&#123;value&#125; /&gt;<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script&gt;<br>    import FancyInput from &quot;../FancyInput.svelte&quot;;<br>  let message = $state(&#x27;hello&#x27;);<br>&lt;/script&gt;<br><br>&lt;FancyInput bind:value=&#123;message&#125;/&gt;<br>&lt;p&gt;&#123;message&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>如果想给 $bindable 设置一个默认值，直接给 $bindable 入参即可 $bindable(默认值)</p><h2 id="inspect"><a href="#inspect" class="headerlink" title="$inspect"></a>$inspect</h2><p>在参数发生变化时，会在控制台打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&lt;script lang=&quot;ts&quot;&gt;<br>  const obj = $state( &#123;<br>    name: &#x27;jack&#x27;,<br>    age: 18,<br>    hobby: [&#x27;run&#x27;, &#x27;jump&#x27;]<br>  &#125;)<br><br>  const addHobby = () =&gt; &#123;<br>    obj.hobby.push(&#x27;ball&#x27;)<br>  &#125;<br><br>  $inspect(obj.hobby)<br>&lt;/script&gt;<br><br>&lt;main&gt;<br>  &lt;div&gt;&#123;obj.hobby.join(&#x27;,&#x27;)&#125;&lt;/div&gt;<br>  &lt;button onclick=&#123;addHobby&#125;&gt;addHobby&lt;/button&gt;<br>&lt;/main&gt;<br></code></pre></td></tr></table></figure><p>以上代码，在初始化时，$inspect 会输出 init 的值，当点击按钮进行更新时，会再次输出 update 的值</p><p><img src="https://s21.ax1x.com/2024/10/26/pAwjam6.png" alt="控制台输出"></p><blockquote><p>$inspect 执行返回一个 with 方法，该方法接收一个函数，函数有两个参数，一个是 type 初始化值为 init，更新时值为 update，第二个参数就是新的值</p></blockquote><h1 id="Template-syntax"><a href="#Template-syntax" class="headerlink" title="Template syntax"></a>Template syntax</h1><h2 id="snippet"><a href="#snippet" class="headerlink" title="$snippet"></a>$snippet</h2><p>使用 $snippet 声明代码片段，通过 @render 渲染使用代码片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs svelte">&#123;#snippet figure(image)&#125;<br>&lt;figure&gt;<br>&lt;img src=&#123;image.src&#125; alt=&#123;image.caption&#125; width=&#123;image.width&#125; height=&#123;image.height&#125; /&gt;<br>&lt;figcaption&gt;&#123;image.caption&#125;&lt;/figcaption&gt;<br>&lt;/figure&gt;<br>&#123;/snippet&#125;<br><br>&#123;#each images as image&#125;<br>&#123;#if image.href&#125;<br>&lt;a href=&#123;image.href&#125;&gt;<br>&#123;@render figure(image)&#125;<br>&lt;/a&gt;<br>&#123;:else&#125;<br>&#123;@render figure(image)&#125;<br>&#123;/if&#125;<br>&#123;/each&#125;ß<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>svelte</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next 配置项 next.config.js</title>
    <link href="/2024/09/04/next-05/"/>
    <url>/2024/09/04/next-05/</url>
    
    <content type="html"><![CDATA[<h1 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h1><p>headers 可以在请求头添加一些自定义内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nextConfig = &#123;<br>    <span class="hljs-attr">headers</span>: <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-keyword">return</span> [<br>            &#123;<br>                <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;/about/:id&#x27;</span>,<br>                <span class="hljs-attr">headers</span>: [<br>                    &#123;<br>                        <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;X-Frame-Options&#x27;</span>,<br>                        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;SAMEORIGIN&#x27;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;ID&#x27;</span>,<br>                        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;:id&#x27;</span><br>                    &#125;,<br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = nextConfig<br></code></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/09/04/pAZiV0S.png"></p><p>headers 是一个异步函数，source 代表路径，headers 是一个数组，数组中可以添加多个 <code>[key, value]</code> 的属性，并且还可以获取路由参数进行赋值，例如 <code>:id</code></p><blockquote><p>headers 同名属性会覆盖前面的属性。</p></blockquote><h2 id="header-的对象属性有哪些"><a href="#header-的对象属性有哪些" class="headerlink" title="header 的对象属性有哪些"></a>header 的对象属性有哪些</h2><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>请求路径，支持三种模式</p><ul><li>路径匹配 <code>source: &#39;/about/:id&#39;</code> 会匹配 about 下一层级路径，多层的不行，例如 <code>/about/1/detail</code> 匹配不到</li><li>通配符匹配 <code>source: &#39;/about/:id*&#39;</code> 在路径匹配基础上，支持匹配多层路径，例如 <code>/about/1/detail</code> 可以匹配到</li><li>正则匹配 <code>source: &#39;/about/:id(\\d+)&#39;</code> 支持正则匹配，例如 <code>/about/1/detail</code> 可以匹配到。另外要注意 <code>(、)、 &#123;、 &#125;、 :、 *、 +、 ?</code> 等特殊字符需要转义</li></ul><h2 id="basePath"><a href="#basePath" class="headerlink" title="basePath"></a>basePath</h2><p><a href="https://nextjs.org/docs/app/api-reference/next-config-js/basePath">basePath</a> 可选值为 <code>false | undefined</code>，当值设置为 false，source 在匹配时会忽略 basePath，使用 Link 跳转会自动加上 basePath</p><h2 id="has"><a href="#has" class="headerlink" title="has"></a>has</h2><p>匹配某些情况才设置 header</p><p>对象属性</p><ul><li>type 类型，可选值为 <code>header | cookie | host | query</code>，header 为请求头，cookie 为请求头的 Cookie，host 为 主机名+端口号，query 为 query参数</li><li>key 所选类型的 key</li><li>value 所选类型的 value</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nextConfig = &#123;<br>    <span class="hljs-attr">headers</span>: <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-keyword">return</span> [<br>            &#123;<br>                <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>                <span class="hljs-attr">has</span>: [<br>                    &#123;<br>                        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;query&#x27;</span>,<br>                        <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>                    &#125;,<br>                ],<br>                <span class="hljs-attr">headers</span>: [<br>                    <span class="hljs-comment">// ...</span><br>                ],<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = nextConfig<br></code></pre></td></tr></table></figure><p>以上代码就是当地址中存在 name 参数时，才会设置 header</p><h2 id="missing"><a href="#missing" class="headerlink" title="missing"></a>missing</h2><p>用法同 has，区别在于 missing 是不满足条件时，才设置 header</p><h1 id="redirects"><a href="#redirects" class="headerlink" title="redirects"></a>redirects</h1><p>一个异步函数，用于进行重定向</p><p>属性</p><ul><li>source 匹配路径</li><li>destination 重定向路径</li><li>permanent 是否永久重定向，可选值为 <code>true | false</code>，默认为 false，即临时重定向，307 状态码，当设置为 true 时，即永久重定向，308 状态码</li></ul><blockquote><p>为什么 Next 使用 307 状态码，而不是 302 状态码？</p><p>很多浏览器会将重定向的请求方法修改为 GET，而不管原本的方法是什么。举个例子，如果浏览器发送了一个 POST 请求，&#x2F;v1&#x2F;users ，然后返回了 302 状态码，新地址是 &#x2F;v2&#x2F;users，则后续的请求会是 GET &#x2F;V2&#x2F;users 而不是 POST &#x2F;v2&#x2F;users，Next.js 用 307 临时重定向和 308 永久重定向状态码就是为了显示保留之前使用的请求方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nextConfig = &#123;<br>    <span class="hljs-attr">redirects</span>: <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-keyword">return</span> [<br>            &#123;<br>                <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;/about/:id&#x27;</span>,<br>                <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>                <span class="hljs-attr">permanent</span>: <span class="hljs-literal">true</span><br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = nextConfig<br></code></pre></td></tr></table></figure><p>重定向会在文件系统（包括页面和 &#x2F;public 文件）之前被触发。</p><p>重定向不会应用于客户端路由（Link、router.push），除非使用了中间件，且有匹配的路径。</p><p>当应用重定向的时候，请求路径的参数也会传递给重定向目标路径：</p><p>在 redirect 中也可以使用 basePath、has、missing 等属性，用法同 headers。</p><p>&#x2F;&#x2F; 未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Next</tag>
      
      <tag>ssr</tag>
      
      <tag>ssg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next 元数据（metadata）</title>
    <link href="/2024/08/30/next-04/"/>
    <url>/2024/08/30/next-04/</url>
    
    <content type="html"><![CDATA[<h1 id="基于配置的元数据"><a href="#基于配置的元数据" class="headerlink" title="基于配置的元数据"></a>基于配置的元数据</h1><p>静态元数据还是动态元数据都只在服务端组件中支持，尽可能使用静态元数据。</p><h2 id="静态元数据"><a href="#静态元数据" class="headerlink" title="静态元数据"></a>静态元数据</h2><p>在 layout.js 或 page.js 中，导出 Metadata 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Next.js&#x27;</span>,<br>    <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Next.js is a framework for building dynamic websites&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态元数据"><a href="#动态元数据" class="headerlink" title="动态元数据"></a>动态元数据</h2><p>使用动态元数据要借助 <code>generateMetadata</code> 函数返回一个 Metadata 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateMetadata</span>(<span class="hljs-params">&#123; params, searchParams &#125;, parent</span>) &#123;<br>  <span class="hljs-comment">// 读取路由参数</span><br>  <span class="hljs-keyword">const</span> id = params.<span class="hljs-property">id</span><br> <br>  <span class="hljs-comment">// 获取数据</span><br>  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://.../<span class="hljs-subst">$&#123;id&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())<br> <br>  <span class="hljs-comment">// 获取和拓展父路由段 metadata</span><br>  <span class="hljs-keyword">const</span> previousImages = (<span class="hljs-keyword">await</span> parent).<span class="hljs-property">openGraph</span>?.<span class="hljs-property">images</span> || []<br> <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">title</span>: product.<span class="hljs-property">title</span>,<br>    <span class="hljs-attr">openGraph</span>: &#123;<br>      <span class="hljs-attr">images</span>: [<span class="hljs-string">&#x27;/some-specific-page-image.jpg&#x27;</span>, ...previousImages],<br>    &#125;,<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">&#123; params, searchParams &#125;</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>该函数接收两个参数，props 和 parent，props 包含当前路由参数的对象，该对象有 params 和 searchParams 两个属性</p><p>params 是动态路由参数的对象，当访问非动态路由，params 为 {}</p><table><thead><tr><th>路由</th><th>url</th><th>params</th></tr></thead><tbody><tr><td>app&#x2F;shop&#x2F;[slug]&#x2F;page.js</td><td>&#x2F;shop&#x2F;1</td><td>{ slug: ‘1’ }</td></tr><tr><td>app&#x2F;shop&#x2F;[tag]&#x2F;[item]&#x2F;page.js</td><td>&#x2F;shop&#x2F;1&#x2F;2</td><td>{ tag: ‘1’, item: ‘2’ }</td></tr><tr><td>app&#x2F;shop&#x2F;[…slug]&#x2F;page.js</td><td>&#x2F;shop&#x2F;1&#x2F;2</td><td>{ slug: [‘1’, ‘2’] }</td></tr></tbody></table><p>searchParams 是 URLSearchParams 对象，包含了 URL 中的查询参数</p><table><thead><tr><th>url</th><th>searchParams</th></tr></thead><tbody><tr><td>&#x2F;shop?a&#x3D;1</td><td>{ a: ‘1’ }</td></tr><tr><td>&#x2F;shop?a&#x3D;1&amp;b&#x3D;2</td><td>{ a: ‘1’, b: ‘2’ }</td></tr><tr><td>&#x2F;shop?a&#x3D;1&amp;a&#x3D;2</td><td>{ a: [‘1’, ‘2’] }</td></tr></tbody></table><p>parent 是一个包含父路由段 metadata 对象的 promise 对象，需要使用 (await parent).openGraph 获取。</p><h2 id="字段覆盖"><a href="#字段覆盖" class="headerlink" title="字段覆盖"></a>字段覆盖</h2><p>Next 会对各层的元数据进行浅合并，离当前页面越近的元数据会覆盖离当前页面越远的元数据。</p><h2 id="字段继承"><a href="#字段继承" class="headerlink" title="字段继承"></a>字段继承</h2><p>当前页的元数据会继承自己没定义的上层的元数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/layout.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;layout&#x27;</span>,<br>  <span class="hljs-attr">openGraph</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;...&#x27;</span>,<br>    <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;...&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/about/page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;page&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，page.js 中未定义 openGraph 而 他的上层 layout 定义了，所以 page 会继承 layout 的 openGraph 字段。</p><h2 id="JSON-LD"><a href="#JSON-LD" class="headerlink" title="JSON-LD"></a>JSON-LD</h2><p><a href="https://json-ld.org/">JSON-LD</a> 可以向搜索引擎描述网站上的内容。 在 Next 中使用 JSON-LD 可以在 layout 或者 page 中使用 script 标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">&#123; params &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProduct</span>(params.<span class="hljs-property">id</span>)<br> <br>  <span class="hljs-keyword">const</span> jsonLd = &#123;<br>    <span class="hljs-string">&#x27;@context&#x27;</span>: <span class="hljs-string">&#x27;https://schema.org&#x27;</span>,<br>    <span class="hljs-string">&#x27;@type&#x27;</span>: <span class="hljs-string">&#x27;Product&#x27;</span>,<br>    <span class="hljs-attr">name</span>: product.<span class="hljs-property">name</span>,<br>    <span class="hljs-attr">image</span>: product.<span class="hljs-property">image</span>,<br>    <span class="hljs-attr">description</span>: product.<span class="hljs-property">description</span>,<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">script</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/ld+json&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">JSON.stringify</span>(<span class="hljs-attr">jsonLd</span>) &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      &#123;<span class="hljs-comment">/* ... */</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &lt;/section&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基于文件的元数据"><a href="#基于文件的元数据" class="headerlink" title="基于文件的元数据"></a>基于文件的元数据</h1><p>基于文件的元数据优先级更高，会覆盖基于配置的元数据。</p><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>Next 的<a href="https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons">图标</a>就是在 &#x2F;app 目录下的 <code>favicon</code>、<code>icon</code>、<code>apple-icon</code> 图片文件。</p><p><code>favicon</code> 必须要在顶层目录（如 &#x2F;app 或 &#x2F;src&#x2F;app）下，<code>icon</code> 和 <code>apple-icon</code> 可以放在更深层的目录。</p><table><thead><tr><th>File convention</th><th>Supported file types</th><th>Valid locations</th><th>Link ref</th></tr></thead><tbody><tr><td>favicon</td><td>.ico</td><td>app&#x2F;</td><td><link rel="icon" /></td></tr><tr><td>icon</td><td>.ico、.jpg、.jpeg、.png、.svg</td><td>app&#x2F;**&#x2F;*</td><td><link rel="icon" /></td></tr><tr><td>apple-icon</td><td>.jpg、.jpeg、.png</td><td>app&#x2F;**&#x2F;*</td><td><link rel="apple-touch-icon" /></td></tr></tbody></table><h3 id="不同尺寸图标"><a href="#不同尺寸图标" class="headerlink" title="不同尺寸图标"></a>不同尺寸图标</h3><p>还可以在一个目录下放多个不同尺寸 icon ，可以根据不同尺寸显示不同 icon。</p><p><img src="https://s21.ax1x.com/2024/09/02/pAVEDfJ.png"></p><h3 id="使用代码生成"><a href="#使用代码生成" class="headerlink" title="使用代码生成"></a>使用代码生成</h3><p>文件名还是 icon 或者 apple-icon 后缀为 js、ts、tsx，通过 next&#x2F;og的 <a href="https://nextjs.org/docs/app/api-reference/functions/image-response">ImageResponse</a> 即可生成一个图标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/icon.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ImageResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/og&#x27;</span><br> <br><span class="hljs-comment">// 路由段配置</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> runtime = <span class="hljs-string">&#x27;edge&#x27;</span><br> <br><span class="hljs-comment">// 图片 metadata</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> size = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">32</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">32</span>,<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> contentType = <span class="hljs-string">&#x27;image/png&#x27;</span><br> <br><span class="hljs-comment">// 图片生成</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Icon</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageResponse</span>(<br>    (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">fontSize:</span> <span class="hljs-attr">24</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">background:</span> &#x27;<span class="hljs-attr">black</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">width:</span> &#x27;<span class="hljs-attr">100</span>%&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">100</span>%&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">display:</span> &#x27;<span class="hljs-attr">flex</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">alignItems:</span> &#x27;<span class="hljs-attr">center</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">justifyContent:</span> &#x27;<span class="hljs-attr">center</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">color:</span> &#x27;<span class="hljs-attr">white</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">        A</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    ),<br>    <span class="hljs-comment">// ImageResponse options</span><br>    &#123;<br>      <span class="hljs-comment">// 方便复用 size</span><br>      ...size,<br>    &#125;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="robot"><a href="#robot" class="headerlink" title="robot"></a>robot</h2><p>robot 用于告诉搜索引擎可以爬取网站中的哪些 URL，Next 中有两种方式设置 robot。</p><ol><li>静态文件<br>在 app&#x2F; 下创建 robot.txt 即可<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">User-Agent: *<br>Allow: /<br>Disallow: /private/<br>Sitemap: https://acme.com/sitemap.xml<br></code></pre></td></tr></table></figure></li><li>代码生成<br>使用 robot.js &#x2F; robot.ts<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">robots</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">rules</span>: &#123;<br>      <span class="hljs-attr">userAgent</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>      <span class="hljs-attr">allow</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-attr">disallow</span>: <span class="hljs-string">&#x27;/private/&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">sitemap</span>: <span class="hljs-string">&#x27;https://acme.com/sitemap.xml&#x27;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="站点地图-sitemap-xml"><a href="#站点地图-sitemap-xml" class="headerlink" title="站点地图 sitemap.xml"></a>站点地图 sitemap.xml</h2><p>站点地图是一个 XML 文件，用于告诉搜索引擎网站的结构，Next 中可以使用静态文件 sitemap.xml 或者 sitemap.js &#x2F; sitemap.ts 生成站点地图。</p><ol><li>静态文件<br>app&#x2F;sitemap.xml：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">urlset</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loc</span>&gt;</span>https://acme.com<span class="hljs-tag">&lt;/<span class="hljs-name">loc</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">lastmod</span>&gt;</span>2023-04-06T15:02:24.021Z<span class="hljs-tag">&lt;/<span class="hljs-name">lastmod</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">changefreq</span>&gt;</span>yearly<span class="hljs-tag">&lt;/<span class="hljs-name">changefreq</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">priority</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">priority</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loc</span>&gt;</span>https://acme.com/about<span class="hljs-tag">&lt;/<span class="hljs-name">loc</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">lastmod</span>&gt;</span>2023-04-06T15:02:24.021Z<span class="hljs-tag">&lt;/<span class="hljs-name">lastmod</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">changefreq</span>&gt;</span>monthly<span class="hljs-tag">&lt;/<span class="hljs-name">changefreq</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">priority</span>&gt;</span>0.8<span class="hljs-tag">&lt;/<span class="hljs-name">priority</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loc</span>&gt;</span>https://acme.com/blog<span class="hljs-tag">&lt;/<span class="hljs-name">loc</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">lastmod</span>&gt;</span>2023-04-06T15:02:24.021Z<span class="hljs-tag">&lt;/<span class="hljs-name">lastmod</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">changefreq</span>&gt;</span>weekly<span class="hljs-tag">&lt;/<span class="hljs-name">changefreq</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">priority</span>&gt;</span>0.5<span class="hljs-tag">&lt;/<span class="hljs-name">priority</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">urlset</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>代码生成<br>使用 sitemap.js &#x2F; sitemap.ts<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sitemap</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> [<br>    &#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://acme.com&#x27;</span>,<br>      <span class="hljs-attr">lastModified</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>      <span class="hljs-attr">changeFrequency</span>: <span class="hljs-string">&#x27;yearly&#x27;</span>,<br>      <span class="hljs-attr">priority</span>: <span class="hljs-number">1</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://acme.com/about&#x27;</span>,<br>      <span class="hljs-attr">lastModified</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>      <span class="hljs-attr">changeFrequency</span>: <span class="hljs-string">&#x27;monthly&#x27;</span>,<br>      <span class="hljs-attr">priority</span>: <span class="hljs-number">0.8</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://acme.com/blog&#x27;</span>,<br>      <span class="hljs-attr">lastModified</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>      <span class="hljs-attr">changeFrequency</span>: <span class="hljs-string">&#x27;weekly&#x27;</span>,<br>      <span class="hljs-attr">priority</span>: <span class="hljs-number">0.5</span>,<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="metadata-属性"><a href="#metadata-属性" class="headerlink" title="metadata 属性"></a>metadata 属性</h1><ol><li>title<br>值可以是字符串，也可以是对象，使用对象时，default 为子路由没定义 title 的默认值，template 为子路由添加一个前缀或者后缀，并且使用 template 的话，必须同时 有 default。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>  <span class="hljs-attr">title</span>: &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;%s | Acme&#x27;</span>,  <span class="hljs-comment">// %s 会被替换为子路由的 title</span><br>    <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;Acme&#x27;</span>,<br>   <br>    <span class="hljs-attr">absolute</span>: <span class="hljs-string">&#x27;About&#x27;</span> <span class="hljs-comment">// 设置标题，会忽略上层路由段设置的 title.template</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li>description<br>设置页面的描述</li><li>metadataBase<br>设置 metadata 字段中地址的前缀<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// layout.js | page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>  <span class="hljs-attr">metadataBase</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;https://acme.com&#x27;</span>),<br>  <span class="hljs-attr">alternates</span>: &#123;<br>    <span class="hljs-attr">canonical</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">languages</span>: &#123;<br>      <span class="hljs-string">&#x27;en-US&#x27;</span>: <span class="hljs-string">&#x27;/en-US&#x27;</span>,<br>      <span class="hljs-string">&#x27;de-DE&#x27;</span>: <span class="hljs-string">&#x27;/de-DE&#x27;</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">openGraph</span>: &#123;<br>    <span class="hljs-attr">images</span>: <span class="hljs-string">&#x27;/og-image.png&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>输出结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;link rel=<span class="hljs-string">&quot;canonical&quot;</span> href=<span class="hljs-string">&quot;https://acme.com&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">hreflang</span>=<span class="hljs-string">&quot;en-US&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://acme.com/en-US&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">hreflang</span>=<span class="hljs-string">&quot;de-DE&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://acme.com/de-DE&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:image&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;https://acme.com/og-image.png&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>使用 metadataBase 后，metadata 的地址还可以使用相对地址，Next 会进行自动合并，还会智能的处理多余的斜杠，当然如果 metadata 设置了绝对地址，metadataBase 会被忽略</li><li>openGraph<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>  <span class="hljs-attr">openGraph</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Next.js&#x27;</span>,<br>    <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;The React Framework for the Web&#x27;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;article&#x27;</span>,<br>    <span class="hljs-attr">publishedTime</span>: <span class="hljs-string">&#x27;2023-01-01T00:00:00.000Z&#x27;</span>,<br>    <span class="hljs-attr">authors</span>: [<span class="hljs-string">&#x27;Seb&#x27;</span>, <span class="hljs-string">&#x27;Josh&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>输出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;meta property=<span class="hljs-string">&quot;og:title&quot;</span> content=<span class="hljs-string">&quot;Next.js&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;The React Framework for the Web&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;article&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;article:published_time&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;2023-01-01T00:00:00.000Z&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;article:author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Seb&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;article:author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Josh&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>robots<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// layout.js | page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>  <span class="hljs-attr">robots</span>: &#123;<br>    <span class="hljs-attr">index</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">follow</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">nocache</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">googleBot</span>: &#123;<br>      <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">follow</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">noimageindex</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&#x27;max-video-preview&#x27;</span>: -<span class="hljs-number">1</span>,<br>      <span class="hljs-string">&#x27;max-image-preview&#x27;</span>: <span class="hljs-string">&#x27;large&#x27;</span>,<br>      <span class="hljs-string">&#x27;max-snippet&#x27;</span>: -<span class="hljs-number">1</span>,<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>输出的 HTML：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;meta name=<span class="hljs-string">&quot;robots&quot;</span> content=<span class="hljs-string">&quot;noindex, follow, nocache&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;googlebot&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index, nofollow, noimageindex, max-video-preview:-1, max-image-preview:large, max-snippet:-1&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">/&gt;</span></span><br></code></pre></td></tr></table></figure> …</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Next</tag>
      
      <tag>ssr</tag>
      
      <tag>ssg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next 组件篇</title>
    <link href="/2024/08/28/next-03/"/>
    <url>/2024/08/28/next-03/</url>
    
    <content type="html"><![CDATA[<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://nextjs.org/docs/app/api-reference/components/image">Image</a> 是 Next 提供的组件之一，使用 Image 时就像使用 Image 标签一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/image&#x27;</span><br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Image</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/profile.png&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">width</span>=<span class="hljs-string">&#123;500&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;500&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Picture of the author&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/08/28/pAAA5xx.png" alt="支持的Props"></p><h2 id="必须的属性"><a href="#必须的属性" class="headerlink" title="必须的属性"></a>必须的属性</h2><p>在使用 Image 时，<code>src</code>、<code>width</code> 和 <code>height</code> 是必须的属性。</p><p>src 支持图片路径的格式，但是要注意如果使用远程地址，需要在 next.config.js 中声明支持的远程地址图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// next.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">images</span>: &#123;<br>    <span class="hljs-attr">remotePatterns</span>: [<br>      &#123;<br>        <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https&#x27;</span>,<br>        <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;s3.amazonaws.com&#x27;</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/my-bucket/**&#x27;</span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>另外也支持<a href="https://nextjs.org/docs/app/building-your-application/optimizing/images#local-images">静态的 import 导入</a>的图片，使用 await import 是不行的，在构建时无法被分析。并且如果使用了 import 导入的图片，那么就不需要使用 <code>width</code> 和 <code>height</code> 了。</p><p>width 和 height 用来推断宽高比，除非是静态导入图片或者图片有 fill 属性，否则为必选项。</p><h2 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h2><ul><li><p>alt 图片描述，用于 SEO 和在图片被禁用或者加载失败时显示。</p></li><li><p>loader 解析图片地址的自定义函数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br> <br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/image&#x27;</span><br> <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">imageLoader</span> = (<span class="hljs-params">&#123; src, width, quality &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`https://example.com/<span class="hljs-subst">$&#123;src&#125;</span>?w=<span class="hljs-subst">$&#123;width&#125;</span>&amp;q=<span class="hljs-subst">$&#123;quality || <span class="hljs-number">75</span>&#125;</span>`</span><br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Image</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">loader</span>=<span class="hljs-string">&#123;imageLoader&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;me.png&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Picture of the author&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">width</span>=<span class="hljs-string">&#123;500&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;500&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>fill 是否填充父元素，默认为 false，当开启这个属性时，父元素必须 position 为 <code>relative</code>、<code>fixed</code>、<code>absolute</code>，img 元素会默认自动指定为 <code>position: &quot;absolute&quot;</code>。<br>关于填充还可以通过 CSS 的方式来实现，<code>object-fit: &quot;contain&quot;</code> 和 <code>object-fit: &quot;cover&quot;</code> 都可以用来填充父元素，他们的区别在于<br>使用 fill 属性时，图片会被拉伸以填充父元素；<br>使用 <code>object-fit: &quot;container&quot;</code> 时图片在保持其宽高比的同时填充元素的整个内容框；<br>使用 <code>object-fit: &quot;cover&quot;</code> 时图片在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框；</p></li><li><p>sizes<br>img 有一个属性 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">srcset</a> 可以根据不同设备显示不同的图片<br>根据分辨率显示图片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;img<br>  srcset=<span class="hljs-string">&quot;elva-fairy-320w.jpg, elva-fairy-480w.jpg 1.5x, elva-fairy-640w.jpg 2x&quot;</span><br>  src=<span class="hljs-string">&quot;elva-fairy-640w.jpg&quot;</span><br>  alt=<span class="hljs-string">&quot;Elva dressed as a fairy&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>在一般情况下显示 elva-fairy-320w.jpg 图片即可，当用户的分辨率比较高的时候，会根据用户的分辨率选择 elva-fairy-480w.jpg 或者 elva-fairy-640w.jpg</p><p>根据设备大小显示图片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;img<br>  srcset=<span class="hljs-string">&quot;elva-fairy-small.jpg 480w, elva-fairy-large.jpg 800w&quot;</span><br>  src=<span class="hljs-string">&quot;elva-fairy-large.jpg&quot;</span><br>  alt=<span class="hljs-string">&quot;Elva dressed as a fairy&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>有两种图片可以选择，elva-fairy-small.jpg 宽度为 480px，elva-fairy-large.jpg 宽度为 800px，不过当窗口宽度不能匹配图片的宽度，也就是窗口宽度为 680px 时，还需要配合使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#sizes">sizes</a> 属性帮助浏览器选择合适的图片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;img<br>  srcset=<span class="hljs-string">&quot;elva-fairy-small.jpg 480w, elva-fairy-large.jpg 800w&quot;</span><br>  sizes=<span class="hljs-string">&quot;(max-width: 600px) 480px,</span><br><span class="hljs-string">         800px&quot;</span><br>  src=<span class="hljs-string">&quot;elva-fairy-large.jpg&quot;</span><br>  alt=<span class="hljs-string">&quot;Elva dressed as a fairy&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>sizes 首先 <code>(max-width: 600px)</code> 是一个媒体条件，看当前视口是否小于等于 600px ，如果是，则使用 480px 的图片，否则使用 800px 的图片。</p><p>不过 Next 的 Image 并需要设置 srcset 属性，Next 会自动生成，如果你不设置组件的 sizes 属性，Next.js 会用 1x、2x 这种像素密度描述符，而如果你设置了 sizes 属性，Next.js 会用 640w、750w 这种固有宽度描述符。</p></li><li><p>quality<br>优化图片的质量，值为 <code>1</code> 到 <code>100</code> 之间的整数，越大品质越好。</p></li><li><p>priority<br>图片加载优先级，<code>boolean</code> 类型，默认为 <code>false</code>，设置为 <code>true</code> 时，图片优先级高并预加载，开启这个属性会禁用懒加载。</p></li><li><p>placeholder<br>占位符，默认值为 <code>empty</code>，没有占位符<br>值为 <code>blur</code> 时使用 blurDataURL 的值作为占位符图片 src 属性值是 import 静态导入的，会自动生成 blurDataURL值<br>值为 <code>data:image/...</code> 时, 使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/URI/Schemes/data">Data URL</a> 作为图片加载时的占位图片</p></li><li><p>blurDataURL<br>当 placeholder 是，使用该值作为占位符。必须是 base64 编码的图片。</p></li><li><p>onLoadingComplete<br>图片加载完毕执行该回调函数，删除占位符图片，需要使用客户端组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;use client&#x27;</span><br>&lt;<span class="hljs-title class_">Image</span> onLoadingComplete=&#123;<span class="hljs-function">(<span class="hljs-params">img</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(img.<span class="hljs-property">naturalWidth</span>)&#125; /&gt;<br></code></pre></td></tr></table></figure></li><li><p>onLoad<br>图片加载完的时候执行，但该回调函数可能会在占位符被删除以及图片被完全解码前执行。需要使用客户端组件。</p></li><li><p>onError<br>加载失败执行，需要使用客户端组件。</p></li><li><p>loading<br>图片加载行为，默认为 loading 懒加载，值为 eager 的时候，图片会被立即加载，但影响性能。</p></li><li><p>unoptimized<br>关闭优化，使用源图片，默认为 false</p></li></ul><h2 id="在-next-config-js-中配置"><a href="#在-next-config-js-中配置" class="headerlink" title="在 next.config.js 中配置"></a>在 next.config.js 中配置</h2><ul><li>remotePatterns<br>配置支持的远程地址图片，在上文中有提到。</li><li>loaderFile<br>作用于所有 next&#x2F;image 的 loader 函数</li><li>deviceSizes<br>声明一系列的设备宽度断点，用来推断正确加载的图片<br>默认值是 <code>deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],</code></li><li>imageSizes<br>声明一系列的图片宽度<br>默认值是 <code>imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],</code><br>和 deviceSizes 区别在于 deviceSizes 用来处理大图片，imageSizes 用来处理小图片。而且 imageSizes 只会在图片使用了 sizes prop 的时候生效。</li><li>formats<br>Next 的 <a href="https://nextjs.org/docs/app/api-reference/components/image#loader">Image Optimization API</a> 会自动检测浏览器支持的图片格式<br>当匹配多个格式，按照数组顺序优先使用</li><li>minimumCacheTTL<br>设置缓存优化请求图片的过期时间，单位为秒</li><li>disableStaticImages<br>处理图片静态导入和其他插件冲突问题</li><li>dangerouslyAllowSVG<br>使用默认图像优化 API 优化 SVG 图像</li></ul><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p>Next 导航的主要方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/page.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/link&#x27;</span><br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/dashboard&quot;</span>&gt;</span>Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p><img src="https://s21.ax1x.com/2024/08/29/pAADHIO.png" alt="props"></p><ul><li>href：必填属性，指定跳转地址，支持传入对象，对象的属性有：<br>href：’<a href="http://user:pass@host.com:8080/p/a/t/h?query=string#hash">http://user:pass@host.com:8080/p/a/t/h?query=string#hash</a>‘<br>protocol：’http:’<br>host: ‘host.com:8080’<br>auth: ‘user:pass’<br>hostname: ‘host.com’<br>port: ‘8080’<br>pathname: ‘&#x2F;p&#x2F;a&#x2F;t&#x2F;h’<br>search: ‘?query&#x3D;string’<br>path: ‘&#x2F;p&#x2F;a&#x2F;t&#x2F;h?query&#x3D;string’<br>query: ‘query&#x3D;string’ or {‘query’:’string’}<br>hash: ‘#hash’</li><li>replace：history.replace 替换当前路由并且不会产生历史记录，默认为 false</li><li>scroll：是否在跳转时滚动到页面顶部，默认为 false</li><li>prefetch：是否预加载，默认为 true，预加载仅在生产环境开启</li><li>其他的 props 会传递到底层的 a 标签</li></ul><h1 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h1><p>加载执行第三方脚本</p><h2 id="Props-1"><a href="#Props-1" class="headerlink" title="Props"></a>Props</h2><p><img src="https://s21.ax1x.com/2024/08/29/pAArUw6.png" alt="prop"></p><ul><li>src：指定加载的脚本源地址</li><li>strategy：加载策略，<ol><li>beforeInteractive： 在可交互前加载，适用于如机器人检测、Cookie 管理等</li><li>afterInteractive：默认值，在可交互后加载，适用于如数据统计等</li><li>lazyOnload：在浏览器空闲时间加载</li><li>worker：（实验性质）通过 web worker 加载</li></ol></li><li>onLoad：脚本加载完成时执行的回调函数</li><li>onReady：组件每次重新挂载的时候执行</li><li>onError：捕获错误</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Next</tag>
      
      <tag>ssr</tag>
      
      <tag>ssg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next 路由篇</title>
    <link href="/2024/08/12/next-02/"/>
    <url>/2024/08/12/next-02/</url>
    
    <content type="html"><![CDATA[<h1 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h1><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>基本使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/link&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>To About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useRouter"><a href="#useRouter" class="headerlink" title="useRouter"></a>useRouter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><span class="hljs-keyword">import</span> &#123;useRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/navigation&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">toAbout</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/about&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toAbout&#125;</span>&gt;</span>To About<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 useRouter 必须在客户端组件，也就是在文件顶部加上 <code>&#39;use client&#39;</code> 还有就是 <code>useRouter</code> 是 “next&#x2F;navigation” 导入的，不是 “next&#x2F;router”。</p><h2 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/about&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端组件使用 redirect 进行重定向跳转。</p><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history 是浏览器提供的原生跳转方式，有 pushState 和 replaceState 两种方式，前者是向路由栈推一条新的路由，后者是直接将当前条替换掉</p><h2 id="跳转行为"><a href="#跳转行为" class="headerlink" title="跳转行为"></a>跳转行为</h2><p>在 App Router 下跳转后默认滚动到顶部，使用导航的前进后退会保持原来的滚动距离</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/link&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">scroll</span>=<span class="hljs-string">&#123;false&#125;</span>&gt;</span>To About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过给 Link 标签添加 scroll 属性，或者使用 router 跳转时第二个参数对象加上 <code>scroll: false</code> 禁用行为。</p><h1 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h1><p>动态路由需要用<code>[]</code>将文件夹名包住，例如新建如下结构目录：<br><img src="https://s21.ax1x.com/2024/08/12/pApMnS0.png"></p><p>在 <code>src/app/dynamic-routing/[id]/page.js</code> 就是一个 id 的动态路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; params &#125; = props;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;params.id&#125;<span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时访问 <code>/dynamic-routing/111</code> 页面现实的结果就是 111</p><p>但如果有多个参数的情况以上方法就不好用了，这时只需要将文件夹的名改成 <code>[...params]</code>，声明接收所有参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> params = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(props.<span class="hljs-property">params</span>.<span class="hljs-property">params</span>)<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;params&#125;<span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们访问 <code>/dynamic-routing/name/age/hobby</code> 来看下效果</p><p><img src="https://s21.ax1x.com/2024/08/12/pApMJYR.png"></p><p>可以看到的是参数是以数组的形式传递进来的。</p><h1 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h1><p>通过使用 <code>()</code> 包裹文件夹名创建分组，通过 <code>()</code> 创建的文件夹不会出现在路由的路径中，例如下图 <code>(group1)</code> 和 <code>(group2)</code> 并不会对路由产生影响，也正因如此，<strong>即使在不同分组下，也不能创建同名的文件夹</strong></p><p><img src="https://s21.ax1x.com/2024/08/12/pApQNNj.png" alt="路由组"></p><h2 id="多个根布局"><a href="#多个根布局" class="headerlink" title="多个根布局"></a>多个根布局</h2><p>使用路由组后，可以给每个组单独设置 layout，也就是在每个分组下新建 layout.js，如果这样做的话，就需要删除掉 app 下的 layout.js，并且因为是根布局，每个分组下的 layout 都需要有 <html> 和 <body> 标签。<br>只是删除 app 下的 layout.js 的话，还是会报错，因为还需要将 app 下的 page.js 放入到某一个分组下，需要注意的是，放在某个分组下就会使用这个分组的 layout。</p><h2 id="平行路由"><a href="#平行路由" class="headerlink" title="平行路由"></a>平行路由</h2><p>当一个页面布局需要多个页面显示在一起的时候可以使用平行路由，通过 <code>@</code> 作为文件夹的开头声明这是一个平行路由，在平行路由的 layout 中通过 props 拿到并渲染</p><p><img src="https://s21.ax1x.com/2024/08/12/pApQIKK.png" alt="目录结构"></p><p>layout.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">&#123; children, address, contact &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">        &#123;address&#125;</span><br><span class="language-xml">        &#123;contact&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>并且平行路由还可以嵌套子路由，例如在 @address 下新增 detail&#x2F;page.js ，然后在 layout 中加入跳转 <code>&lt;Link href=&quot;/detail&quot;&gt;to detail&lt;/Link&gt;</code></p><p><img src="/img/next-10.gif" alt="效果图"></p><p>可以看到当进行跳转时，只有 address 部分进行了更新，然后我们刷新页面会发现页面404了</p><p><img src="https://s21.ax1x.com/2024/08/12/pAp3MC9.png"></p><p>为什么会出现以上的情况呢？简单来说我们给 @address 加了 detail 的子路由，而 @contact 没有，当通过 Link 软导航跳转时，Next 进行了部分渲染，也就是对匹配上路由的 @address 进行更新，而 @contact 匹配不上，保留了原来的状态，当我们刷新浏览器进行硬导航时，Next 没办法判断不匹配路由，也就是 @contact 的状态没办法进行渲染，所以 404。</p><p>想要解决 404 的问题，我们需要给不匹配的路由增加 default.js 在不匹配时显示</p><p><img src="https://s21.ax1x.com/2024/08/12/pAp325Q.png"></p><p>效果<br><img src="/img/next-12.gif"></p><h1 id="路由拦截"><a href="#路由拦截" class="headerlink" title="路由拦截"></a>路由拦截</h1><p>Next 提供路由拦截功能，当从一个路由跳转到新的路由可以进行拦截渲染。</p><p>实现方式：在文件夹名前加上 <code>(.)</code> 声明拦截路由，按照官网说的不同数量的 . 代表拦截不同层级</p><ul><li>(.)来匹配同一层级</li><li>(..)来匹配上一层级</li><li>(..)(..)来匹配上两层</li><li>(…)来匹配应用程序根目录</li></ul><p>我们新建一个 product ，这里希望使用 (.)detail 拦截 <code>&#39;/product/detail&#39;</code></p><p><img src="https://s21.ax1x.com/2024/08/12/pApGlm6.png" alt="目录结构"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// (.)detail/page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>    <span class="hljs-keyword">return</span><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>拦截 Product Detail<span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>剩下的文件随便写点内容即可，我们看下效果</p><p><img src="/img/next-15.gif"></p><p>可以看到当我们从 &#x2F;product 跳转到 &#x2F;product&#x2F;detail 时被拦截了，而我们硬导航刷新页面则不会被拦截。</p><h1 id="路由处理程序"><a href="#路由处理程序" class="headerlink" title="路由处理程序"></a>路由处理程序</h1><p>Next 中命名为 route.js 的文件路由处理程序，也就是负责请求的文件，该文件必须在 app 目录下，并且不能和 page.js 同级。因为在同级的情况下，请求和页面路径相同产生冲突。</p><p>我们新增 api&#x2F;test&#x2F;route.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;xxxxxxxxx&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里写了一个最简单的 GET 请求，通过 <code>/api/test</code> 即可访问接口，除了 GET 请求还有 POST、PUT、PATCH、DELETE、HEAD 和 OPTIONS ，另外每个请求都有两个参数 request 和 context。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request, context</span>)&#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">request, context</span>)&#123;&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><p>request 是对 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">Web Request API</a> 的扩展</p><p><img src="https://s21.ax1x.com/2024/08/12/pApNPCF.png" alt="request"></p><h3 id="通过-request-获取-search-参数"><a href="#通过-request-获取-search-参数" class="headerlink" title="通过 request 获取 search 参数"></a>通过 request 获取 search 参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-keyword">const</span> field = request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>)<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过 request.nextUrl.searchParams.get() 的方法来获取 search 参数</p><h3 id="通过-request-获取-body-参数"><a href="#通过-request-获取-body-参数" class="headerlink" title="通过 request 获取 body 参数"></a>通过 request 获取 body 参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> request.<span class="hljs-title function_">json</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>(&#123; res &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们写一个 POST 请求，然后随便传递参数进来看打印结果。</p><p><img src="https://s21.ax1x.com/2024/08/12/pApNkv9.png"></p><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context 只有一个 params，这里我们新建目录来测试<br><img src="https://s21.ax1x.com/2024/08/12/pApNmE6.png"></p><p>我们让接口地址传入一个 name 参数进来，看看 context 会打印出什么</p><p><img src="https://s21.ax1x.com/2024/08/12/pApNu4O.png"></p><p>我接口调用 <code>/api/jack</code> 可以看到 context 输出了 name为 jack 的对象，如果有多个参数需要传递，也可以使用上文说到的 <code>[...params]</code> 的方式命名文件夹，参数会以数组的形式传递进来。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h2 id="NextResponse"><a href="#NextResponse" class="headerlink" title="NextResponse"></a>NextResponse</h2><p>NextResponse 是 Next 提供的网络响应 API，他是对<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response">Response</a>的扩展，在生产环境下，使用 Response 或者 NextResponse 的 GET 请求会被缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleTimeString</span>() &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们写一行这样一段 api 然后 执行 <code>npm run build</code> 打包，再执行 <code>npm run start</code> <a href="https://nextjs.org/docs/app/building-your-application/deploying">构建</a></p><p>这时我们访问这个接口发现日期是不会更新的</p><h2 id="退出缓存的方式"><a href="#退出缓存的方式" class="headerlink" title="退出缓存的方式"></a>退出缓存的方式</h2><ol><li>GET 请求使用 Request 对象 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-keyword">const</span> params = request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">searchParams</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleTimeString</span>(), <span class="hljs-attr">params</span>: params.<span class="hljs-title function_">toString</span>() &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>添加其他的请求，如 POST</li><li>手动声明为动态模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NextResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic = <span class="hljs-string">&#x27;force-dynamic&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleTimeString</span>() &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>设置缓存失效<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置重新验证频率为 10s 就是十秒后第一次请求还是会拿到缓存值，再次请求才会拿到新的值</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleTimeString</span>() &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h1><p>中间件一般用来拦截应用的请求和响应，一般写在 src 文件夹下，也就是存放路由页面的根目录（当然可以不是 src）。</p><p><img src="https://s21.ax1x.com/2024/08/13/pApTPjH.png" alt="目录结构"></p><p>官网给了一个中间件的例子，功能就是拦截一个路由并且进行重定向。这里可以根据自己的例子修改下路由即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NextResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;/&#x27;</span>, request.<span class="hljs-property">url</span>))<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = &#123;<br>   <span class="hljs-attr">matcher</span>: <span class="hljs-string">&#x27;/product/:path*&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="/img/next-redirect.gif" alt="效果图"></p><p>可以看到当访问 &#x2F;product&#x2F;detail 时，被重定向到 &#x2F; 说明我们写的 middleware 生效了。</p><h2 id="matcher"><a href="#matcher" class="headerlink" title="matcher"></a>matcher</h2><p>matcher 就是用来选中拦截的路由，只有一个时用字符串即可，就像上面的例子一样，如果是多个情况，也可以使用数组。还可以用<code>()</code>包裹正则表达式进行匹配。</p><p>官网提供了一个例子，匹配了除特定路径之外的所有路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">matcher</span>: [<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Match all request paths except for the ones starting with:</span><br><span class="hljs-comment">     * - api (API routes)</span><br><span class="hljs-comment">     * - _next/static (static files)</span><br><span class="hljs-comment">     * - _next/image (image optimization files)</span><br><span class="hljs-comment">     * - favicon.ico (favicon file)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-string">&#x27;/((?!api|_next/static|_next/image|favicon.ico).*)&#x27;</span>,<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><p>matcher 还可以是一个对象数组，通过对象属性进一步严格匹配，has 匹配有该属性和值，missing 匹配不存在该属性和值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">matcher</span>: [<br>    &#123;<br>      <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;/((?!api|_next/static|_next/image|favicon.ico).*)&#x27;</span>,<br>      <span class="hljs-attr">missing</span>: [<br>        &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;header&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;next-router-prefetch&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;header&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;purpose&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;prefetch&#x27;</span> &#125;,<br>      ],<br>      <span class="hljs-attr">has</span>: [<br>         &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;header&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;Authorization&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Bearer Token&#x27;</span> &#125;<br>      ],<br>    &#125;,<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><p>就像上面例子，missing 规定 <code>header</code> 不能存在 <code>next-router-prefetch</code> 且 <code>purpose</code> 值不为 <code>prefetch</code>，has 规定 <code>header</code> 的 <code>Authorization</code> 的值需要为 <code>Bearer Token</code> 的。</p><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>匹配路由除了使用 config 的 matcher 还可以直接在 middleware 中进行判断，效果和上面是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NextResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) &#123;<br>   <span class="hljs-keyword">if</span> (request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/product/&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">rewrite</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;/&#x27;</span>, request.<span class="hljs-property">url</span>))<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读取和设置-cookie"><a href="#读取和设置-cookie" class="headerlink" title="读取和设置 cookie"></a>读取和设置 cookie</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) &#123;<br>   <span class="hljs-keyword">let</span> cookie = request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;nextjs&#x27;</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cookie) <span class="hljs-comment">// =&gt; &#123; name: &#x27;nextjs&#x27;, value: &#x27;fast&#x27;, Path: &#x27;/&#x27; &#125;</span><br>   <span class="hljs-keyword">const</span> allCookies = request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">getAll</span>()<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allCookies) <span class="hljs-comment">// =&gt; [&#123; name: &#x27;nextjs&#x27;, value: &#x27;fast&#x27; &#125;]</span><br><br>   request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;nextjs&#x27;</span>) <span class="hljs-comment">// =&gt; true</span><br>   request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;nextjs&#x27;</span>)<br>   request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;nextjs&#x27;</span>) <span class="hljs-comment">// =&gt; false</span><br><br>   <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()<br>   response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;vercel&#x27;</span>, <span class="hljs-string">&#x27;fast&#x27;</span>)<br>   response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vercel&#x27;</span>,<br>      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;fast&#x27;</span>,<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>   &#125;)<br>   cookie = response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;vercel&#x27;</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cookie) <span class="hljs-comment">// =&gt; &#123; name: &#x27;vercel&#x27;, value: &#x27;fast&#x27;, Path: &#x27;/&#x27; &#125;</span><br><br>   <span class="hljs-keyword">return</span> response<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 request 的 get 和 getAll 方法读取 cookie 的值，通过 has 查看是否存在某值，通过 delete 方法删除 cookie 的值。</p><p><code>NextResponse.next()</code> 执行该方法会返回一个新的 Response 对象，通过 set 方法设置 cookie 的值。</p><h2 id="读取和设置-header"><a href="#读取和设置-header" class="headerlink" title="读取和设置 header"></a>读取和设置 header</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NextResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-comment">// 克隆请求头</span><br>    <span class="hljs-keyword">const</span> requestHeaders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(request.<span class="hljs-property">headers</span>)<br>    <span class="hljs-comment">// 在请求前设置请求头</span><br>    requestHeaders.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;x-hello-from-middleware1&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>)<br><br>    <span class="hljs-comment">// You can also set request headers in NextResponse.next</span><br>    <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>(&#123;<br>        <span class="hljs-attr">request</span>: &#123;<br>            <span class="hljs-comment">// New request headers</span><br>            <span class="hljs-attr">headers</span>: requestHeaders,<br>        &#125;,<br>    &#125;)<br><br>    <span class="hljs-comment">// 设置响应头</span><br>    response.<span class="hljs-property">headers</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;x-hello-from-middleware2&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">return</span> response<br>&#125;<br></code></pre></td></tr></table></figure><p>响应头加上了 <code>x-hello-from-middleware2</code><br><img src="https://s21.ax1x.com/2024/08/16/pACEBuQ.png"></p><h2 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NextResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span><br><br><span class="hljs-keyword">const</span> allowedOrigins = [<span class="hljs-string">&#x27;https://acme.com&#x27;</span>, <span class="hljs-string">&#x27;https://my-app.org&#x27;</span>]<br><br><span class="hljs-keyword">const</span> corsOptions = &#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="hljs-string">&#x27;GET, POST, PUT, DELETE, OPTIONS&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="hljs-string">&#x27;Content-Type, Authorization&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-comment">// 获取请求源</span><br>    <span class="hljs-keyword">const</span> origin = request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;origin&#x27;</span>) ?? <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;origin:&quot;</span>, origin)<br>    <span class="hljs-comment">// 是否在允许源的白名单中</span><br>    <span class="hljs-keyword">const</span> isAllowedOrigin = allowedOrigins.<span class="hljs-title function_">includes</span>(origin)<br><br>    <span class="hljs-comment">// 处理预请求</span><br>    <span class="hljs-keyword">const</span> isPreflight = request.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;OPTIONS&#x27;</span><br>    <span class="hljs-keyword">if</span> (isPreflight) &#123;<br>        <span class="hljs-keyword">const</span> preflightHeaders = &#123;<br>            ...(isAllowedOrigin &amp;&amp; &#123; <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: origin &#125;),<br>            ...corsOptions,<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>(&#123;&#125;, &#123; <span class="hljs-attr">headers</span>: preflightHeaders &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 处理简单请求</span><br>    <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">if</span> (isAllowedOrigin) &#123;<br>        response.<span class="hljs-property">headers</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)<br>    &#125;<br><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(corsOptions).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> &#123;<br>        response.<span class="hljs-property">headers</span>.<span class="hljs-title function_">set</span>(key, value)<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> response<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = &#123;<br>    <span class="hljs-attr">matcher</span>: <span class="hljs-string">&#x27;/api/:path*&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生成响应"><a href="#生成响应" class="headerlink" title="生成响应"></a>生成响应</h2><p>通过 Response 或 NextResponse 直接返回响应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">NextResponse</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/server&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = &#123;<br>   <span class="hljs-attr">matcher</span>: <span class="hljs-string">&#x27;/api/:function*&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) &#123;<br>   <span class="hljs-comment">// return Response.json(</span><br>   <span class="hljs-comment">//     &#123; success: false, message: &#x27;authentication failed --Response&#x27; &#125;,</span><br>   <span class="hljs-comment">//     &#123; status: 401 &#125;</span><br>   <span class="hljs-comment">// )</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NextResponse</span>(<br>           <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;authentication failed --NextResponse&#x27;</span> &#125;),<br>           &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">401</span> &#125;<br>   )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高级中间件标志"><a href="#高级中间件标志" class="headerlink" title="高级中间件标志"></a>高级中间件标志</h2><h3 id="skipMiddlewareUrlNormalize"><a href="#skipMiddlewareUrlNormalize" class="headerlink" title="skipMiddlewareUrlNormalize"></a>skipMiddlewareUrlNormalize</h3><p>跳过尾部斜杠重定向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// next.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>   <span class="hljs-comment">// 跳过尾部斜杠重定向</span><br>   <span class="hljs-attr">skipTrailingSlashRedirect</span>: <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// middleware.js</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">NextResponse</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/server&quot;</span>;<br><br><span class="hljs-keyword">const</span> legacyPrefixes = [<span class="hljs-string">&#x27;/product&#x27;</span>]<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">req</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; pathname &#125; = req.<span class="hljs-property">nextUrl</span><br><br>    <span class="hljs-keyword">if</span> (legacyPrefixes.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">prefix</span>) =&gt;</span> pathname.<span class="hljs-title function_">startsWith</span>(prefix))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()<br>    &#125;<br><br>    <span class="hljs-comment">// apply trailing slash handling</span><br>    <span class="hljs-keyword">if</span> (<br>        !pathname.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp;<br>        !pathname.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/</span>)<br>    ) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;req.nextUrl.pathname&#125;</span>/`</span>, req.<span class="hljs-property">nextUrl</span>)<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码实现除了 &#x2F;product 为前缀的路由外，其他路由加上尾斜杠</p><h3 id="skipMiddlewareUrlNormalize-1"><a href="#skipMiddlewareUrlNormalize-1" class="headerlink" title="skipMiddlewareUrlNormalize"></a>skipMiddlewareUrlNormalize</h3><p>开启时在 middleware 中获取的 req.nextUrl.pathname 为原始的地址。</p><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>middleware（截至目前 Next 最新版本为 14.2.5） 只支持 Edge runtime，不支持 node runtime，所以写 middleware 时尽量使用 web API 不要使用 node API。</p><h1 id="路由段配置"><a href="#路由段配置" class="headerlink" title="路由段配置"></a>路由段配置</h1><p>路由段指的是斜杠分割的路径，比如 &#x2F;api&#x2F;user 中 <code>/</code> 是根段，<code>api</code> 是段 <code>user</code> 是叶段。</p><p>配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// layout.js | page.js | route.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic = <span class="hljs-string">&#x27;auto&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamicParams = <span class="hljs-literal">true</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-literal">false</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fetchCache = <span class="hljs-string">&#x27;auto&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> runtime = <span class="hljs-string">&#x27;nodejs&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> preferredRegion = <span class="hljs-string">&#x27;auto&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> maxDuration = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h2><p>更改布局或者页面的动态行为</p><p>可选值：<code>&#39;auto&#39;（默认） | &#39;force-dynamic&#39; | &#39;error&#39; | &#39;force-static&#39;</code></p><ul><li>auto： 自动判断</li><li>force-dynamic： 强制使用动态渲染，退出所有 fetch 请求缓存</li><li>error：强制静态渲染并且缓存数据，如果有组件使用动态函数或者不缓存数据请求，会报错</li><li>force-static：强制静态渲染并且缓存数据，同时 cookie() headers() useSearchParams() 返回空值。</li></ul><h2 id="dynamicParams"><a href="#dynamicParams" class="headerlink" title="dynamicParams"></a>dynamicParams</h2><p>可选值：<code>true（默认） | false</code></p><ul><li>true： 按需生成</li><li>false： 返回 404</li></ul><h2 id="revalidate"><a href="#revalidate" class="headerlink" title="revalidate"></a>revalidate</h2><p>设置重验证的时间间隔，单位为秒。此设置不会覆盖单个 fetch 请求设置的 revalidate 的值。</p><p>可选值：false | ‘force-cache’ | 0 | number</p><ul><li>false： 不重新验证</li><li>0：总是动态渲染</li><li>number：重新验证的时间间隔</li></ul><h2 id="fetchCache"><a href="#fetchCache" class="headerlink" title="fetchCache"></a>fetchCache</h2><p>可选值：<code>&#39;auto&#39; | &#39;default-cache&#39; | &#39;only-cache&#39; | &#39;force-cache&#39; | &#39;force-no-store&#39; | &#39;default-no-store&#39; | &#39;only-no-store&#39;</code></p><ul><li>auto： 自动判断</li><li>default-cache： 默认缓存</li><li>only-cache：如果开发者未设置 cache 选项，默认设置为 force-cache，如果有请求设置成 cache: ‘no-store’，则会导致报错</li><li>force-cache：将所有请求的 cache 选项设置为 force-cache 。</li><li>default-no-store：开发者可以自由设置 cache 选项，但如果开发者未设置 cache 选项，默认设置为 no-store，这意味着即使是在动态函数之前的请求，也会被视为动态。</li><li>only-no-store：如果开发者未设置 cache 选项，默认设置为 no-store，如果有请求设置成 cache: ‘force-cache’，则会导致报错</li><li>force-no-store：将所有请求的 cache 选项设置为 no-store 。</li></ul><h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><p>运行时环境设置<br>可选值：<code>&#39;edge&#39; | &#39;nodejs&#39;</code></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Next</tag>
      
      <tag>ssr</tag>
      
      <tag>ssg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next 入门篇</title>
    <link href="/2024/08/08/next-01/"/>
    <url>/2024/08/08/next-01/</url>
    
    <content type="html"><![CDATA[<h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><h2 id="手动创建-Next-项目"><a href="#手动创建-Next-项目" class="headerlink" title="手动创建 Next 项目"></a>手动创建 Next 项目</h2><p>第一步：创建文件夹 next-demo<br>第二步：初始化 package.json </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm init -y<br></code></pre></td></tr></table></figure><p>第三步；安装 next react</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install next@latest react@latest react-dom@latest<br></code></pre></td></tr></table></figure><p>第四步：package.json 添加执行命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next dev&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next start&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next lint&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>第五步：新建 layout 文件 src&#x2F;app&#x2F;layout.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>第六步：新建 page 文件 src&#x2F;app&#x2F;page.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello Next<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行 dev 命令就能启动项目了</p><h2 id="通过-create-next-app-脚手架创建项目"><a href="#通过-create-next-app-脚手架创建项目" class="headerlink" title="通过 create-next-app 脚手架创建项目"></a>通过 create-next-app 脚手架创建项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx create-next-app@latest<br></code></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/08/08/pkzEA6s.png"></p><h1 id="App-Router"><a href="#App-Router" class="headerlink" title="App Router"></a>App Router</h1><p>在 Next 13.4 版本后推荐使用 App Route 在上文通过 create-next-app 脚手架创建项目时，有个选项就是是否使用 App Router</p><h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><p><img src="https://s21.ax1x.com/2024/08/08/pkzVnKA.png"></p><p>创建如上的目录结构，page.js 可以理解为对应的页面文件，app 下的 page.js 对应的路由就是 &#x2F; about 文件下的 page.js 对应的路由就是 &#x2F;about 如果目录下没有 page.js 文件，也就不会生成对应的路由</p><h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><p>Layout 相当于页面的“壳”，每个页面都会在 layout 下，另外还可以给每个页面单独设置一个 layout，例如在 about 目录下新建 layout.js 文件</p><p><img src="https://s21.ax1x.com/2024/08/08/pkzV6xJ.png"></p><p>最后呈现的效果大概是这样，Layout 就是最外层 app&#x2F;layout.js About Page 是 about&#x2F;layout.js</p><h3 id="根目录的-layout"><a href="#根目录的-layout" class="headerlink" title="根目录的 layout"></a>根目录的 layout</h3><p>根目录下的 layout 有一点特殊，首先这个文件是必需的，另外这个文件必须有 html 和 body 标签，而其他的 layout 不能有</p><h2 id="模板-template"><a href="#模板-template" class="headerlink" title="模板 template"></a>模板 template</h2><p>模板和 layout 的区别在于 template 没有办法保持状态。</p><p><img src="https://s21.ax1x.com/2024/08/12/pApJFgA.png" alt="目录结构"></p><p>这里 detail 和 detail2 只是用来进行跳转用，重点看一下 layout 和 template</p><p>layout.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/link&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductLayout</span>(<span class="hljs-params">&#123;children&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            Layout: &#123;state&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setState(state+1)&#125;&gt;add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            &#123;children&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/product/detail&quot;</span>&gt;</span>TO DETAIL<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/product/detail2&quot;</span>&gt;</span>TO DETAIL2<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>template.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductLayout</span>(<span class="hljs-params">&#123;children&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            Template: &#123;state&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setState(state+1)&#125;&gt;add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            &#123;children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>在 layout 和 template 中分别加入状态，当我们切换路由时看状态变化</p><p><img src="/img/next-16.gif" alt="效果图"></p><h2 id="加载-loading"><a href="#加载-loading" class="headerlink" title="加载 loading"></a>加载 loading</h2><p>在页面同级下创建 loading.js，以上例子是 about&#x2F;loading.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardLoading</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>Loading...<span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 about&#x2F;page.js 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">About</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">3000</span>))<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;About Page&#x27;</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getData</span>();<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时再进入到 about 页面就会先出现 Loading… 等到 page.js 内的请求完毕 loading 关闭，所以 page 必须是一个异步函数，或者使用 React 的 use 函数才能触发 loading</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">About</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">3000</span>))<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;About Page&#x27;</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">getData</span>());<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>loading 会给 page 包一层 <code>&lt;Suspense&gt;</code> 用来捕获 page 加载的 promise，实现 loading 效果。</p><h2 id="错误-error"><a href="#错误-error" class="headerlink" title="错误 error"></a>错误 error</h2><p>通过 error 可以在页面发生错误时，展示 error</p><p>还是页面的同级目录创建 error.js，另外需要注意的是 error 组件必须是客户端组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Error</span>(<span class="hljs-params">&#123; error, reset &#125;</span>) &#123;<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>    &#125;, [error])<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Something went wrong!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    // <span class="hljs-attr">尝试恢复</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    () =&gt;</span> reset()</span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">            &gt;</span><br><span class="language-xml">                Try again</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>error 会给 page 包一层 <code>&lt;ErrorBoundary&gt;</code> </p><h3 id="全局错误处理-global-error"><a href="#全局错误处理-global-error" class="headerlink" title="全局错误处理 global-error"></a>全局错误处理 global-error</h3><h1 id="404页面-not-found"><a href="#404页面-not-found" class="headerlink" title="404页面 not-found"></a>404页面 not-found</h1><p>next 存在默认的 404 页面<br><img src="https://s21.ax1x.com/2024/08/08/pkzUgQs.png" alt="next-404"></p><p>如果想要自定义 404 页面，可以在 app 目录下新增一个 not-found.js 作为 404 页面。</p><h2 id="跳转-404"><a href="#跳转-404" class="headerlink" title="跳转 404"></a>跳转 404</h2><p>next 有两种方式可以触发 not-found，第一种是执行 notFound 函数，第二种是路由找不到的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; notFound &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/navigation&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">notFound</span>()<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h1><p><img src="https://s21.ax1x.com/2024/08/12/pApKpb4.png" alt="文件结构"></p><p>层级结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">Layout</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Tempolate</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;&#123;</span>&lt;<span class="hljs-attr">Error</span>/&gt;</span>&#125;&#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Loading</span>/&gt;</span>&#125;&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">NotFound</span>/&gt;</span>&#125;&gt;</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Page</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Tempolate</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Layout</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="Next-中的懒加载"><a href="#Next-中的懒加载" class="headerlink" title="Next 中的懒加载"></a>Next 中的懒加载</h1><p>React 提供了 lazy + Suspense 实现了懒加载。在 Next 中额外提供了 <a href="https://nextjs.org/docs/app/building-your-application/optimizing/lazy-loading#nextdynamic">next&#x2F;dynamic</a> 方式实现懒加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br> <br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/dynamic&#x27;</span><br> <br><span class="hljs-comment">// Client Components:</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentA</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/A&#x27;</span>))<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentB</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/B&#x27;</span>))<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentC</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/C&#x27;</span>), &#123; <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> &#125;)<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientComponentExample</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [showMore, setShowMore] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)<br> <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;/* Load immediately, but in a separate client bundle */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">      &#123;/* Load on demand, only when/if the condition is met */&#125;</span><br><span class="language-xml">      &#123;showMore &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> /&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setShowMore(!showMore)&#125;&gt;Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">      &#123;/* Load only on the client side */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentC</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>使用时需要注意的是</p><ol><li>import 中不能是模板字符串和变量</li><li>dynamic 要在模块顶层</li></ol><p>客户端组件默认会被预渲染（SSR），通过 ssr: false 可以关闭预渲染，这会让组件比正常预渲染的组件晚显示，实际上会有一个 template 给该组件占位，然后等待加载完成再渲染。</p><h2 id="关于导入导出"><a href="#关于导入导出" class="headerlink" title="关于导入导出"></a>关于导入导出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>在使用 Next 的懒加载时，如果需要导入以上这种非默认导出需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/dynamic&#x27;</span><br> <br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ClientComponent</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =&gt;</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/hello&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">mod</span>) =&gt;</span> mod.<span class="hljs-property">Hello</span>)<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Next</tag>
      
      <tag>ssr</tag>
      
      <tag>ssg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于原型的 JS 题</title>
    <link href="/2024/07/28/this-topic/"/>
    <url>/2024/07/28/this-topic/</url>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>    getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;<br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>&#125;<br><span class="hljs-title function_">getName</span>()<br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>()<br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>()<br><span class="hljs-title function_">getName</span>()<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<br></code></pre></td></tr></table></figure><blockquote><p>答案：4 3 1 3 1 2 2</p></blockquote><h3 id="1-getName"><a href="#1-getName" class="headerlink" title="1.getName()"></a>1.getName()</h3><p>function 和 var 都会提升，function 作为第一公民，比 var 优先级更高，所以 var 会覆盖 function</p><h3 id="2-Foo-getName"><a href="#2-Foo-getName" class="headerlink" title="2.Foo.getName()"></a>2.Foo.getName()</h3><p>第十一行代码将 Foo 的 getName 方法指向了一个新的函数，所以 Foo.getName 调用的是新的函数</p><h3 id="3-Foo-getName"><a href="#3-Foo-getName" class="headerlink" title="3.Foo().getName()"></a>3.Foo().getName()</h3><p>Foo() 执行的时候，将 window 的 getName 方法改写，并且 Foo 的 this 就是 window，所以调用的是 window.getName</p><h3 id="4-new-Foo-getName"><a href="#4-new-Foo-getName" class="headerlink" title="4.new Foo.getName()"></a>4.new Foo.getName()</h3><p>本质还是执行的 Foo.getName()</p><h3 id="5-getName"><a href="#5-getName" class="headerlink" title="5.getName()"></a>5.getName()</h3><p>由于之前执行了 Foo() getName 被改写，现在执行的是被改写后的 getName()</p><h3 id="6-new-Foo-getName"><a href="#6-new-Foo-getName" class="headerlink" title="6.new Foo().getName()"></a>6.new Foo().getName()</h3><p>创造了 Foo 的实例，执行 getName 顺着原型链向上找到 Foo.prototype.getName()</p><h3 id="7-new-new-Foo-getName"><a href="#7-new-new-Foo-getName" class="headerlink" title="7.new new Foo().getName()"></a>7.new new Foo().getName()</h3><p>同 6</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Nuxt</title>
    <link href="/2024/05/24/nuxt/"/>
    <url>/2024/05/24/nuxt/</url>
    
    <content type="html"><![CDATA[<h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p>新建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm dlx nuxi init nuxt3-demo<br></code></pre></td></tr></table></figure><p>接入 tailwindcss</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add @nuxtjs/tailwindcss -D<br></code></pre></td></tr></table></figure><p>另外 tailwindcss 需要在 nuxt.config.ts 中配置一下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-attr">modules</span>: [<span class="hljs-string">&quot;@nuxtjs/tailwindcss&quot;</span>]<br></code></pre></td></tr></table></figure><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>Nuxt 路由基于 vue-router ，在 pages 目录下创建的文件都会自动生成路由</p><p><img src="https://s21.ax1x.com/2024/06/04/pkJrFIA.png"></p><p>例如如上结构的路由大概是：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<br>  &#123;<br>    path: <span class="hljs-symbol">&#x27;/</span>&#x27;,<br>    component: <span class="hljs-symbol">&#x27;./pages/index.vue</span>&#x27;,<br>  &#125;,<br>  &#123;<br>    path: <span class="hljs-symbol">&#x27;/welcome</span>&#x27;,<br>    component: <span class="hljs-symbol">&#x27;./pages/welcome.vue</span>&#x27;,<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="NuxtPage"><a href="#NuxtPage" class="headerlink" title="NuxtPage"></a>NuxtPage</h3><p>在 pages 下写了文件，但目前页面其实还不能按照上面的路由展示，需要在 app.vue 中给一个入口，就是 <code>&lt;NuxtPage&gt;</code>，当然如果项目只有一个页面就使用app.vue就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;NuxtPage&gt;&lt;/NuxtPage&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h3><p>Nuxt 提供 <code>&lt;NuxtLink&gt;</code>标签可以用来进行跳转，该标签有一个 to 属性声明跳转的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;NuxtLink to=&quot;/home&quot;&gt;link&lt;/NuxtLink&gt;<br></code></pre></td></tr></table></figure><p>还有一个帮助函数 navigateTo 可以用编程的方式进行导航，需要注意的是，调用该函数需要用 return 或者 await 处理结果。并且 navigateTo 还可以跳转到外部的地址，当跳转到外部地址时第二个参数必须有 <code>external: true</code>，不然会报错</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vue 内跳转</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">navigateTo</span>(<span class="hljs-string">&#x27;/home&#x27;</span>)<br><span class="hljs-comment">// 跳转外部地址</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">navigateTo</span>(<span class="hljs-string">&#x27;https://nuxt.com&#x27;</span>, &#123;<br>    <span class="hljs-attr">external</span>: <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>当文件名包含了<code>[]</code>，就会被转换为动态路由参数，例如新建一个 list-[id].vue 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &#123;&#123; $route.params.id &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>直接访问 &#x2F;list-1 可以看到页面显示 1</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>当需要二级路由，就需要通过文件结构来处理，pages&#x2F;detail&#x2F;name.vue 就会生成对应的路由 ‘&#x2F;detail&#x2F;name’ ，另外当存在 ‘&#x2F;detail’ 路由时，也就是</p><p><img src="https://s21.ax1x.com/2024/05/28/pk1cj9P.png"></p><p>name 作为字路由，需要在 <code>detail.vue</code> 中提供入口 <code>&lt;NuxtPage&gt;</code> 才能将二级路由页面显示出来，另外也可以在 detail 目录下使用动态路由的方式创建 [id].vue 这样就通过 &#x2F;detail&#x2F;1 的方式访问即可。</p><h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><p>根目录下的 Layouts 目录用于存放页面布局，该目录下的组件都可以通过 <code>&lt;NuxtLayout&gt;</code> 标签使用，该标签有一个属性 name 用于指定使用哪个 Layout ，如不指定，默认使用 default。在 Layout 中，还需要写一个插槽来展示 Layout 包裹的组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;Header&lt;/div&gt;<br>  &lt;slot /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>需要打包工具处理的资源放在 assets 目录下，不需要处理的放在 public 目录下，访问 public 下的资源直接通过<code>/</code> 例如 <code>&#39;/pic.png&#39;</code>，访问 assets 目录下的资源需要从根目录开始，在 Nuxt 中路径有的会存在别名，可以通过别名来访问。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;~~&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&lt;rootDir&gt;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;@@&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&lt;rootDir&gt;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;~&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&lt;rootDir&gt;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;@&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&lt;rootDir&gt;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;assets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&lt;rootDir&gt;/assets&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;public&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&lt;rootDir&gt;/public&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><p>在 app.vue 引入的 css 都会作用于全局，另一种方法就是通过 nuxt.config.ts 进行配置，在 assets 新建一个 global.css 作为全局样式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">css</span>: [<span class="hljs-string">&quot;assets/global.css&quot;</span>],<br>  <span class="hljs-comment">// ...  </span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="组件-Components"><a href="#组件-Components" class="headerlink" title="组件 Components"></a>组件 Components</h2><p>Nuxt 组件放在根目录下的 components 目录下，这个目录下的组件当被使用到的时候无需引入和注册，<strong>组件名是路径和文件名以大驼峰</strong>，例如 ‘components&#x2F;nav&#x2F;bar.vue’ 就是 <code>&lt;NavBar&gt;</code></p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Vue-渲染过程中的错误"><a href="#Vue-渲染过程中的错误" class="headerlink" title="Vue 渲染过程中的错误"></a>Vue 渲染过程中的错误</h2><p>通过 Nuxt 提供的插件，在 plugins 目录下新建 error-handler.js 来处理 vue 渲染过程中的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>(<span class="hljs-function">(<span class="hljs-params">nuxtApp</span>) =&gt;</span> &#123;<br>  nuxtApp.<span class="hljs-property">vueApp</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-function">(<span class="hljs-params">..._args</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vue error handler&#x27;</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过 Nuxt 钩子捕获 Vue 传播上来的错误<br>第一个钩子 app:error：整个应用层面的错误捕获<br>第二个钩子 vue:error：仅 Vue 层面的错误捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>(<span class="hljs-function">(<span class="hljs-params">nuxtApp</span>) =&gt;</span> &#123;<br>  nuxtApp.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&#x27;app:error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">..._args</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;app:error&#x27;</span>)<br>  &#125;)<br>  nuxtApp.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&#x27;vue:error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">..._args</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;app:error&#x27;</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>触发顺序：errorHandler -&gt; vue:error -&gt; app:error。</p><h2 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h2><p>在根目录下创建 error.vue 文件，当抛出异常时会跳转到这个页面。另外手动抛出错误可以使用 showError() 参数是一个字符串或者一个错误对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">showError</span>(<span class="hljs-string">&#x27;404&#x27;</span>)<br><span class="hljs-title function_">showError</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;404&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="组件错误处理"><a href="#组件错误处理" class="headerlink" title="组件错误处理"></a>组件错误处理</h2><p>Nuxt 提供 NuxtErrorBoundary 处理组件级的错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;NuxtErrorBoundary&gt;<br>    &lt;!-- 默认插槽显示正常内容 --&gt;<br>    &lt;!-- 触发一个错误 --&gt;<br>    &lt;ThrowError&gt;&lt;/ThrowError&gt;<br>    &lt;!-- error插槽显示错误时内容 --&gt;<br>    &lt;template #error=&quot;&#123; error &#125;&quot;&gt;<br>      &lt;p class=&quot;my-4 text-xl text-gray-500&quot;&gt;发生了一些错误 &#123;&#123; error &#125;&#125;&lt;/p&gt;<br>      &lt;NButton type=&quot;success&quot; @click=&quot;error.value = null&quot;&gt; 修正错误 &lt;/NButton&gt;<br>    &lt;/template&gt;<br>  &lt;/NuxtErrorBoundary&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>当 ThrowError 组件抛出错误时，会触发 error 插槽的内容。</p><h1 id="配置-meta"><a href="#配置-meta" class="headerlink" title="配置 meta"></a>配置 meta</h1><h2 id="通过-app-head-配置"><a href="#通过-app-head-配置" class="headerlink" title="通过 app.head 配置"></a>通过 app.head 配置</h2><p>在 nuxt.config.ts 中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">app</span>: &#123;<br>      <span class="hljs-attr">head</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;nuxt3-demo&#x27;</span>,<br>          <span class="hljs-attr">meta</span>: [<br>              &#123;<br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>,<br>                  <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;nuxt3-demo&#x27;</span><br>              &#125;,<br>              &#123;<br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;description&#x27;</span>,<br>                  <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;nuxt3-demo&#x27;</span><br>              &#125;<br>          ]<br>      &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/11/pkh869x.png"></p><h2 id="通过-useHead-在组件内配置"><a href="#通过-useHead-在组件内配置" class="headerlink" title="通过 useHead 在组件内配置"></a>通过 useHead 在组件内配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>useHead(&#123;<br>  title: &quot;Counter&quot;,<br>  meta: [<br>    &#123;name: &quot;description&quot;, content: &quot;counter&quot;&#125;,<br>  ]<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>useHead 中的 title 会直接替换原本的 title，如果想保留原本的 title 可以使用 <code>titleTemplate</code> 配置。</p><h2 id="通过组件标签配置"><a href="#通过组件标签配置" class="headerlink" title="通过组件标签配置"></a>通过组件标签配置</h2><p>Nuxt 提供 <Title>, <Base>, <NoScript>, <Style>, <Meta>, <Link>, <Body>, <Html> , <Head> 标签来配置 header。</p><h2 id="常用-meta-配置"><a href="#常用-meta-配置" class="headerlink" title="常用 meta 配置"></a>常用 meta 配置</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 文本设置 GB2312:中国信息交换用汉字编码字符集(简体中文) GBK:汉字扩展规范(扩大汉字收录,增加繁体中文,蒙语,藏语等少数民族的文字) UTF-8: 万国码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 标题 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 关键字  100字节 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 描述 80-120汉字 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 一般在移动端中使用，width=device-width 设置网页的宽度（viewport）和设备的宽度一样，这样横向就不会出现滚动条，用户浏览体验会大幅提升；后面的几个设置不允许用户手动缩放。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>搜索引擎认知优先级  title &gt; description &gt; keywords</p><h1 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h1><h2 id="匿名路由中间件"><a href="#匿名路由中间件" class="headerlink" title="匿名路由中间件"></a>匿名路由中间件</h2><p>匿名中间件就是在单个页面执行，没办法复用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">definePageMeta</span>(&#123;<br>  <span class="hljs-title function_">middleware</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;匿名中间件&#x27;</span>);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="命名路由中间件"><a href="#命名路由中间件" class="headerlink" title="命名路由中间件"></a>命名路由中间件</h2><p>根目录下的 middleware 目录用来存放路由中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// middleware/auth.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtRouteMiddleware</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 验证权限</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAuthenticated</span>() === <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">navigateTo</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- pages/auth.vue--&gt;<br>definePageMeta(&#123;<br>  middleware: &#x27;auth&#x27;<br>&#125;)<br></code></pre></td></tr></table></figure><p>当进入到页面时触发路由中间件，进行鉴权，无权限跳转到 login</p><h2 id="全局路由中间件"><a href="#全局路由中间件" class="headerlink" title="全局路由中间件"></a>全局路由中间件</h2><p>在 middleware 目录下新建 mid.global.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtRouteMiddleware</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;全局中间件&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h2><ol><li>abortNavigation：留在 from 页面</li><li>navigateTo：跳转到某个页面</li></ol><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>根目录下的 plugin 目录下的文件或者文件夹下的 index.js 文件会被注册成插件，<br>另外可通过 1.name.js 给文件名加数字的方式控制插件的顺序<br>还可以通过 .server.js &#x2F; .client.js 给插件区分环境</p><h2 id="NuxtApp"><a href="#NuxtApp" class="headerlink" title="NuxtApp"></a>NuxtApp</h2><p>使用 defineNuxtPlugin 时会传入一个参数 nuxtApp</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>(<span class="hljs-function">(<span class="hljs-params">nuxtApp</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>nuxtApp 中有一些属性和方法：</p><ul><li>provide (name, value)：定义全局变量和方法；</li><li>hook(name, cb)：定义 nuxt 钩子函数；</li><li>vueApp：获取 vue 实例；</li><li>ssrContext：服务端渲染时的上下文；</li><li>payload：从服务端到客户端传递的数据和状态；</li><li>isHydrating：用于检测是否正在客户端注水过程中。</li></ul><p>获取全局注册的属性和方法</p><p>当使用 provide 定义了一些属性和方法时，通过 useNuxtApp() 获取</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nuxt</tag>
      
      <tag>SSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微前端 qiankun</title>
    <link href="/2024/05/22/qiankun-baics/"/>
    <url>/2024/05/22/qiankun-baics/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>创建三个项目分别是：<br><img src="https://s21.ax1x.com/2024/05/23/pkQmkFS.png"></p><p>其中 react 项目都是通过 create-react-app 创建的，vue 项目通过 vite 创建，另外项目还需要安装 qiankun。</p><h1 id="搭建主应用"><a href="#搭建主应用" class="headerlink" title="搭建主应用"></a>搭建主应用</h1><h2 id="子应用渲染入口"><a href="#子应用渲染入口" class="headerlink" title="子应用渲染入口"></a>子应用渲染入口</h2><p>首先需要给子应用在主应用中渲染的容器，我们在 App.js 中写一个容器<br><img src="https://s21.ax1x.com/2024/05/23/pkMvP9U.png"></p><h2 id="定义子应用的列表"><a href="#定义子应用的列表" class="headerlink" title="定义子应用的列表"></a>定义子应用的列表</h2><p>在 src 下新建一个 subApp.js</p><p><img src="https://s21.ax1x.com/2024/05/23/pkMvnN6.png"></p><ul><li>name 子应用的名称，需要唯一</li><li>entry 子应用的入口，就是子应用的访问地址，这里通过环境变量来达到不同环境使用不同的入口地址</li><li>container 子应用在主应用的挂载的节点，就是把子应用放在主应用的哪个地方，上文我们有定义</li><li>activeRule 子应用路由规则，主应用触发该路由加载访问子应用</li></ul><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>新建 .env.development 文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">REACT_APP_REACT_SUB=<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span>/react<br>REACT_APP_VUE_SUB=<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">5173</span>/vue<br></code></pre></td></tr></table></figure><p><strong>需要注意的是一定要以 REACT_APP 开头的环境变量才会被识别。</strong></p><h2 id="注册子应用并启动"><a href="#注册子应用并启动" class="headerlink" title="注册子应用并启动"></a>注册子应用并启动</h2><p>在入口文件 main.js 中通过 qiankun 提供的 registerMicroApps 注册我们的子应用，使用 start 启动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">registerMicroApps</span>(microApps)<br><span class="hljs-title function_">start</span>()<br></code></pre></td></tr></table></figure><p>另外 registerMicroApps 还可以传入第二个参数 lifeCycles ，也就是全局的微应用生命周期钩子，start 也可以传入一些配置项，<a href="https://qiankun.umijs.org/zh/api">具体参考</a></p><h1 id="react-子应用搭建"><a href="#react-子应用搭建" class="headerlink" title="react 子应用搭建"></a>react 子应用搭建</h1><h2 id="window-POWERED-BY-QIANKUN"><a href="#window-POWERED-BY-QIANKUN" class="headerlink" title="window.POWERED_BY_QIANKUN"></a>window.<strong>POWERED_BY_QIANKUN</strong></h2><p>首先需要了解一下 <code>window.__POWERED_BY_QIANKUN__ </code> 这个值，这是 qiankun 注入的一个全局变量，是一个布尔值，他代表了当前应用是不是在 qiankun 的容器中运行</p><h2 id="修改-publicPath"><a href="#修改-publicPath" class="headerlink" title="修改 publicPath"></a>修改 publicPath</h2><p>新建一个 public-path.js 文件，需要在入口文件 index.js 中引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;<br>    __webpack_public_path__ = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="routebase"><a href="#routebase" class="headerlink" title="routebase"></a>routebase</h2><p>修改 App.jsx 文件，主要定义 routebase。<br><img src="https://s21.ax1x.com/2024/05/23/pkMxnqs.png"></p><p><strong>需要注意的是，这里的 BASE_NAME 一定要和主应用中定义的子应用列表的 activeRule 一致。</strong></p><h2 id="修改入口文件-index-js"><a href="#修改入口文件-index-js" class="headerlink" title="修改入口文件 index.js"></a>修改入口文件 index.js</h2><p><img src="https://s21.ax1x.com/2024/05/23/pkQeSET.png"></p><ul><li>render 就是进行渲染的方法，这里 render 限制了查找根节点的范围</li><li>然后判断是在主应用下运行的还是单独运行的</li><li>mount 是每次进入子应用调用的钩子</li><li>unmount 是卸载调用的钩子</li></ul><h2 id="修改-webpack-配置"><a href="#修改-webpack-配置" class="headerlink" title="修改 webpack 配置"></a>修改 webpack 配置</h2><p>因为我们是用 create-react-app 创建的项目，不使用 eject 的情况下，修改 webpack 配置需要安装插件 <code>react-app-rewired</code> 或者 <code>@rescripts/cli</code>，这里我们用前者。</p><p>新建 config-overrides.js 文件</p><p><img src="https://s21.ax1x.com/2024/05/23/pkQk8Wn.png"></p><h1 id="vue-子应用搭建"><a href="#vue-子应用搭建" class="headerlink" title="vue 子应用搭建"></a>vue 子应用搭建</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>vite 需要安装插件 <code>vite-plugin-qiankun</code> 才能使用 qiankun。</p><h2 id="配置-vite-config-js"><a href="#配置-vite-config-js" class="headerlink" title="配置 vite.config.js"></a>配置 vite.config.js</h2><p><img src="https://s21.ax1x.com/2024/05/23/pkQZbCQ.png"></p><h2 id="修改入口文件"><a href="#修改入口文件" class="headerlink" title="修改入口文件"></a>修改入口文件</h2><p><img src="https://s21.ax1x.com/2024/05/23/pkQZjuq.png"><br>判断是否在 qiankun 的环境下运行应用，和 react 的配置类似。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>完成以上步骤其实就基本实现了构建微前端项目的过程，但还有一些地方可以进行简单的优化</p><h2 id="指定子应用的启动端口"><a href="#指定子应用的启动端口" class="headerlink" title="指定子应用的启动端口"></a>指定子应用的启动端口</h2><p>在开发环境下，主应用需要子应用的入口，指定子应用的端口就不用每次去修改主应用的配置了，上文中 vue-sub 我在写 vite.config.js 的时候已经指定的端口为9000，react-sub 的话通过环境变量就能指定启动端口号了，在 react-sub 中新增环境变量配置文件 .env.development，声明 <code>PORT=8080</code><br>即可</p><h2 id="通过按钮切换两个子应用"><a href="#通过按钮切换两个子应用" class="headerlink" title="通过按钮切换两个子应用"></a>通过按钮切换两个子应用</h2><p>在 react-master 的 App.js 中实现两个按钮分别切换 react-sub 和 vue-sub</p><p><img src="https://s21.ax1x.com/2024/05/23/pkQevzd.png"></p><p>这里推荐使用 <code>window.history.pushState</code> 让页面在不刷新的情况下进行跳转。</p><h1 id="应用间通信"><a href="#应用间通信" class="headerlink" title="应用间通信"></a>应用间通信</h1><h2 id="initGlobalState"><a href="#initGlobalState" class="headerlink" title="initGlobalState"></a>initGlobalState</h2><p>首先在主应用中通过 initGlobalState API 初始化一个全局 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/shared/actions</span><br><span class="hljs-keyword">import</span> &#123; initGlobalState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;qiankun&quot;</span>;<br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>    <span class="hljs-attr">sharedProperty</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;;<br><span class="hljs-keyword">const</span> actions = <span class="hljs-title function_">initGlobalState</span>(initialState);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> actions;<br></code></pre></td></tr></table></figure><p>然后调用 onGlobalStateChange 来观察全局 state 的变化，当 state 发生变化时，就会调用这个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 注册一个观察者函数</span><br>actions.<span class="hljs-title function_">onGlobalStateChange</span>(<span class="hljs-function">(<span class="hljs-params">state, prev</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// state: 变更后的状态; prev 变更前的状态</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state, prev);<br>&#125;);<br><span class="hljs-comment">// 设置值</span><br>actions.<span class="hljs-title function_">setGlobalState</span>(&#123;<br>    <span class="hljs-attr">sharedProperty</span>: <span class="hljs-string">&#x27;qiankun-example&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="子应用接收-state"><a href="#子应用接收-state" class="headerlink" title="子应用接收 state"></a>子应用接收 state</h2><p>子应用在 render 生命周期中可以通过 props 获取主应用传来的 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">if</span> (props) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props)<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并且也可以用 actions 的方法进行操作，我们可以封装一个类来处理 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">emptyAction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;Current execute action is empty!&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Actions</span> &#123;<br>    actions = &#123;<br>        <span class="hljs-attr">onGlobalStateChange</span>: emptyAction,<br>        <span class="hljs-attr">setGlobalState</span>: emptyAction<br>    &#125;<br>    <span class="hljs-title function_">setActions</span>(<span class="hljs-params">actions</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span> = actions;<br>    &#125;<br>    <span class="hljs-title function_">onGlobalStateChange</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-title function_">onGlobalStateChange</span>(...args);<br>    &#125;<br>    <span class="hljs-title function_">setGlobalState</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-title function_">setGlobalState</span>(...args);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> actions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Actions</span>();<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> actions;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微前端</tag>
      
      <tag>qiankun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解Vue3是如何进行组件更新的</title>
    <link href="/2024/05/17/vue3-diff/"/>
    <url>/2024/05/17/vue3-diff/</url>
    
    <content type="html"><![CDATA[<h1 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h1><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>vue 在更新的时候，使用 patch 方法更新新老节点，判断老节点是否可以复用<br><img src="https://s21.ax1x.com/2024/05/16/pkn0081.png" alt="patch"><br>在 patch 时会先比较新老节点的类型，比较的方式就是判断 type 和 key 是否都相等，类型不同代表不能复用，直接卸载。然后判断新节点的类型，<br><img src="https://s21.ax1x.com/2024/05/16/pknBFIJ.png" alt="isSameVNodeType"></p><h3 id="在这里可以看到有三种类型的节点，使用不同的方法进行处理："><a href="#在这里可以看到有三种类型的节点，使用不同的方法进行处理：" class="headerlink" title="在这里可以看到有三种类型的节点，使用不同的方法进行处理："></a>在这里可以看到有三种类型的节点，使用不同的方法进行处理：</h3><ol><li>文本节点</li><li>Fragment 节点，vue3 引入 Fragment，在 vue3 的模板中可以使用多个根节点，会被视为 Fragment</li><li>element(<code>普通元素</code>)类型、component(<code>组件</code>)类型</li></ol><h2 id="component-类型"><a href="#component-类型" class="headerlink" title="component 类型"></a>component 类型</h2><p>updateComponent<br><img src="https://s21.ax1x.com/2024/05/31/pk8EnGF.png"><br>首先判断新老节点是否发生变化，决定需不需要更新，需要更新就执行<br>update，就是执行组件自己的更新流程。不需要更新就用老节点就行。通过组件的更新可以看出当父组件更新，子组件没发生变化是不会随着父组件更新的</p><h2 id="element-类型"><a href="#element-类型" class="headerlink" title="element 类型"></a>element 类型</h2><p>Vue3 通过 patchElement 方法处理 element 类型的节点，首先会去比较新老节点的 props ，如果不同就更新，然后再执行 patchChildren 进行全量比较更新。</p><h1 id="patchChildren"><a href="#patchChildren" class="headerlink" title="patchChildren"></a>patchChildren</h1><p>在 patchChildren 中对 children 的 vnode 进行 patch，这里存在几种情况：</p><table><thead><tr><th>老节点</th><th>新节点</th><th>处理方式</th></tr></thead><tbody><tr><td>空</td><td>空</td><td>-</td></tr><tr><td>空</td><td>文本</td><td>添加文本节点</td></tr><tr><td>空</td><td>数组</td><td>添加多个节点</td></tr><tr><td>文本</td><td>空</td><td>删除多个节点</td></tr><tr><td>文本</td><td>文本</td><td>替换新文本</td></tr><tr><td>文本</td><td>数组</td><td>清空老节点，添加多个新节点</td></tr><tr><td>数组</td><td>空</td><td>删除多个节点</td></tr><tr><td>数组</td><td>文本</td><td>删除多个节点，添加文本节点</td></tr><tr><td>数组</td><td>数组</td><td>diff</td></tr></tbody></table><p>当新老节点都是数组的时候，就会进入到 diff 的流程。</p><h2 id="存在-key"><a href="#存在-key" class="headerlink" title="存在 key"></a>存在 key</h2><p>当节点有 key 时，就会进入到 diff 流程，Vue3 通过 <code>patchKeyedChildren</code> 进行处理。</p><p>首先声明了一些变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>              <span class="hljs-comment">/* 记录索引 */</span><br><span class="hljs-keyword">const</span> l2 = c2.<span class="hljs-property">length</span>   <span class="hljs-comment">/* 新vnode的数量 */</span><br><span class="hljs-keyword">let</span> e1 = c1.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> <span class="hljs-comment">/* 老vnode 最后一个节点的索引 */</span><br><span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>        <span class="hljs-comment">/* 新节点最后一个节点的索引 */</span><br></code></pre></td></tr></table></figure><h3 id="从头对比"><a href="#从头对比" class="headerlink" title="从头对比"></a>从头对比</h3><p><img src="https://s21.ax1x.com/2024/05/16/pknWSfO.png"><br>从头对比就是用 <code>isSameVNodeType</code> 检查新老节点是否能一一相等，如果相等就 <code>patch</code>，如果发现不等就 break 跳出头部对比流程。</p><h3 id="从尾对比"><a href="#从尾对比" class="headerlink" title="从尾对比"></a>从尾对比</h3><p><img src="https://s21.ax1x.com/2024/05/17/pknv2wV.png"><br>从尾对比就同样用 <code>isSameVNodeType</code> 从尾开始遍历检查新老节点是否相等，直到遇到不等的就 break 跳出从尾对比流程</p><h3 id="比较节点数"><a href="#比较节点数" class="headerlink" title="比较节点数"></a>比较节点数</h3><p>进行完头尾对比后会出现三种可能</p><ol><li>老节点全部 patch ，新节点有剩余，说明有新增节点，就需要添加这个节点</li><li>新节点全部 patch ，老节点有剩余，说明有节点被删除，老节点剩余的节点不需要了，需要全部删除</li><li>新老节点全部有剩余，说明节点可能发生了移动，新增，删除</li></ol><h3 id="剩余的节点"><a href="#剩余的节点" class="headerlink" title="剩余的节点"></a>剩余的节点</h3><h4 id="keyToNewIndexMap"><a href="#keyToNewIndexMap" class="headerlink" title="keyToNewIndexMap"></a>keyToNewIndexMap</h4><p><img src="https://s21.ax1x.com/2024/05/17/pknza8g.png"><br>keyToNewIndexMap 是一个 <code>[新节点的key, 索引]</code> 的 map 集合，方便通过 key 来找到老节点的索引。</p><h4 id="遍历老节点"><a href="#遍历老节点" class="headerlink" title="遍历老节点"></a>遍历老节点</h4><p>这一步的主要过程就是通过老节点的 key 去查找索引，如果没有 key，就遍历剩下的新节点，看有没有和该节点相等的，如果有，就证明有可复用的老节点，直接进行 patch，如果找不到索引，就说明不可复用，直接删除，最后把新老节点对应的索引保存在 newIndexToOldIndexMap，结构是 <code>[新节点索引, 老节点索引]</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newIndexToOldIndexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(toBePatched)<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><p>newIndexToOldIndexMap 是长度和新节点长度相等的，初始值都是 0 的数组。</p></blockquote><p>经历过上面的步骤，老节点都已经被 patch 过了，剩下的就是新节点有新增、移动两种情况，在 newIndexToOldIndexMap 中没有找到新节点对应的值，说明是新增的节点</p><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><p>求出最长递增子序列，根据这个作为基准移动节点，使用最长递增子序列作为基准可以使节点移动最少。</p><blockquote><p>最长递增子序列就是一个序列中，找到一个最长的子序列，并且子序列中的元素是按照递增顺序排列的。</p></blockquote><h2 id="不存在-key"><a href="#不存在-key" class="headerlink" title="不存在 key"></a>不存在 key</h2><p>没有 key 的时候会进入 patchUnKeyedChildren 来处理</p><p>首先比较老节点和新节点的 length ，获取其中较小的值，然后遍历进行 patch<br>然后如果老节点长度大于新节点，进行删除<br>如果老节点长度小于新节点，进行新增</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞定 React 的 ref</title>
    <link href="/2024/04/29/react-ref/"/>
    <url>/2024/04/29/react-ref/</url>
    
    <content type="html"><![CDATA[<h1 id="创建一个-ref"><a href="#创建一个-ref" class="headerlink" title="创建一个 ref"></a>创建一个 ref</h1><h2 id="类组件的-ref"><a href="#类组件的-ref" class="headerlink" title="类组件的 ref"></a>类组件的 ref</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img src="https://s21.ax1x.com/2024/04/29/pkixB8K.png"><br>当 ref 是一个函数时，入参就是当前的 DOM 节点，在函数内将它赋给别的值，就可以通过这个值进行访问。<br><img src="https://s21.ax1x.com/2024/04/29/pkixDgO.png" alt="输出结果"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="https://s21.ax1x.com/2024/04/29/pkixJu4.png"><br>ref 可以绑定一个字符串，它会被保存到 this.refs 上。<br><img src="https://s21.ax1x.com/2024/04/29/pkivIB9.png" alt="输出结果"></p><p>另外当判断 ref 绑定的是字符串时，其实走的是函数的处理逻辑，只不过字符串都被绑定在了 this.refs 上。</p><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef()"></a>createRef()</h3><p><img src="https://s21.ax1x.com/2024/04/29/pkixcbd.png"><br>通过 React 提供的 createRef 来创建一个 ref 对象，ref 对象有一个 current 属性，绑定的值就会保存在这里。<br><img src="https://s21.ax1x.com/2024/04/29/pkix2VA.png" alt="输出结果"></p><h4 id="createRef-源码"><a href="#createRef-源码" class="headerlink" title="createRef 源码"></a>createRef 源码</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRef</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">RefObject</span> &#123;<br>    <span class="hljs-keyword">const</span> refObject = &#123;<br>        <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> refObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>createRef 的本质就是创建一个带有 current 属性的对象，然后把这个对象返回。</p><h2 id="函数组件创建-ref-方式"><a href="#函数组件创建-ref-方式" class="headerlink" title="函数组件创建 ref 方式"></a>函数组件创建 ref 方式</h2><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><img src="https://s21.ax1x.com/2024/04/29/pkiz8it.png"></p><p><img src="https://s21.ax1x.com/2024/04/29/pkizYz8.png" alt="输出结果"></p><p>和类组件不同的是，函数式组件没有实例，没办法在实例上保存一些东西，所以 React 提供了一系列的 hooks<br>来帮助函数式组件能够像类组件一样有自己的状态等功能，关于 ref 可以通过使用 useRef 来创建一个 ref 对象。</p><h4 id="useRef-源码"><a href="#useRef-源码" class="headerlink" title="useRef 源码"></a>useRef 源码</h4><p>初始化 ref</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> mountRef&lt;T&gt;(<span class="hljs-attr">initialValue</span>: T): &#123; <span class="hljs-attr">current</span>: T &#125; &#123;<br>    <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();<br>    <span class="hljs-keyword">const</span> ref = &#123;<span class="hljs-attr">current</span>: initialValue&#125;;<br>    hook.<span class="hljs-property">memoizedState</span> = ref;<br>    <span class="hljs-keyword">return</span> ref;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新 ref</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> updateRef&lt;T&gt;(<span class="hljs-attr">initialValue</span>: T): &#123; <span class="hljs-attr">current</span>: T &#125; &#123;<br>    <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();<br>    <span class="hljs-keyword">return</span> hook.<span class="hljs-property">memoizedState</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ref 值被保存在 memoizedState 中。</p><h3 id="为什么函数式组件不能用-createRef？"><a href="#为什么函数式组件不能用-createRef？" class="headerlink" title="为什么函数式组件不能用 createRef？"></a>为什么函数式组件不能用 createRef？</h3><p>看过 createRef 就知道他只是返回了一个带有 current 属性的对象，而<strong>函数式组件每次更新时都会重新执行，也就相当于说我们又重新创建了一个 ref</strong>，这么做没什么意义。</p><h1 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h1><h2 id="useRef-缓存数据"><a href="#useRef-缓存数据" class="headerlink" title="useRef 缓存数据"></a>useRef 缓存数据</h2><p>在函数式组件内部每次更新状态都会触发视图更新，当有一些数据更新并不需要视图更新的时候，使用 state 难免造成多余的渲染。<br>这时候使用 <code>useRef</code> 应该是更好的选择，<code>useRef</code> 保存的值更新时不会触发视图更新，<br><strong>并且 useRef 由于始终指向同一个地址，拿到的永远是最新值</strong>，因此 useRef 可以起到一个缓存数据的功能。</p><h3 id="ahooks-中的-useLatest"><a href="#ahooks-中的-useLatest" class="headerlink" title="ahooks 中的 useLatest"></a>ahooks 中的 useLatest</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> useLatest&lt;T&gt;(<span class="hljs-attr">value</span>: T) &#123;<br>    <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(value);<br>    ref.<span class="hljs-property">current</span> = value;<br><br>    <span class="hljs-keyword">return</span> ref;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 ahooks 中的 useLatest 就使用 useRef 来保存值，确保每次都可以拿到最新的值，从而避免闭包问题。</p><h2 id="forwardRef-转发-ref"><a href="#forwardRef-转发-ref" class="headerlink" title="forwardRef 转发 ref"></a>forwardRef 转发 ref</h2><p>在子组件是类组件时可以通过 ref 直接获取到子组件的实例<br><img src="https://s21.ax1x.com/2024/04/29/pkFV8xA.png" alt="类组件通过ref通信"><br><img src="https://s21.ax1x.com/2024/04/29/pkFVUVf.png" alt="输出"><br>但是对于函数式组件来说，不存在实例，也就无法像类组件一样通过 ref 直接通信，针对这个问题 React 提供了 forwardRef 来帮助我们在函数式组件通过 ref 通信。<br><img src="https://s21.ax1x.com/2024/04/29/pkFVmb6.png" alt="使用forwardRef转发ref"><br><img src="https://s21.ax1x.com/2024/04/29/pkFVdIS.png" alt="输出"></p><h3 id="配合-useImperativeHandle-实现通信"><a href="#配合-useImperativeHandle-实现通信" class="headerlink" title="配合 useImperativeHandle 实现通信"></a>配合 useImperativeHandle 实现通信</h3><p>仅仅使用 forwardRef 只能是将 ref 转发出去，但还不足以实现组件间的通信，如果父组件需要调用子组件中的属性&#x2F;方法，那子组件就需要用 useImperativeHandle 暴漏出去</p><p><img src="https://s21.ax1x.com/2024/04/29/pkFV4G4.png" alt="使用useImperativeHandle"></p><p>这里我们将子组件改造一下，使用 useImperativeHandle 暴露出一些属性，再看父组件的输出：<br><img src="https://s21.ax1x.com/2024/04/29/pkFVIz9.png"><br>可以看到父组件接收到了子组件暴露出来的属性，这也就完成了通信。</p><h1 id="ref-的更新流程"><a href="#ref-的更新流程" class="headerlink" title="ref 的更新流程"></a>ref 的更新流程</h1><p><img src="https://s21.ax1x.com/2024/04/30/pkF0N1H.png"><br>以上代码会发生奇怪的输出情况：<br><img src="https://s21.ax1x.com/2024/04/30/pkF0Qn1.png" alt="输出结果"><br>根据输出结果发现每次更新都会有两次输出，<strong>一次为 null，一次才是真正的 DOM</strong>。在 React 中<strong>一次更新分为 render 和 commit 两个阶段</strong>，替换真实 DOM 发生在 commit 阶段，而我们的 ref 就是获取真实 DOM 的，所以对于 ref 的处理都在 commit 阶段。至于会变更两次，分别发生在 DOM 更新前和 DOM 更新后，<strong>在 DOM 更新前会重置 ref 的值，所以会输出 null</strong>，然后 DOM 进行更新，<strong>更新后拿到新的 DOM 再次更新 ref，这次输出的是真实 DOM 节点</strong>。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>首先在 commit 的 mutation 阶段(也就是 DOM 更新前)，执行 commitDetachRef，将 ref 值置为 null</li><li>然后 DOM 进行更新</li><li>在 commit 的 layout 阶段(也就是 DOM 更新后)，更新真实节点，执行 commitAttachRef，重新设置 ref 的值</li></ol><h3 id="markRef-标记"><a href="#markRef-标记" class="headerlink" title="markRef 标记"></a>markRef 标记</h3><p>ref 更新前会进行判断，<strong>如果存在 tag 才会进行更新</strong>，给 ref 打 tag 的操作就是 markRef</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">markRef</span>(<span class="hljs-params">current: Fiber | <span class="hljs-literal">null</span>, workInProgress: Fiber</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = workInProgress.<span class="hljs-property">ref</span>;<br>  <span class="hljs-keyword">if</span> (<br>    (current === <span class="hljs-literal">null</span> &amp;&amp; ref !== <span class="hljs-literal">null</span>) || <span class="hljs-comment">// 初始化</span><br>    (current !== <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">ref</span> !== ref) <span class="hljs-comment">// 更新</span><br>  ) &#123; <span class="hljs-comment">/*...*/</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>标记的时机就是<strong>初始化的时候</strong>和<strong>ref 指向发生改变</strong>，在上文输出中的 null 就是因为 current.ref !&#x3D;&#x3D; ref 认为发生了更新，打上了 tag ，存在 tag 在执行 commitDetachRef 时把 ref 赋值为 null。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 react 的日常开发中，ref 的使用是很常见的，本文从创建 ref 开始，分析类组件和函数组件的 ref 区别，以及一些使用 ref 需要注意的地方，在通过例子讲述了 ref 的一些高阶用法，希望能够帮助读者更好的进行开发。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞定 React 的 useEffect</title>
    <link href="/2024/04/25/useEffect/"/>
    <url>/2024/04/25/useEffect/</url>
    
    <content type="html"><![CDATA[<h1 id="当依赖为引用数据类型时"><a href="#当依赖为引用数据类型时" class="headerlink" title="当依赖为引用数据类型时"></a>当依赖为引用数据类型时</h1><h2 id="依赖是引用数据类型和基本类型对比"><a href="#依赖是引用数据类型和基本类型对比" class="headerlink" title="依赖是引用数据类型和基本类型对比"></a>依赖是引用数据类型和基本类型对比</h2><p><img src="https://s21.ax1x.com/2024/06/03/pkJ9xC4.png" alt="不同类型对比"></p><p>每次点击发现只会输出 <code>useEffect - obj</code>，也就是当 useEffect 依赖为对象时，每次更新都会执行。<br><img src="https://s21.ax1x.com/2024/04/25/pkC5uJ1.png" alt="控制台输出"></p><h2 id="依赖是如何进行比较的"><a href="#依赖是如何进行比较的" class="headerlink" title="依赖是如何进行比较的"></a>依赖是如何进行比较的</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">areHookInputsEqual</span>(<span class="hljs-params"></span><br><span class="hljs-params">  nextDeps: <span class="hljs-built_in">Array</span>&lt;mixed&gt;,</span><br><span class="hljs-params">  prevDeps: <span class="hljs-built_in">Array</span>&lt;mixed&gt; | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (prevDeps === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prevDeps.<span class="hljs-property">length</span> &amp;&amp; i &lt; nextDeps.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">objectIs</span>(nextDeps[i], prevDeps[i])) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="比较分为三种方式："><a href="#比较分为三种方式：" class="headerlink" title="比较分为三种方式："></a>比较分为三种方式：</h3><ol><li>当 prevDeps 为 null ，也就是没传入依赖（<code>在这之前会对依赖进行处理，如果传入依赖为 undefined 会赋值 null</code>），始终返回 false，每次都执行</li><li>如果传入依赖就进行遍历，通过 Object.is 进行比较，当比较出不等时返回 false，也就是依赖发生变化时执行</li><li>遍历结束认为依赖没发生变化，返回 true，不执行</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>上文分析了问题产生的原因，那么应该如何处理呢？</p><h3 id="使用-useRef"><a href="#使用-useRef" class="headerlink" title="使用 useRef"></a>使用 useRef</h3><p><img src="https://s21.ax1x.com/2024/06/03/pkJ9OET.png" alt="使用useRef"></p><p>因为 ref 会单独开辟一个地址，在组件更新前后不会新建，这也是能够用 useRef 进行缓存的原因。这里我们使用 useRef 包裹一个对象，每次对比的都是相同的对象，所以 useEffect 只会在初始化执行，更新时不会执行。</p><h1 id="useEffect-返回函数-cleanup"><a href="#useEffect-返回函数-cleanup" class="headerlink" title="useEffect 返回函数 cleanup"></a>useEffect 返回函数 cleanup</h1><h2 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h2><p>cleanup 会在组件销毁、依赖改变的情况下执行。<br><img src="https://s21.ax1x.com/2024/06/03/pkGzwNQ.png"><br>当改变 num 值和控制 Child 组件隐藏销毁组件时，都会有输出。</p><p><img src="https://s21.ax1x.com/2024/06/03/pkGzV6x.png"></p><h2 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h2><p>cleanup 函数通常用来清除副作用，例如清理定时器，清除事件监听等，这里用计时器作为例子：</p><p><img src="https://s21.ax1x.com/2024/06/03/pkGz2HU.png" alt="计时"></p><p>这段代码中我们就需要每次清空循环定时器才能达到想要的效果，不然每次更新都会创建循环定时器。</p><h1 id="useEffect-模拟声明周期"><a href="#useEffect-模拟声明周期" class="headerlink" title="useEffect 模拟声明周期"></a>useEffect 模拟声明周期</h1><p>React hooks 提供 useEffect、useLayoutEffect 来解决函数式组件没有声明周期的问题。</p><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;, [])<br></code></pre></td></tr></table></figure><p>当 useEffect 依赖为 <code>[]</code> 时，setup 函数也就是 useEffect 的第一个参数，只在组件初始化时执行。</p><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;, [])<br></code></pre></td></tr></table></figure><p>在上一个的基础上，setup 函数的返回函数 cleanup 函数会在每次依赖项变更重新渲染后，用旧的值执行一遍，当组件从页面卸载也会执行一遍。一般在这里清除定时器，关闭事件监听等等。</p><h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;, [props])<br></code></pre></td></tr></table></figure><p>将 props 放在 useEffect 的依赖中，会在 props 变化时执行。和 componentWillReceiveProps 区别在于 useEffect 在 commit 阶段才会执行，componentWillReceiveProps 在 render 阶段就执行，另外 useEffect 在初始化时默认执行一次。</p><h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...    </span><br>&#125;)<br></code></pre></td></tr></table></figure><p>不设置 useEffect 的依赖，将会在组件状态更新时执行。和 componentDidUpdate 区别在于 useEffect 是异步执行，componentDidUpdate 是同步执行，并且 useEffect 在初始化时默认执行一次。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>当我们模拟 componentDidUpdate 时，如果在 setup 函数中更新状态，会导致 <code>更新状态 -&gt; 执行 -&gt; 更新状态 -&gt; 执行 ...</code>无限循环执行。</p><h1 id="useEffect、useLayoutEffect、useInsertionEffect"><a href="#useEffect、useLayoutEffect、useInsertionEffect" class="headerlink" title="useEffect、useLayoutEffect、useInsertionEffect"></a>useEffect、useLayoutEffect、useInsertionEffect</h1><p>useEffect 在浏览器渲染完成之后异步执行，useLayoutEffect 在 DOM 更新后，浏览器渲染前同步执行，会阻塞浏览器绘制。对于 DOM 的操作一般放在 useLayoutEffect 中，因为 useEffect 执行时 DOM 已经渲染完成了，再去修改 DOM 可能会产生回流或者重绘。</p><p>在 <code>React18</code> 版本又提供 useInsertionEffect 来处理 CSS-in-JS 在渲染中注入样式的性能问题。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nest 初体验</title>
    <link href="/2024/04/02/nest-01/"/>
    <url>/2024/04/02/nest-01/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm i -g @nestjs/cli</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nest new project-name</span><br></code></pre></td></tr></table></figure><h1 id="文件概览"><a href="#文件概览" class="headerlink" title="文件概览"></a>文件概览</h1><h2 id="src-main-ts-入口文件"><a href="#src-main-ts-入口文件" class="headerlink" title="src&#x2F;main.ts 入口文件"></a>src&#x2F;main.ts 入口文件</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">NestFactory</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AppModule</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.module&#x27;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);<br>    <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-title function_">bootstrap</span>();<br></code></pre></td></tr></table></figure><p>入口文件，通过 NestFactory 创建一个 Nest 应用实例，并且监听 3000 端口。</p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><blockquote><p>创建控制器命令：nest g controller [name]</p></blockquote><p>接收请求的地方，通过类和装饰器对元数据进行关联。</p><p><img src="https://s21.ax1x.com/2024/04/03/pFH7LaF.png" alt="控制器代码示例"></p><p>在 constructor 中注入 service，@Get 表明这是一个 Get 请求，可以在 Get 中添加路径。其他请求方式包括 @Post、@Delete、@Put 等。</p><h3 id="可能用到的装饰件器"><a href="#可能用到的装饰件器" class="headerlink" title="可能用到的装饰件器"></a>可能用到的装饰件器</h3><h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p>定义控制器，另外可以传入路由路径前缀。</p><h4 id="Param-param-string"><a href="#Param-param-string" class="headerlink" title="@Param(param?: string)"></a>@Param(param?: string)</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Get</span>(<span class="hljs-string">&#x27;/name/:id&#x27;</span>)<br><span class="hljs-built_in">getNameById</span>(<span class="hljs-variable">@Param</span>() params): string &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>@Params 可以获取到路径中的参数对象，可传入属性名表示获取该属性的值。</p><h4 id="Body-param-string"><a href="#Body-param-string" class="headerlink" title="@Body(param?: string)"></a>@Body(param?: string)</h4><p>@Body 获取的请求体中的参数对象，可传入属性名表示获取该属性的值</p><h4 id="Query-param-string"><a href="#Query-param-string" class="headerlink" title="@Query(param?: string)"></a>@Query(param?: string)</h4><p>@Query 获取的时 url 上的 query 对象，例如 <code>xxx?name=&#39;xxx&#39;</code>，另外可传入属性名表示获取该属性的值</p><h2 id="提供器"><a href="#提供器" class="headerlink" title="提供器"></a>提供器</h2><p>服务层，在该层处理业务逻辑<br><img src="https://s21.ax1x.com/2024/04/03/pFH7vG9.png" alt="提供器代码示例"></p><h3 id="可能用到的装饰器"><a href="#可能用到的装饰器" class="headerlink" title="可能用到的装饰器"></a>可能用到的装饰器</h3><h4 id="Injectable"><a href="#Injectable" class="headerlink" title="@Injectable()"></a>@Injectable()</h4><p>将该类标记为提供器</p><h4 id="InjectRepository"><a href="#InjectRepository" class="headerlink" title="InjectRepository()"></a>InjectRepository()</h4><p>将实体类的 repository 注入到 userRepository 属性中，在 service 层中调用 userRepository 进行数据库操作。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote><p>创建命令：nest g module name</p></blockquote><p>每个应用至少会有一个模块，即根模块，模块将控制器、提供器、相关组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-meta">@Module</span>(&#123;<br>    <span class="hljs-attr">imports</span>: [],<br>    <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AppController</span>],<br>    <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AppService</span>],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>providers：将由 Nest 注入器实例化并且至少可以在该模块中共享的提供程序</li><li>controllers：此模块中定义的必须实例化的控制器集</li><li>imports：导出此模块所需的提供程序的导入模块列表</li><li>exports：这个模块提供的 providers 的子集应该在导入这个模块的其他模块中可用。你可以使用提供器本身或仅使用其令牌（provide 值）</li></ol><p>模块是构建应用图的起点，</p><h1 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h1><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&#x27;Forbidden&#x27;</span>, <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">FORBIDDEN</span>);<br></code></pre></td></tr></table></figure><p>Nest 内置了 HttpException 类用来抛出异常，第一个参数是返回的 message，第二个参数是状态码，HttpStatus<br>是一个保存了 <code>&#123;错误类型: 错误码&#125;</code> 的对象，例如你可以通过</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&#x27;参数类型不正确&#x27;</span>, <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">BAD_REQUEST</span>);<br></code></pre></td></tr></table></figure><p>返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;statusCode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">400</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;参数类型不正确&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="异常过滤器-1"><a href="#异常过滤器-1" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><p><img src="https://s21.ax1x.com/2024/04/02/pFHAo5j.png" alt="异常过滤器"><br>这是官网提供的异常过滤器</p><h2 id="绑定过滤器"><a href="#绑定过滤器" class="headerlink" title="绑定过滤器"></a>绑定过滤器</h2><p><img src="https://s21.ax1x.com/2024/04/02/pFHAxZF.png" alt="绑定过滤器"></p><p>通过 @UseFilters(new HttpExceptionFilter()) 来给控制层的接口添加异常过滤器</p><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><h2 id="第一步：安装依赖"><a href="#第一步：安装依赖" class="headerlink" title="第一步：安装依赖"></a>第一步：安装依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save @nestjs/typeorm typeorm mysql2<br></code></pre></td></tr></table></figure><h2 id="第二步：连接数据库"><a href="#第二步：连接数据库" class="headerlink" title="第二步：连接数据库"></a>第二步：连接数据库</h2><p>在根目录的 app.module.ts 中，配置自己的数据库。</p><p><img src="https://s21.ax1x.com/2024/04/03/pFHbNfH.png" alt="连接配置"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 思维导图(二)</title>
    <link href="/2024/03/25/vue-mapping-deep/"/>
    <url>/2024/03/25/vue-mapping-deep/</url>
    
    <content type="html"><![CDATA[<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p><img src="https://s21.ax1x.com/2024/03/25/pF40bZj.png" alt="组件注册"></p><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p><img src="https://s21.ax1x.com/2024/03/25/pF4rwin.png" alt="Props"></p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p><img src="https://s21.ax1x.com/2024/03/27/pFIu5WR.png" alt="v-model"></p><h2 id="透传Attributes"><a href="#透传Attributes" class="headerlink" title="透传Attributes"></a>透传Attributes</h2><p><img src="https://s21.ax1x.com/2024/03/27/pFI16Vf.png" alt="透传Attributes"></p><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p><img src="https://s21.ax1x.com/2024/03/28/pFIbKFs.png" alt="插槽"></p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><img src="https://s21.ax1x.com/2024/03/28/pFIqD4s.png" alt="依赖注入"></p><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p><img src="https://s21.ax1x.com/2024/03/28/pFopCBq.png" alt="异步组件"></p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p><img src="https://s21.ax1x.com/2024/03/29/pFog57V.png" alt="自定义指令"></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><img src="https://s21.ax1x.com/2024/04/01/pF71Awq.png" alt="插件"></p><h2 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h2><p><img src="https://s21.ax1x.com/2024/04/01/pF71kmn.png" alt="KeepAlive"></p><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><p><img src="https://s21.ax1x.com/2024/04/01/pF78ZzF.png" alt="Teleport"></p><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><p><img src="https://s21.ax1x.com/2024/04/01/pF7amhn.png" alt="Suspense"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 思维导图(一)：基础篇</title>
    <link href="/2024/03/21/vue-mind-mapping/"/>
    <url>/2024/03/21/vue-mind-mapping/</url>
    
    <content type="html"><![CDATA[<h2 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h2><p><img src="https://s21.ax1x.com/2024/04/01/pF7BiCj.png" alt="响应式基础"></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p><img src="https://s21.ax1x.com/2024/03/21/pFfKT7d.png" alt="计算属性"></p><h2 id="类和样式"><a href="#类和样式" class="headerlink" title="类和样式"></a>类和样式</h2><p><img src="https://s21.ax1x.com/2024/03/21/pFf1bqS.png" alt="类和样式"></p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><img src="https://s21.ax1x.com/2024/03/21/pFf3WLT.png" alt="条件渲染"></p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p><img src="https://s21.ax1x.com/2024/03/21/pFfG5G9.png" alt="列表渲染"></p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p><img src="https://s21.ax1x.com/2024/03/21/pFfagq1.png" alt="事件处理"></p><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p><img src="https://s21.ax1x.com/2024/03/22/pFfT6QH.png" alt="侦听器"></p><h2 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h2><p><img src="https://s21.ax1x.com/2024/03/22/pFfHBxe.png" alt="模板引用"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://s21.ax1x.com/2024/03/25/pF42BW9.png" alt="组件"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL开始构建浏览器知识体系</title>
    <link href="/2024/01/09/browser/"/>
    <url>/2024/01/09/browser/</url>
    
    <content type="html"><![CDATA[<h1 id="从浏览器输入-URL-到页面呈现都发生了什么"><a href="#从浏览器输入-URL-到页面呈现都发生了什么" class="headerlink" title="从浏览器输入 URL 到页面呈现都发生了什么"></a>从浏览器输入 URL 到页面呈现都发生了什么</h1><ol><li>输入 URL</li><li>查找<a href="/2024/01/09/browser/#%E7%BC%93%E5%AD%98">缓存</a>，有缓存读取缓存，没有进行下一步</li><li>DNS 域名解析，解析出域名对应的 IP 地址</li><li>和服务器建立 <a href="/2024/01/09/browser/#TCP-%E5%92%8C-UDP">TCP 连接</a></li><li>发送 <a href="/2024/01/09/browser/#HTTP">HTTP</a> 请求</li><li>服务端响应请求，返回结果</li><li>断开 TCP 连接</li><li><a href="/2024/01/09/browser/#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93">浏览器渲染</a></li></ol><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ol><li>首先查找浏览器缓存</li><li>然后查找操作系统缓存</li><li>查找路由器缓存</li><li>查找 ISP 缓存</li></ol><h2 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>如果命中强缓存就无需向服务器发送请求。</p><p>在 <strong>http1.0</strong> 通过 <strong>Expires</strong> 来判断是否命中强缓存，这个字段代表资源过期时间，如果资源未过期，即可读取缓存，但是由于浏览器时间和服务器时间可能存在差异，导致缓存失效。</p><p>在 <strong>http1.1</strong> 通过 <strong>Cache-Control</strong> 进行判断，和 Expires 不同的是，Cache-Control 的 <strong>max-age</strong> 字段代表的是缓存的时长，在这个时长内缓存都是有效的，这样就能避免由于时间误差导致缓存失效。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强缓存失效就进入到了协商缓存，协商缓存需要向服务器发送请求。协商缓存通过 <strong>Last-Modified</strong> 和 <strong>ETag</strong> 来判断。</p><p><strong>Last-Modified</strong> 即最后修改时间，在浏览器接收到请求，会在请求头保存最后修改时间在 <strong>If-Modified-Since</strong> 字段，当该字段和服务器的最后修改时间一致，标识服务端资源没有再被更改，命中协商缓存。</p><p><strong>ETag</strong> 和 Last-Modified 的区别在于，后者按照修改时间界定资源是否更新，而 ETag 则是通过资源生成的唯一 hash 值来进行界定，只要资源发生改变就会生成新的 hash 值，通过这个值就能判断是否命中协商缓存。</p><p><img src="https://s11.ax1x.com/2024/02/29/pFwcSl6.jpg" alt="缓存流程图"></p><h1 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手主要目的是确认客户端和服务端的发送和接收功能是否正常。</p><p><strong>第一次握手</strong>；客户端向服务端发送 SYN 标记的包，告诉服务端请求建立连接（确认客户端发送功能正常）<br><strong>第二次握手</strong>：服务端接收到 SYN 包并确认，发送包 SYN、ACK 到客户端响应连接（确认服务端发送和相应功能正常）<br><strong>第三次握手</strong>：客户端接收到服务端响应，发送确认包 ACK 到服务端，连接建立成功（确认客户端接收功能正常）</p><p><img src="https://s11.ax1x.com/2024/01/10/pFpbgun.png" alt="三次握手"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><strong>第一次挥手</strong>：客户端发送 FIN 包请求关闭连接，客户端此时不再发送数据，变成 FIN_WAIT 状态<br><strong>第二次挥手</strong>：服务端接收到 FIN 包，释放 TCP 连接，发送确认包 ACK，进入 CLOSE_WAIT 状态，此时客户端到服务端的连接已经关闭<br><strong>第三次挥手</strong>：等到服务端数据发送完要断开连接，发送 FIN 包给客户端请求断开连接，此时服务端处于 LAST_ACK 状态<br><strong>第四次挥手</strong>：客户端收到服务端请求断开 FIN 包，发送 ACK 应答包，此时客户端进入 TIME_WAIT 状态，等待2MSL(报文最大生存时间)服务端收到 ACK 包，进入 CLOSED 状态</p><p><img src="https://s11.ax1x.com/2024/01/10/pFpbaHP.png" alt="四次挥手"></p><h2 id="TCP-如何保证数据包传输有序可靠"><a href="#TCP-如何保证数据包传输有序可靠" class="headerlink" title="TCP 如何保证数据包传输有序可靠"></a>TCP 如何保证数据包传输有序可靠</h2><ol><li>序列号和确认应答：每个 TCP 数据包都包含一个序列号，接收方在收到数据包后会发送一个确认应答，确认已成功接收到数据。</li><li>超时重发：如果发送方在一定时间内没有收到接收方的确认应答，就会重新发送相同的数据包，直到收到应答或重传次数超过规定的最大次数为止。</li></ol><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li>缺点<br>由于 UDP 协议是<strong>面向无连接</strong>的，不需要像 TCP 一样需要三次握手才能建立连接，UDP 想发送就发送，而且 UDP 始终以恒定的速度发送数据，在网络出现波动的情况下，可能出现丢包的情况，就算丢包了，UDP 也不会重发，它根本不关心数据是否发送成功，所以 UDP 是<strong>不可靠的</strong>。</li><li>优点<br>UDP 的头部开销只有八个字节，比 TCP 少得多，UDP 还支持一对多，多对多的传输方式</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 全称<strong>超文本传输协议(Hypertext Transfer Protocol)</strong></p><h2 id="各个版本特点"><a href="#各个版本特点" class="headerlink" title="各个版本特点"></a>各个版本特点</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul><li>默认使用短连接</li><li>使用 If-Modified-Since，Expires来做缓存判断的标准</li><li>存在带宽浪费现象，客户端只需要某个对象一部分，服务器也会把整个对象传过来</li></ul><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul><li>支持长连接</li><li>引入 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 控制缓存</li><li>优化带宽浪费，允许只请求资源某部分</li><li>新增错误状态码（24个）</li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li>引入多路复用，即可以只通过一个 TCP 连接就可以传输所有的请求数据</li><li>二进制传输，HTTP1 是基于文本，HTTP2.0 采用二进制</li><li>头部压缩，在 HTTP1 中 header 带有大量信息，每次都重新发送，HTTP2.0 通过 encoder 减少 header 大小，并且在两端维护索引表记录出现过的 header，再次传输只需要传输键名就能拿到值。</li><li>支持服务端 push</li></ul><h3 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h3><ul><li>在 HTTP2.0 下使用了多路复用，只使用一个 TCP 连接，当出现丢包的时候，整个 TCP 等待重传，造成堵塞。所以 HTTP3.0 使用基于 UDP 的 QUIC 协议</li></ul><h2 id="判断使用的哪个版本"><a href="#判断使用的哪个版本" class="headerlink" title="判断使用的哪个版本"></a>判断使用的哪个版本</h2><p>在控制台输入 <code>window.chrome.loadTimes()</code></p><p><img src="https://s11.ax1x.com/2024/01/11/pF9qvH1.png"></p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><ul><li>应用层：最高层的网络协议，提供应用程序与网络之间的接口，支持各种应用程序（如Web浏览器、电子邮件等）进行通信。</li><li>运输层：负责提供端到端的数据传输服务，确保数据可靠地传输，常用的传输协议有TCP（传输控制协议）和UDP（用户数据报协议）。</li><li>网络层：负责通过路由选择算法将数据包从源主机传输到目标主机，实现数据的网络互联与路由选择。</li><li>数据链路层：负责将原始的比特流进行分组并转换为数据帧，处理数据帧之间的错误校验和流量控制，以确保数据的可靠传输。</li><li>物理层：负责传输数据，将帧中的一个个比特从一个节点传输到另外的节点</li></ul><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>运输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul><h1 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h1><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ol><li><a href="/2024/01/09/browser/#HTML%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90%E6%97%B6%E9%97%B4%E7%BA%BF">解析 HTML</a>、CSS 生成 DOM 树、CSSOM 树，</li><li>DOM + CSSOM 生成 Render Tree</li><li>根据生成的 Render Tree 进行<a href="/2024/01/09/browser/#%E9%87%8D%E7%BB%98-%E9%87%8D%E6%8E%92">回流</a>，得到节点几何信息</li><li>根据 Render Tree 和 回流得到节点绝对像素</li><li>将像素发送给 GPU 在页面显示</li></ol><h2 id="HTML文档解析时间线"><a href="#HTML文档解析时间线" class="headerlink" title="HTML文档解析时间线"></a>HTML文档解析时间线</h2><ol><li>浏览器生成 document 对象</li><li>解析文档（从 html 第一行开始）、构建DOM树<br><strong>document.readyState &#x3D; ‘loading’ 加载中阶段</strong></li><li>link 开新的线程 -&gt; 异步加载 css 外部文件  style</li><li>没有设置异步加载的 script ，阻塞文档解析，等 js 脚本执行完，继续解析文档</li><li>有异步加载的 script ，异步加载js脚本，不阻塞解析文档 （异步加载文档不能使用document.write，会报错）</li><li>解析文档遇到 img 先解析这个节点，创建加载线程 异步加载图片资源 不阻塞文档解析</li><li>文档解析完成<br><strong>document.readState  &#x3D; ‘interactive’ 解析完成 交互阶段</strong></li><li>文档解析完成 defer script js脚本开始按照顺序执行</li><li>文档解析完成：<strong>立即触发 DOMContentLoaded 事件</strong>，程序由 同步脚本执行阶段 走向 事件驱动阶段，此时用户可以进行操作</li><li>async script 加载完并执行，img 等资源加载完成 <strong>window.onload 事件触发</strong><br><strong>document.readState &#x3D; ‘complete’ 文档加载完毕阶段</strong></li></ol><h2 id="重绘-重排"><a href="#重绘-重排" class="headerlink" title="重绘&amp;重排"></a>重绘&amp;重排</h2><ol><li>重绘：重绘指的是浏览器根据元素样式的更改重新绘制页面的过程，但并不影响页面中元素的布局</li><li>重排：重排指的是浏览器重新计算文档流中元素的位置和大小，然后根据新的布局信息进行重新排列的过程</li></ol><h3 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h3><ol><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动</li></ol><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ol><li>合并样式修改：尽量避免对页面中的元素频繁进行样式更改。可以将多个样式更改合并成一次操作，或者使用类似于requestAnimationFrame的方法来批量处理样式</li><li>使用文档片段：使用文档片段（DocumentFragment）进行离线操作，然后一次性将其添加到文档中，减少对实际 DOM 树的操作。</li><li>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li><li>动画开始GPU加速，translate使用3D变化</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack优化篇</title>
    <link href="/2024/01/06/webpack-03/"/>
    <url>/2024/01/06/webpack-03/</url>
    
    <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><p>这里使用 <a href="https://www.npmjs.com/package/webpack-bundle-analyzer">Webpack-bundle-analyzer</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add progress-bar-webpack-plugin -D<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// 代码产物分析</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(),<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif" alt="分析界面（图片来自https://www.npmjs.com/package/webpack-bundle-analyzer）"></p><h2 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h2><ul><li>初始化<ol><li>根据配置文件、Shell 参数以及默认配置结合得出最终的配置参数</li><li>创建编译器对象 compiler</li><li>初始化编译环境</li><li>编译开始，执行 compiler 的 run 方法，创建 compilation 对象</li><li>确定入口</li></ol></li><li>构建<ol><li>编译模块</li><li>完成编译模块，得到依赖关系图</li></ol></li><li>封装<ol><li>根据依赖关系进行打包</li><li>对包进行优化，tree-shaking、压缩 等</li><li>写入系统</li></ol></li></ul><h2 id="webpack-生命周期"><a href="#webpack-生命周期" class="headerlink" title="webpack 生命周期"></a>webpack 生命周期</h2><ol><li>beforeRun：进入编译前的阶段，初始化 Compiler 对象。</li><li>run：开始编译前的阶段，此时会读取入口文件和依赖，并创建依赖图。</li><li>compilation：进入编译阶段，此时会开始编译入口文件和依赖的模块，并生成输出文件。</li><li>emit：生成输出文件前的阶段，此时可以在插件中处理生成的输出文件。</li><li>done：完成打包后的阶段，此时可以在插件中进行一些清理工作。</li></ol><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>在 webpack 5 中提供了<a href="https://webpack.js.org/configuration/cache/#cache">缓存</a>的功能，通过 <code>cache.type = &#39;filesystem&#39;</code> 即可开启持久化缓存。<br>开启持久化缓存后，webpack 会在首次构建时，将构建出的产物模块序列化然后保存到硬盘，后面再执行构建时，就可以跳过很多编译过程，直接复用缓存。</p><h1 id="图像优化"><a href="#图像优化" class="headerlink" title="图像优化"></a>图像优化</h1><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>关于图片压缩这里使用的是 <a href="https://github.com/tcoopman/image-webpack-loader">image-webpack-loader</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D image-webpack-loader<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(gif|png|jpe?g|svg)$/i</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;asset/resource&quot;</span>,<br>                <span class="hljs-attr">use</span>: [&#123;<br>                    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;image-webpack-loader&#x27;</span>,<br>                    <span class="hljs-attr">options</span>: &#123;<br>                       <span class="hljs-attr">mozjpeg</span>: &#123;<br>                            <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>,<br>                            <span class="hljs-attr">quality</span>: <span class="hljs-number">65</span>,<br>                        &#125;,<br>                        <span class="hljs-attr">optipng</span>: &#123;<br>                            <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>,<br>                        &#125;,<br>                        <span class="hljs-attr">pngquant</span>: &#123;<br>                            <span class="hljs-attr">quality</span>: [<span class="hljs-number">0.65</span>, <span class="hljs-number">0.9</span>],<br>                            <span class="hljs-attr">speed</span>: <span class="hljs-number">4</span>,<br>                        &#125;,<br>                        <span class="hljs-attr">gifsicle</span>: &#123;<br>                            <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span>,<br>                        &#125;,<br>                        <span class="hljs-attr">webp</span>: &#123;<br>                            <span class="hljs-attr">quality</span>: <span class="hljs-number">75</span>,<br>                        &#125;,<br>                    &#125;<br>                &#125;]<br>            &#125;,<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际测试 766kb 图片压缩到192kb。</p></blockquote><ul><li>mozjpeg：压缩 JPG(JPEG) 图片</li><li>optipng、pngquant：压缩 PNG 图片</li><li>svgo：压缩 SVG 图片</li><li>gifsicle：压缩 Gif 图</li><li>webp：将 JPG&#x2F;PNG 图压缩并转化为 WebP 图片格式</li></ul><h1 id="打包体积优化"><a href="#打包体积优化" class="headerlink" title="打包体积优化"></a>打包体积优化</h1><h2 id="使用-cdn-分包"><a href="#使用-cdn-分包" class="headerlink" title="使用 cdn 分包"></a>使用 cdn 分包</h2><p>将项目中体积较大的包通过 cdn 的方式引入，减少打包产物体积大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add html-webpack-externals-plugin -D<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackExternalsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-externals-plugin&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackExternalsPlugin</span>(&#123;<br>            <span class="hljs-attr">externals</span>: [<br>                &#123;<br>                    <span class="hljs-attr">module</span>: <span class="hljs-string">&#x27;react&#x27;</span>,<br>                    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;https://unpkg.com/react@18.2.0/umd/react.production.min.js&#x27;</span>,<br>                    <span class="hljs-attr">global</span>: <span class="hljs-string">&#x27;React&#x27;</span>,<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">module</span>: <span class="hljs-string">&#x27;react-dom&#x27;</span>,<br>                    <span class="hljs-attr">entry</span>:<br>                        <span class="hljs-string">&#x27;https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js&#x27;</span>,<br>                    <span class="hljs-attr">global</span>: <span class="hljs-string">&#x27;ReactDOM&#x27;</span>,<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">module</span>: <span class="hljs-string">&#x27;echarts&#x27;</span>,<br>                    <span class="hljs-attr">entry</span>:<br>                        <span class="hljs-string">&#x27;https://cdn.bootcdn.net/ajax/libs/echarts/5.4.3/echarts.common.min.js&#x27;</span>,<br>                    <span class="hljs-attr">global</span>: <span class="hljs-string">&#x27;echarts&#x27;</span>,<br>                &#125;,<br>            ]<br>        &#125;)<br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里以 react、react-dom、echarts 为例，将他们使用 cdn 的方式引入，不再打包进入产物，</p><h2 id="合并模块-Scope-Hoisting"><a href="#合并模块-Scope-Hoisting" class="headerlink" title="合并模块 Scope Hoisting"></a>合并模块 Scope Hoisting</h2><p>Scope Hoisting 可以将符合条件的多个模块合并到一个函数中，减少产物体积</p><h3 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h3><ul><li>使用 mode &#x3D; ‘production’ 开启生产模式</li><li>使用 optimization.concatenateModules 配置项</li><li>使用 ModuleConcatenationPlugin 插件</li></ul><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>在一些特殊情况下会关闭模块合并</p><ol><li>非 ESM 模块</li><li>模块被多个 Chunk 引用</li></ol><h1 id="打包速度优化"><a href="#打包速度优化" class="headerlink" title="打包速度优化"></a>打包速度优化</h1><h2 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D thread-loader<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            <span class="hljs-comment">// ...</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>                <span class="hljs-attr">use</span>: [<br>                    &#123;<br>                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;thread-loader&quot;</span>,<br>                        <span class="hljs-attr">options</span>: &#123;<br>                            <span class="hljs-attr">workers</span>: <span class="hljs-number">2</span>,<br>                            <span class="hljs-attr">workerParallelJobs</span>: <span class="hljs-number">50</span>,<br>                        &#125;,<br>                    &#125;,<br>                    <span class="hljs-comment">// ...</span><br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>workers 进程总数</li><li>workerParallelJobs 单个进程中并发执行的任务数</li><li>poolTimeout 超时时间，子进程空闲超时会关闭</li><li>poolRespawn 是否允许子进程关闭后重新创建新的子进程</li><li>workerNodeArgs 设置启动子进程时，额外的参数</li></ul><h2 id="按需编译"><a href="#按需编译" class="headerlink" title="按需编译"></a>按需编译</h2><p>webpack 提供一个实验特性 <a href="https://webpack.docschina.org/configuration/experiments/#experimentslazycompilation">lazyCompilation</a>用来实现异步引用模块的按需编译，极大提高了冷启动速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">experiments</span>: &#123;<br>        <span class="hljs-attr">lazyCompilation</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是该功能还处在实验阶段，<strong>最好只在开发环境使用</strong>。</p><h2 id="约束-loader-执行的范围"><a href="#约束-loader-执行的范围" class="headerlink" title="约束 loader 执行的范围"></a>约束 loader 执行的范围</h2><p>通过 <code>module.rules.exclude</code> &#x2F; <code>module.rules.include</code> 可以进一步缩小 loader 的执行范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>        <span class="hljs-comment">// ...</span><br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="使用-noParse"><a href="#使用-noParse" class="headerlink" title="使用 noParse"></a>使用 noParse</h2><p>使用 <a href="https://webpack.docschina.org/configuration/module/#modulenoparse">module.noParse</a> 跳过不需要二次编译的资源文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">noParse</span>: <span class="hljs-regexp">/lodash|react/</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 noParse 需要注意的是：</p><ul><li>需要确保 noParse 文件的准确性</li><li>不能依赖其他文件</li><li>使用 noParse 的文件就无法 tree-shaking 了</li></ul><h2 id="关闭-ts-的类型检查"><a href="#关闭-ts-的类型检查" class="headerlink" title="关闭 ts 的类型检查"></a>关闭 ts 的类型检查</h2><p>使用 <code>fork-ts-checker-webpack-plugin</code> 插件来进行 ts 的类型检查，该插件会将 ts 的类型检查和编译过程放在单独的进程中运行，然后我们关闭 ts-loader 的类型检查，提升编译速度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D fork-ts-checker-webpack-plugin<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ForkTsCheckerWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fork-ts-checker-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [&#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>        &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>          <span class="hljs-attr">options</span>: &#123;<br>            <span class="hljs-comment">// 仅编译</span><br>            <span class="hljs-attr">transpileOnly</span>: <span class="hljs-literal">true</span><br>          &#125;<br>        &#125;<br>      ],<br>    &#125;, ],<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-comment">// 使用插件，用单独的进程进行 ts 类型检查</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkTsCheckerWebpackPlugin</span>()<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="resolve-modules-定向查找"><a href="#resolve-modules-定向查找" class="headerlink" title="resolve.modules 定向查找"></a>resolve.modules 定向查找</h2><p>webpack 在查找模块时，会先去当前目录的 .&#x2F;node_modules 下查找，没找到就去上一级的 ..&#x2F;node_modules 找。使用 resolve.modules 指定查找的目录，减少查找的时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;node_modules&#x27;</span>)]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指定补全后缀"><a href="#指定补全后缀" class="headerlink" title="指定补全后缀"></a>指定补全后缀</h2><p><code>resolve.extensions</code> 可以指定导入没写后缀时自动补全的后缀列表，默认值是 <code>[&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;]</code>，也就是导入的时候没写后缀，会自动去查找 .js、.json、.wasm 后缀的文件，如果找不到就报错。<br>如果手动声明这个属性，会把默认值覆盖掉，我们可以通过 <code>[&#39;...&#39;]</code>的方式保留默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>, <span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.tsx&#x27;</span>],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h1><p>代码压缩就是抛弃代码的可读性、格式化等等一切，把我们的代码做到最精简。</p><h2 id="js-压缩"><a href="#js-压缩" class="headerlink" title="js 压缩"></a>js 压缩</h2><p>webpack 5 默认使用 terser 进行 js 压缩，通过 <code>optimization.minimize</code> 属性开启。</p><h2 id="css-压缩"><a href="#css-压缩" class="headerlink" title="css 压缩"></a>css 压缩</h2><p>使用 <a href="https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/#root">css-minimizer-webpack-plugin</a> 插件来完成对 css 的压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D css-minimizer-webpack-plugin<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;css-minimizer-webpack-plugin&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">minimizer</span>: [<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(),<br>        ],<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>该插件还可以通过 <code>minify</code> 属性来指定使用什么进行压缩，可选值：</p><ul><li><code>CssMinimizerPlugin.cssnanoMinify</code>  使用 cssnano 默认值，不需要额外安装依赖</li><li><code>CssMinimizerPlugin.cssoMinify</code>  使用 csso</li><li><code>CssMinimizerPlugin.cleanCssMinify</code>  使用 clean-css</li><li><code>CssMinimizerPlugin.esbuildMinify</code>  使用 ESBuild</li><li><code>CssMinimizerPlugin.parcelCssMinify</code>  使用 parcel-css</li></ul><p>需要注意的是，该插件必须配合之前提到的 <code>mini-css-extract-plugin</code> 插件一起使用，<code>mini-css-extract-plugin</code> 插件将 css 代码抽离到一个文件，<code>css-minimizer-webpack-plugin</code> 再对代码进行压缩。</p><h2 id="html-压缩"><a href="#html-压缩" class="headerlink" title="html 压缩"></a>html 压缩</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D html-minifier-terser<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">minimizer</span>: [<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;<br>                <span class="hljs-attr">parallel</span>: <span class="hljs-number">2</span> <span class="hljs-comment">// number | boolean</span><br>            &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(&#123;<br>                <span class="hljs-attr">minify</span>: <span class="hljs-title class_">CssMinimizerPlugin</span>.<span class="hljs-property">cssnanoMinify</span>,<br>            &#125;),<br>        ],<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>安装 <a href="https://webpack.docschina.org/plugins/compression-webpack-plugin/#root">CompressionWebpackPlugin</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D compression-webpack-plugin<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CompressionPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;<br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;gzip&#x27;</span>,    <span class="hljs-comment">// 默认值就是 gzip</span><br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|css)$/</span>,  <span class="hljs-comment">// 压缩范围</span><br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="抽离运行时代码"><a href="#抽离运行时代码" class="headerlink" title="抽离运行时代码"></a>抽离运行时代码</h1><p>在 entry 中配置 runtime 将运行时代码抽离到 common-runtime 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">main</span>: &#123; <span class="hljs-attr">import</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span>, <span class="hljs-attr">runtime</span>: <span class="hljs-string">&quot;common-runtime&quot;</span> &#125;,<br>    <span class="hljs-attr">foo</span>: &#123; <span class="hljs-attr">import</span>: <span class="hljs-string">&quot;./src/foo.js&quot;</span>, <span class="hljs-attr">runtime</span>: <span class="hljs-string">&quot;common-runtime&quot;</span> &#125;,<br>  &#125;,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].js&quot;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack入坑指北</title>
    <link href="/2023/12/27/webpack-01/"/>
    <url>/2023/12/27/webpack-01/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>首先新建一个项目然后初始化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm init -y<br>pnpm add webpack webpack-cli -D<br></code></pre></td></tr></table></figure><p>创建一个 src&#x2F;main.js 文件，随便写点啥<br>在根目录创建 build&#x2F;webpack.common.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../src/main.js&quot;</span>),<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].bundle.js&quot;</span>,<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../dist&quot;</span>),<br>        <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里需要注意一点是为什么 webpack 配置文件要用 cjs 来写 ?</p><p>答案就是因为 webpack 打包过程是在 node 环境下</p></blockquote><p>在 package.json 加上打包命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config build/webpack.common.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过执行  <code>pnpm run build</code> 进行打包，执行后会生成一个 <code>dist</code> 目录，里面就是我们打包的产物。</p><blockquote><p>打包时控制台会报 <code>The &#39;mode&#39; option has not been set</code> 的警告，意思就是我们需要设置一个 mode 它可以是 <code>development</code> 开发模式、<code>production</code>生产模式、<code>none</code>无模式。</p><p>另外如果 shell 命令中参数和配置文件冲突，生效的是 shell 命令参数。</p></blockquote><h2 id="创建-HTML"><a href="#创建-HTML" class="headerlink" title="创建 HTML"></a>创建 HTML</h2><p>打包好的产物我们希望能通过html在浏览器中打开看效果，需要通过 <code>html-webpack-plugin</code> 插件实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D html-webpack-plugin<br></code></pre></td></tr></table></figure><p>在配置文件中写入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> htmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title function_">htmlWebpackPlugin</span>(&#123;<br>           <span class="hljs-comment">// 设置模板，需要在根目录创建一个 index.html 文件</span><br>            <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../index.html&quot;</span>)<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>plugins 就是我们声明插件来对 webpack 的功能进行扩展的地方。这时候再打包，发现产物目录下有一个 html 文件，并且通过 script 引入了我们打包的 js 文件。</p><h2 id="打包时显示进度"><a href="#打包时显示进度" class="headerlink" title="打包时显示进度"></a>打包时显示进度</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add progress-bar-webpack-plugin -D<br>pnpm add chalk@4.1.2 -D<br></code></pre></td></tr></table></figure><blockquote><p>这里的 <a href="https://www.npmjs.com/package/chalk?activeTab=versions">chalk</a> 最新版本（5.3.0）使用 esm 引入，我们使用 4.1.2 版本</p></blockquote><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;chalk&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProgressBarPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;progress-bar-webpack-plugin&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProgressBarPlugin</span>(&#123;<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">`  :msg [:bar] <span class="hljs-subst">$&#123;chalk.green.bold(<span class="hljs-string">&quot;:percent&quot;</span>)&#125;</span> (:elapsed s)`</span>,<br>        &#125;),<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>再进行打包就能看到进度条了，另外可以通过 chalk 来修改进度条的颜色等。</p><h1 id="处理样式"><a href="#处理样式" class="headerlink" title="处理样式"></a>处理样式</h1><p>我们定义一个 main.css 文件，在 main.js 引入，进行打包时会发现控制台报错，并提示我们需要用 loader 来处理这个类型的文件。<br>处理 css 类型文件需要用到以下两个 loader。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D style-loader css-loader<br></code></pre></td></tr></table></figure><p>在配置文件中声明使用这两个 loader 来处理 css 类型文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>   <span class="hljs-attr">rules</span>: [<br>      &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>          <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>]<br>      &#125;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><p>module 是我们用来定义某种资源通过指定的 loader 来处理，如上代码我们通过 <code>&quot;style-loader&quot;</code> 和 <code>&quot;css-loader&quot;</code> 来处理后缀名为 <code>css</code> 的文件，<code>&quot;css-loader&quot;</code> 做的是解析 css 文件，翻译成 JavaScript 代码，使得 webpack 能够如同处理 JS 代码一样解析 CSS，<code>&quot;style-loader&quot;&quot;</code> 做的是将解析出来的文件通过 <code>style</code> 标签插入到页面中。</p><blockquote><p>另外 loader 的书写顺序也是有要求的，<strong>一般情况下</strong>，会按照由右到左，由上到下的顺序执行。所以上面代码才是先解析再插入到页面。</p></blockquote><p>通过打包的产物发现我们的 css 已经被打包进 js 文件中，下面我们把 css 代码抽离出来。安装<a href="https://webpack.js.org/plugins/mini-css-extract-plugin/">MiniCssExtractPlugin</a>插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D mini-css-extract-plugin<br></code></pre></td></tr></table></figure><p>然后进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>]<br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../index.html&quot;</span>),<br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候再打包可以看到产物中多一个 css 文件，这样我们就把 css 文件抽离出来了<br><img src="https://s11.ax1x.com/2023/12/27/pibHXsH.png" alt="产物结构"><br>再看产物中的 index.html，多了一行 link 标签，所以这个插件的作用就是把 css 文件抽离并通过 link 标签的形式插入到页面中，这也是为什么在上面的配置中我们去掉了 style-loader。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;main.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 MiniCssExtractPlugin 插件的好处在于，避免了 js 和 css 只能同步加载，对性能有影响，并且其中任意一个更新都会导致缓存失效。另外该插件必须和上面写到的 HTMLWebpackPlugin 插件一起使用（不然连 html 文件都没有怎么插入到页面）。</p><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>我们以 less 为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D less less-loader<br></code></pre></td></tr></table></figure><p>然后新建一个 less 文件，随便写点样式，在打包入口文件导入，接着进行对 less 的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>   <span class="hljs-attr">rules</span>: [<br>      &#123;<br>         <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,<br>         <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>, <span class="hljs-string">&quot;less-loader&quot;</span>]<br>      &#125;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><p>无非在处理 css 文件的基础上，多了一个 less-loader ，这个 loader 做的就是把 less 翻译成 css。</p><h2 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h2><p>安装 <a href="https://github.com/postcss/postcss/blob/main/docs/README-cn.md">postcss</a> 和 <a href="https://webpack.docschina.org/loaders/postcss-loader#root">postcss-loader</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D postcss postcss-loader<br></code></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>postcss 有强大的插件生态来处理各种问题，常用的如 <a href="https://github.com/postcss/autoprefixer">autoprefixer</a>，他能根据配置的浏览器兼容性，检测出需要添加前缀的 css 属性，构建的时候进行添加。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D autoprefixer<br></code></pre></td></tr></table></figure><p>对 postcss 配置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    test:</span> /\.less$/,<br><span class="hljs-symbol">    use:</span> [<br>        MiniCssExtractPlugin.loader,<br>        <span class="hljs-string">&quot;css-loader&quot;</span>,<br>        <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            loader:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span>,<br><span class="hljs-symbol">            options:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">                postcssOptions:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-comment">// 添加 autoprefixer 插件</span><br><span class="hljs-symbol">                    plugins:</span> [require(<span class="hljs-string">&quot;autoprefixer&quot;</span>)],<br>                <span class="hljs-punctuation">&#125;</span>,<br>            <span class="hljs-punctuation">&#125;</span>,<br>        <span class="hljs-punctuation">&#125;</span>,<br>        <span class="hljs-string">&quot;less-loader&quot;</span>]<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在 less 文件中写入</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-pseudo">::placeholder</span> &#123;<br>  <span class="hljs-attribute">color</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>打包后可以看到产物已经增加了前缀<br><img src="https://s11.ax1x.com/2023/12/27/pibLirQ.png"></p><blockquote><p>关于系统支持的浏览器可以通过 package.json 的 browserslist 或者 <code>.browserslistrc</code> 文件进行配置<br>另外<a href="https://github.com/csstools/postcss-preset-env">postcss-preset-env</a>也可以做同样的事情，甚至更强大，他还能将现代 CSS 转换成大多数浏览器都能理解的东西。</p></blockquote><h1 id="处理-js"><a href="#处理-js" class="headerlink" title="处理 js"></a>处理 js</h1><p>webpack 默认是支持处理 js 文件的，但在一些情况下，js 代码会存在兼容性的问题，在低版本的浏览器无法运行的情况，所以我们需要对这部分代码进行处理。这里用到的是 <code>babel</code> 对代码进行转译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D @babel/core @babel/preset-env babel-loader<br></code></pre></td></tr></table></figure><blockquote><p>@babel&#x2F;core：babel核心库<br>@babel&#x2F;preset-env 根据目标环境转译 JavaScript 的预设<br>babel-loader webpack 中的一个 loader，将 babel 集成到 webpack 构建过程中</p></blockquote><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-attr">rules</span>: [<br>         &#123;<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>            <span class="hljs-attr">use</span>: [<br>               &#123;<br>                  <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>                  <span class="hljs-attr">options</span>: &#123;<br>                     <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>                  &#125;<br>               &#125;<br>            ]<br>         &#125;]<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在入口文件我们声明一个箭头函数并执行，然后分别看使用 babel-loader 进行语法降级和 不使用的效果，可以看到用 babel 后，箭头函数被转译成如下的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">/*...*/</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="处理-ts"><a href="#处理-ts" class="headerlink" title="处理 ts"></a>处理 ts</h1><h2 id="使用-ts-loader"><a href="#使用-ts-loader" class="headerlink" title="使用 ts-loader"></a>使用 ts-loader</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D typescript ts-loader<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>   <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-attr">rules</span>: [<br>         <span class="hljs-comment">// ...</span><br>         &#123;<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,<br>            <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;ts-loader&quot;</span>]<br>         &#125;,<br>      ]<br>   &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>还需要创建 ts 的配置文件 tsconfig.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;noImplicitAny&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这时候就可以执行构建了</p><h2 id="使用-babel"><a href="#使用-babel" class="headerlink" title="使用 babel"></a>使用 babel</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D @babel/preset-typescript<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>   <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-attr">rules</span>: [<br>         <span class="hljs-comment">// ...</span><br>         &#123;<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,<br>            <span class="hljs-attr">use</span>: [<br>               &#123;<br>                  <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>                  <span class="hljs-attr">options</span>: &#123;<br>                     <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-typescript&#x27;</span>],<br>                  &#125;,<br>               &#125;,<br>            ],<br>         &#125;,<br>      ]<br>   &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>使用 <code>@babel/preset-typescript</code> 只是进行了代码转换，而 <code>ts-loader</code> 还会对代码进行类型检查。例如我们将 number 赋值给一个 string 类型。<code>ts-loader</code> 在构建时会报错。<br><img src="https://s11.ax1x.com/2023/12/27/piqCZm6.png" alt="ts-loader构建报错"></p><h1 id="处理资源"><a href="#处理资源" class="headerlink" title="处理资源"></a>处理资源</h1><h2 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D file-loader<br></code></pre></td></tr></table></figure><p>file-loader 将资源重命名，在代码中插入 url 地址。</p><h2 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D url-loader<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>   <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-attr">rules</span>: [<br>         <span class="hljs-comment">// ...</span><br>         &#123;<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg)$/</span>,<br>            <span class="hljs-attr">use</span>: [<br>               &#123;<br>                  <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>                  <span class="hljs-attr">options</span>: &#123;<br>                     <span class="hljs-attr">limit</span>: <span class="hljs-number">1024</span><br>                  &#125;<br>               &#125;<br>            ]<br>         &#125;,<br>      ]<br>   &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>url-loader 会对比资源大小和配置的限制大小，如果没超出限制就转为 Base64 编码，超出的话就同 file-loader 一致。</p><h2 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h2><p>不转译，直接将文件复制到产物。</p><h2 id="Webpack5-通过-module-rules-type-指定资源类型。"><a href="#Webpack5-通过-module-rules-type-指定资源类型。" class="headerlink" title="Webpack5 通过 module.rules.type 指定资源类型。"></a>Webpack5 通过 <code>module.rules.type</code> 指定资源类型。</h2><p><code>asset/resource</code> 对标 <code>file-loader</code><br><code>asset</code> 对标 <code>url-loader</code>，<code>module.rules.parser.dataUrlCondition</code> 用于限定文件大小阈值<br><code>asset/source</code> 对标 <code>raw-loader</code> &#x2F; <code>asset/inline</code></p><p><a href="https://webpack.js.org/guides/asset-modules/">查看更多</a></p><h1 id="区分开发环境和生产环境"><a href="#区分开发环境和生产环境" class="headerlink" title="区分开发环境和生产环境"></a>区分开发环境和生产环境</h1><p>我们上面写到的 webpack.common.js 可以作为一个基础的配置，在开发环境和生产环境中配置也是有差异的，所以我们还需要分别去配置。<br>创建 <code>build/webpack.dev.js</code> 和 <code>build/webpack.prod.js</code><br>因为开发环境和生产环境都基于基础配置，我们需要通过 webpack.merge 将他们连接起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D webpack-merge<br></code></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>一般开发环境我们希望项目构建后能直接在浏览器运行，这一点通过 <code>webpack-dev-server</code> 来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm add -D webpack-dev-server<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-merge&quot;</span>);<br><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./webpack.common.js&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123;<br>   <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>   <span class="hljs-attr">devServer</span>: &#123;<br>      <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>   &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>重写启动命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve --config build/webpack.dev.js&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>执行 <code>pnpm run dev</code> 将会在 3000 端口启动。</p><h1 id="关于打包命名"><a href="#关于打包命名" class="headerlink" title="关于打包命名"></a>关于打包命名</h1><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>[name]</td><td>文件名称</td></tr><tr><td>[hash]</td><td>每次webpack构建时生成一个唯一的hash值</td></tr><tr><td>[chunkhash]</td><td>根据chunk生成hash值，来源于同一个chunk，则hash值就一样</td></tr><tr><td>[contenthash]</td><td>根据内容生成hash值，文件内容相同hash值就相同</td></tr></tbody></table><h1 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h1><p>一般建议在开发环境中开启 sourcemap 开启方法也很简单 配置中设置 devtool 即可，默认在开发环境中是 eval 生产环境是 none</p><p>开发环境一些参数（具体需要看文档） </p><p>eval 会在构建时使用 eval 来执行代码，在末尾加上 &#x2F;&#x2F;# sourceURL&#x3D;xxx.js 来指定映射文件路径，报错时会指向webpack 生成的一个临时文件中，速度最快</p><p>eval-source-map 和 eval 类似， 区别在于使用的是 dataUrl 的方式</p><p>cheap-eval–source-map 类似 eval-source-map  但开销更低 只映射行数，会忽略 loader 的sourcemap</p><p>cheap-module-eval–source-map 支持 loader 的 sourcemap</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出前端模块化原理</title>
    <link href="/2023/12/18/module/"/>
    <url>/2023/12/18/module/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>模块化简单说就是为了解决代码没有自己的“域”，很容易造成命名冲突，依赖混乱。我们的代码通过模块化隔离开来，更有利于后期维护。</p><h2 id="模块化解决方案"><a href="#模块化解决方案" class="headerlink" title="模块化解决方案"></a>模块化解决方案</h2><p>从最开始的通过立即执行函数（IIFE）到 CJS、AMD、CMD、UMD、再到 ES6 引入模块化 ESM，本文主要写 CJS 和 ESM。</p><h1 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./name&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/name.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;john&quot;</span>;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">name</span>: name,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把以上代码打包，通过产物看一下CJS到底是如何进行模块化的。<strong>产物代码经过简化</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 定义一个 modules 存放每个文件的源码，[key] 是文件路径</span><br>    <span class="hljs-keyword">var</span> __webpack_modules__ = (&#123;<br>        <span class="hljs-string">&quot;./src/index.js&quot;</span>: (<span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __unused_webpack_exports, __webpack_require__</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;),<br>        <span class="hljs-string">&quot;./src/name.js&quot;</span>: (<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;)<br>    &#125;);<br>    <span class="hljs-comment">// 缓存</span><br>    <span class="hljs-keyword">var</span> __webpack_module_cache__ = &#123;&#125;;<br><br>    <span class="hljs-comment">// 获取源码的方法</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) &#123;<br>        <span class="hljs-comment">// 读取缓存</span><br>        <span class="hljs-keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];<br>        <span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-comment">// 有缓存就不执行了，直接返回缓存</span><br>            <span class="hljs-keyword">return</span> cachedModule.<span class="hljs-property">exports</span>;<br>        &#125;<br>        <span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = __webpack_module_cache__[moduleId] = &#123;<br>            <span class="hljs-attr">exports</span>: &#123;&#125;<br>        &#125;;<br>        <span class="hljs-comment">// 没缓存就执行然后缓存，</span><br>        __webpack_modules__[moduleId](<span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, __webpack_require__);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行入口函数</span><br>    <span class="hljs-keyword">var</span> __webpack_exports__ = <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-string">&quot;./src/index.js&quot;</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>从产物中不难看出 CJS 把每个路径的源码都存在一起，然后通过 require 来实现读取并缓存，实现模块化的功能，其实说到底还是使用了立即执行函数（IIFE）来实现的。<br><img src="https://s11.ax1x.com/2023/12/18/pi5L129.png" alt="CJS原理"></p><h1 id="EsModule"><a href="#EsModule" class="headerlink" title="EsModule"></a>EsModule</h1><p>我们在 name.js 加上默认导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/name.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;john&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;this is default&quot;</span><br></code></pre></td></tr></table></figure><p>ESM 和 CJS 的区别在于，ESM 给 exports 做了一层代理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> __webpack_modules__ = (&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-string">&quot;./src/name.js&quot;</span>: (<span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 扩展里会写到</span><br>        __webpack_require__.<span class="hljs-title function_">r</span>(__webpack_exports__);<br>        <span class="hljs-comment">// 进行代理</span><br>        __webpack_require__.<span class="hljs-title function_">d</span>(__webpack_exports__, &#123;<br>            <span class="hljs-string">&quot;default&quot;</span>: <span class="hljs-function">() =&gt;</span> (__WEBPACK_DEFAULT_EXPORT__),<br>            <span class="hljs-attr">name</span>: <span class="hljs-function">() =&gt;</span> (name)<br>        &#125;);<br>        <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;john&quot;</span>;<br>        <span class="hljs-keyword">const</span> __WEBPACK_DEFAULT_EXPORT__ = (<span class="hljs-string">&quot;this is default&quot;</span>);<br>    &#125;)<br>&#125;);<br><br>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 代理</span><br>    __webpack_require__.<span class="hljs-property">d</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">exports</span>, definition</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> definition) &#123;<br>            <span class="hljs-keyword">if</span> (__webpack_require__.<span class="hljs-title function_">o</span>(definition, key) &amp;&amp; !__webpack_require__.<span class="hljs-title function_">o</span>(<span class="hljs-built_in">exports</span>, key)) &#123;<br>                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, key, &#123;<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">get</span>: definition[key]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>当我们使用 ESM 导入的值，实际上都是代理值，我们每次访问这个值其实都是通过要这个代理，这也就是为什么导出后改变这个值，导入的文件也能拿到更新后的值。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="设置值类型"><a href="#设置值类型" class="headerlink" title="设置值类型"></a>设置值类型</h2><p>在 EsModule 的 <code>__webpack_modules__</code> 中有一个方法 <code>__webpack_require__.r</code> 这个是干什么用的呢？他其实就是把 exports标记成 <code>Module</code> 类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function">() =&gt;</span> &#123;<br>    __webpack_require__.<span class="hljs-property">r</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">exports</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>) &#123;<br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Module&#x27;</span>&#125;);<br>        &#125;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&#x27;__esModule&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>&#125;);<br>    &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>我们判断一个值的属性，通过 <code>Object.prototype.toString.call()</code>方法，那么这个方法是根据什么判断出类型的？其实就是根据值的 <code>Symbol.toStringTag</code> 来识别。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Module&quot;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj)); <span class="hljs-comment">// [object Module]</span><br></code></pre></td></tr></table></figure><h2 id="CJS-和-ESM-区别"><a href="#CJS-和-ESM-区别" class="headerlink" title="CJS 和 ESM 区别"></a>CJS 和 ESM 区别</h2><table><thead><tr><th></th><th>CJS</th><th>ESM</th></tr></thead><tbody><tr><td>语法类型</td><td>动态</td><td>静态</td></tr><tr><td>加载方式</td><td>运行时加载</td><td>编译时加载</td></tr><tr><td>加载行为</td><td>同步加载</td><td>异步加载</td></tr><tr><td>this指向</td><td>当前模块</td><td>undefined</td></tr><tr><td>能否修改</td><td>可以修改引用的值</td><td>引入的值是只读的</td></tr><tr><td>引用</td><td>基本类型复制<br/>引用类型浅拷贝</td><td>动态只读引用</td></tr><tr><td>书写位置</td><td>任意位置</td><td>顶层</td></tr></tbody></table><h3 id="运行时加载和编译时加载"><a href="#运行时加载和编译时加载" class="headerlink" title="运行时加载和编译时加载"></a>运行时加载和编译时加载</h3><p>运行时加载会生成一个对象全部加载，运行时获得该对象。编译时加载直接从模块中加载，能做到按需加载，效率更高。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
      <tag>CommonJs</tag>
      
      <tag>ES Module</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无法避免的正则表达式</title>
    <link href="/2023/12/13/regexp/"/>
    <url>/2023/12/13/regexp/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h2><p>我们在日常开发中总是能遇到一些需要校验的功能，例如校验邮箱、手机号等等，或者对一些字符串做替换处理等，正则表达式总是避不开的。个人理解正则就是用来匹配字符，校验字符规则，或者是提取一段字符中的内容。本文只介绍正则的一些基本使用。</p><h1 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h1><h2 id="匹配模糊长度"><a href="#匹配模糊长度" class="headerlink" title="匹配模糊长度"></a>匹配模糊长度</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/ab&#123;1,5&#125;c/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abc abbc abbbc abbbbbbbc&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;abc&#x27;, &#x27;abbc&#x27;, &#x27;abbbc&#x27; ]</span><br></code></pre></td></tr></table></figure><p>通过 <strong>{m,n}</strong> 的形式来设置匹配的长度范围，以上代码匹配的就是 b 出现 1 - 5 次。而且 {m,n}中，可以省略，代表匹配出现至少 m 次，或者只写 m，{m} 代表匹配只出现 m 次。</p><h2 id="匹配模糊字符"><a href="#匹配模糊字符" class="headerlink" title="匹配模糊字符"></a>匹配模糊字符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/a[bcde]a/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;aba aca ada aaa&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;aba&#x27;, &#x27;aca&#x27;, &#x27;ada&#x27; ]</span><br></code></pre></td></tr></table></figure><p>通过 <strong>[]</strong> 的形式来设置可能出现的字符，以上代码匹配的就是 <code>bcde</code> 中出现任意一个。</p><p>排除某些字符用 <strong>^</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/a[^bcde]c/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abc acc adc aac&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;aac&#x27; ]</span><br></code></pre></td></tr></table></figure><p>通过 <strong>^</strong> 来设置不匹配哪些字符，以上代码匹配的就是 除了 <code>bcde</code> 字符外任意字符</p><h2 id="多分支匹配"><a href="#多分支匹配" class="headerlink" title="多分支匹配"></a>多分支匹配</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/a|b|cd|efg/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;adbdcdefg&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;cd&#x27;, &#x27;efg&#x27; ]</span><br></code></pre></td></tr></table></figure><p>多分支匹配通过 <strong>|</strong> 实现，意思是匹配其中任意一个即可，和 JS 中的 <code>或</code> 类似，另外需要注意当前面的分支匹配上后就不会继续进行匹配了。</p><h1 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h1><h2 id="锚字符"><a href="#锚字符" class="headerlink" title="锚字符"></a>锚字符</h2><ul><li>^ 匹配开头</li><li>$ 匹配结尾</li><li>\b 单词字符和非单词字符之间，也就是 \w 和 \W 之间</li><li>\B 把 \b 取反</li><li>(?&#x3D;p) p 前的位置</li><li>(?&#x3D;p) 除了p 前的位置</li></ul><h2 id="开头结尾"><a href="#开头结尾" class="headerlink" title="开头结尾 ^ $"></a>开头结尾 ^ $</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/^ab$/g</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;ab&#x27; ]</span><br></code></pre></td></tr></table></figure><p>以上代码就是匹配以 a 开头，b 结尾的字符串，另外字符串有一个方法 replace 可以通过匹配位置进行替换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> string = <span class="hljs-string">&quot;abdefg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^|$/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">// #abdefg#</span><br></code></pre></td></tr></table></figure><p>通过匹配字符串的开头和结尾位置，替换成 #。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> string = <span class="hljs-string">&quot;a\nb\nd\ne\nf\ng&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^|$/gm</span>, <span class="hljs-string">&#x27;#&#x27;</span>))<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#a#</span><br><span class="hljs-comment">#b#</span><br><span class="hljs-comment">#d#</span><br><span class="hljs-comment">#e#</span><br><span class="hljs-comment">#f#</span><br><span class="hljs-comment">#g#</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在多行模式匹配下，开头和结尾是每行的开头结尾。</p><h2 id="单词边界-b-B"><a href="#单词边界-b-B" class="headerlink" title="单词边界 \b \B"></a>单词边界 \b \B</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> string = <span class="hljs-string">&quot;Hello,[JS] Hello World&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\b/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">// #Hello#,[#JS#] #Hello# #World#</span><br></code></pre></td></tr></table></figure><p>单词边界就是 \w 和 \W 之间，也就是所有数字、字符串以及下划线 和 其他字符之间，也就是下图箭头所指的位置。注意看箭头两边的字符分别是\w 和 \W，另外要注意的是开头和结尾也是 \W。<br><img src="https://s11.ax1x.com/2023/12/14/pihZunS.png" alt="单词边界"><br>那 \B 就很好理解了，就是除了 \w 所指位置的其他位置。</p><h2 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h2><p><code>(?=p)</code>（正向先行断言）指 p 前面的位置，这个 p 就是一个子模式，先用 p 进行匹配，然后再取他前面的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> string = <span class="hljs-string">&quot;Hello,[JS] Hello World&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?=\w)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">// #H#e#l#l#o,[#J#S] #H#e#l#l#o #W#o#r#l#d</span><br></code></pre></td></tr></table></figure><p><code>(?!p)</code>（负向先行断言）就是和 <code>(?=p)</code> 相反，就是先匹配非 p 然后取前面的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?!\w)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">// Hello#,#[JS#]# Hello# World#</span><br></code></pre></td></tr></table></figure><p><code>(?&lt;=p)</code> 指 p 后面的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?&lt;=\w)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">// H#e#l#l#o#,[J#S#] H#e#l#l#o# W#o#r#l#d#</span><br></code></pre></td></tr></table></figure><p><code>(?&gt;!p)</code> 和 <code>(?&lt;=p)</code> 相反</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?&lt;!\w)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">// #Hello,#[#JS]# #Hello #World</span><br></code></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>给金额加上千分位逗号 例如 123456789 -&gt; 123,456,789<br>解题思路：先选中倒数第三位前的位置替换成逗号，然后出现多次，最后排除开头的位置。<br><img src="https://s11.ax1x.com/2023/12/14/pihDGX6.png" alt="需要匹配的位置"><br>我们要做的就是选中图中箭头的位置</p><p><strong>第一步</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> string = <span class="hljs-string">&quot;123456789&quot;</span>;<br><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(?=\d&#123;3&#125;$)/g</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(regexp, <span class="hljs-string">&quot;,&quot;</span>)); <span class="hljs-comment">// 123456,789</span><br></code></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2023/12/14/pihDwhd.png" alt="第一步"><br>上面的正则匹配的就是以三个数字结尾前的位置，然后替换成逗号。<br><strong>第二步</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(?=(\d&#123;3&#125;)+$)/g</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(regexp, <span class="hljs-string">&quot;,&quot;</span>)); <span class="hljs-comment">// ,123,456,789</span><br></code></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2023/12/14/pihDdtH.png" alt="第二步"><br>通过 <code>+</code> 让三个数字匹配多次，达到匹配上每三位数字前的位置，然后替换成逗号，这时发现开头的位置多了一个逗号，我们需要排除掉开始的位置<br><strong>第三步</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">replace</span>(regexp, <span class="hljs-string">&quot;,&quot;</span>)); <span class="hljs-comment">// 123,456,789</span><br></code></pre></td></tr></table></figure><p>通过<code>(?!^)</code>匹配除了开始位置的其他位置，这种方法就排除掉了开头，达到了预期的效果。</p><h1 id="影响量词的匹配行为"><a href="#影响量词的匹配行为" class="headerlink" title="影响量词的匹配行为"></a>影响量词的匹配行为</h1><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>正则在进行量词匹配时，会尽可能地多匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/a&#123;1,3&#125;/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;aaa aaaa aaaaa&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;aaa&#x27;, &#x27;aaa&#x27;, &#x27;a&#x27;, &#x27;aaa&#x27;, &#x27;aa&#x27; ]</span><br></code></pre></td></tr></table></figure><h2 id="惰性匹配（非贪婪匹配）"><a href="#惰性匹配（非贪婪匹配）" class="headerlink" title="惰性匹配（非贪婪匹配）"></a>惰性匹配（非贪婪匹配）</h2><p>我们使用 ? 来声明惰性匹配，惰性匹配每次只满足最低要求即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/a&#123;1,3&#125;?/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;aaa&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27; ]</span><br></code></pre></td></tr></table></figure><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>我们可以通过<code>()</code>来对正则表达式进行分组，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(abc)+/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abcabc abccc&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;abcabc&#x27;, &#x27;abc&#x27; ]</span><br></code></pre></td></tr></table></figure><p>把 <code>abc</code> 括起来使他们成为一个分组，<code>+</code>的就是这个分组。</p><h2 id="提取分组的数据"><a href="#提取分组的数据" class="headerlink" title="提取分组的数据"></a>提取分组的数据</h2><p>我们对正则进行分组匹配后还可以拿到分组匹配到的数据，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(\d+)([a-z]+)/</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;1231abc&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regexp.<span class="hljs-title function_">exec</span>(str))<br></code></pre></td></tr></table></figure><p>两个输出结果相同，输出结果：<br><img src="https://s11.ax1x.com/2023/12/15/pihXNtg.png" alt="输出结果"></p><p>需要注意的是，在捕获分组的时候，使用全部匹配 <code>/g</code> 就不返回分组信息了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(\d+)([a-z]+)/g</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;1231abc&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp)) <span class="hljs-comment">// [ &#x27;1231abc&#x27; ]</span><br></code></pre></td></tr></table></figure><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>在正则表达式中，如果有一个不确定的字符，后面还需要用到这个相同的字符，就可以用反向引用的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/\d&#123;3&#125;([,\-])\d&#123;3&#125;\1\d&#123;3&#125;/</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;123,456,789&quot;</span>;<br><span class="hljs-keyword">const</span> str2 = <span class="hljs-string">&quot;123-456-789&quot;</span>;<br><span class="hljs-keyword">const</span> str3 = <span class="hljs-string">&quot;123-456,789&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regexp.<span class="hljs-title function_">test</span>(str))   <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regexp.<span class="hljs-title function_">test</span>(str2))  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regexp.<span class="hljs-title function_">test</span>(str3))  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>这里我们用 <code>\1</code> 来引用第一个分组的字符，所以当前面是 <code>,</code> 后面也只能是 <code>,</code>，这样就能做到前后一致。<br>另外如果出现嵌套括号的情况，我们以左括号出现的顺序为引用的顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* \1  =&gt; ((\d)(\d(\d)))</span><br><span class="hljs-comment">* \2  =&gt; (\d)</span><br><span class="hljs-comment">* \3  =&gt; (\d(\d))</span><br><span class="hljs-comment">* \4  =&gt; (\d)</span><br><span class="hljs-comment">* */</span><br></code></pre></td></tr></table></figure><p><img src="https://s11.ax1x.com/2023/12/15/pi4pkXd.png" alt="红色是 \1 ，绿色是 \2 ，橙色是 \3 ，蓝色是 \4"></p><p>如果不希望分组被提取引用，使用非捕获分组 <code>(?:p)</code>，我们把上面的代码修改一下看结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(\d+)([a-z]+)/</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;1231abc&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(regexp))<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://s11.ax1x.com/2023/12/15/pi4AXod.png" alt="非捕获分组输出"></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>详细查阅： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions">正则表达式</a></p><h2 id="匹配数量简写"><a href="#匹配数量简写" class="headerlink" title="匹配数量简写"></a>匹配数量简写</h2><ul><li>{m,} 至少出现 m 次数</li><li>{m} 只出现 m 次数</li><li>? 不出现或者出现一次 等价于 {0,1}</li><li>+ 至少出现一次</li><li>* 有没有都行</li></ul><h2 id="匹配范围简写"><a href="#匹配范围简写" class="headerlink" title="匹配范围简写"></a>匹配范围简写</h2><ul><li>\d 表示数字</li><li>\D 除了数字外任意字符</li><li>\w 数字+字母+下划线</li><li>\W 除了 \w</li><li>\s 空白字符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符</li><li>\S 非空白符</li><li>. 任意字符</li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li>i 不区分大小写</li><li>g 全局匹配</li><li>m 多行匹配</li><li>s 允许 . 匹配换行符。</li><li>u 使用 unicode 码的模式进行匹配。</li><li>y 粘性 匹配从目标字符串的当前位置开始。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript入坑指北</title>
    <link href="/2023/10/31/ts-01/"/>
    <url>/2023/10/31/ts-01/</url>
    
    <content type="html"><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>Typescript 包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%8E%9F%E5%A7%8B%E5%80%BC_primitive_values">Javascript 的全部类型</a>，也就是 number、boolean、string、object、bigint、symbol、undefined、null，还有包装类 Number、Boolean、String、Object、Symbol。</p><p>除此之外，Typescript 还有 void、never、enum、unknown、any、tuple(元组) 以及自定义的 type 和 interface。</p><h2 id="null、undefined"><a href="#null、undefined" class="headerlink" title="null、undefined"></a>null、undefined</h2><p>在 Typescript 中，null、undefined 标识一个具体的类型值，被当成其他类型的子类型（在不开启 strictNullChecks 前提下），也就是说 null 和 undefined 可以赋值给其他类型的变量</p><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>用来表示一个函数没有显示的返回值。这里的 test2 虽然可以用 void 但其实它显示声明了 return， 只不过什么都没返回，所以用 undefined 更好。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="void-的特殊情况"><a href="#void-的特殊情况" class="headerlink" title="void 的特殊情况"></a>void 的特殊情况</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fun</span>  = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">fun</span>: <span class="hljs-title class_">Fun</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fun</span>();<br></code></pre></td></tr></table></figure><p>这里 Fun 返回值是 void，实际 fun 返回了一个字符串，这段代码并没有报错，而且 result 的类型还是 void。这虽然看起来有点奇怪，但其实 TS 并没有强制要求 void 真的不能什么都不返回，他的意思更倾向于返回值并不会被使用，就像我们写 forEach 返回值是 void ，但我们箭头函数简写一般都会省略代码块。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>never 在 Typescript 中表示什么都没有，他不可以被任何类型赋值，但可以赋值给任何类型。<br><img src="https://z1.ax1x.com/2023/12/12/piWDU0g.png" alt="不能被任何类型赋值"><br>另外在联合类型中，never 直接被无视掉。<br><img src="https://z1.ax1x.com/2023/12/12/piWDa7Q.png" alt="在联合类型被移除"></p><h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h2><p>枚举其实可以理解成我们把一些常量封装到一个命名空间里面，通过这个命名空间来给我们提供类型提示。<br>另外，如果你没有给你的 enum 赋值，那么他会自动从 0 开始累加赋值。如果你给某个枚举赋值数字，那么他下面的会依次累加。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Numbers</span> &#123;<br>    a, <span class="hljs-comment">// 0</span><br>    b, <span class="hljs-comment">// 1</span><br>    c = <span class="hljs-number">200</span>,<br>    d, <span class="hljs-comment">// 201</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="enum-的延迟求值"><a href="#enum-的延迟求值" class="headerlink" title="enum 的延迟求值"></a>enum 的延迟求值</h3><p>在枚举中，可以通过赋值一个函数执行来进行延迟求值，但是如果使用延迟求职，他后面的值无法自己累加，所以没显示赋值的枚举不能直接在延迟求职之后。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getNum</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    num1 = <span class="hljs-title function_">getNum</span>(),<br>    num2 = <span class="hljs-number">1</span>,<br>    num3,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向映射"><a href="#双向映射" class="headerlink" title="双向映射"></a>双向映射</h3><p>Typescript 中，<strong>值为数字的</strong>枚举成员是双向映射的，也就是你可以通过枚举成员获取到枚举值，也可以通过枚举值来找到它的枚举成员，延迟求职的枚举也不例外。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getNum</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-number">1</span> + <span class="hljs-number">14</span>;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    num1 = <span class="hljs-title function_">getNum</span>(),<br>    num2 = <span class="hljs-number">1</span>,<br>    num3,<br>&#125;<br><br><span class="hljs-keyword">const</span> num = <span class="hljs-title class_">Items</span>.<span class="hljs-property">num1</span> <span class="hljs-comment">// 15</span><br><span class="hljs-keyword">const</span> key = <span class="hljs-title class_">Items</span>[<span class="hljs-number">15</span>]  <span class="hljs-comment">// &#x27;num1&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>常量枚举只能通过枚举成员访问枚举值，它的编译产物和普通枚举也有所不同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 常量枚举</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    num1,<br>    num2,<br>    num3,<br>&#125;<br><br><span class="hljs-keyword">const</span> num = <span class="hljs-title class_">Items</span>.<span class="hljs-property">num1</span><br></code></pre></td></tr></table></figure><p>常量枚举编译产物 <a href="https://www.tslang.cn/play/index.html#src=const%20enum%20Items%20%7B%0D%0A%20%20%20%20num1%2C%0D%0A%20%20%20%20num2%2C%0D%0A%20%20%20%20num3%2C%0D%0A%7D%0D%0A%0D%0Aconst%20num%20%3D%20Items.num1">在线试一试</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span> <span class="hljs-comment">/* num1 */</span>;<br></code></pre></td></tr></table></figure><p>普通枚举产物 <a href="https://www.tslang.cn/play/index.html#src=enum%20Items%20%7B%0D%0A%20%20%20%20num1%2C%0D%0A%20%20%20%20num2%2C%0D%0A%20%20%20%20num3%2C%0D%0A%7D%0D%0A%0D%0Aconst%20num%20%3D%20Items.num1">在线试一试</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Items</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Items</span>) &#123;<br>    <span class="hljs-title class_">Items</span>[<span class="hljs-title class_">Items</span>[<span class="hljs-string">&quot;num1&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;num1&quot;</span>;<br>    <span class="hljs-title class_">Items</span>[<span class="hljs-title class_">Items</span>[<span class="hljs-string">&quot;num2&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;num2&quot;</span>;<br>    <span class="hljs-title class_">Items</span>[<span class="hljs-title class_">Items</span>[<span class="hljs-string">&quot;num3&quot;</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">&quot;num3&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Items</span> || (<span class="hljs-title class_">Items</span> = &#123;&#125;));<br><span class="hljs-keyword">var</span> num = <span class="hljs-title class_">Items</span>.<span class="hljs-property">num1</span>;<br></code></pre></td></tr></table></figure><p>通过产物不难看出，普通枚举双向映射的原因是进行了两次赋值，在 Item 中对 枚举值和枚举对象都进行了赋值。</p><h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>元组类型其实就是元素个数和类型固定的数组类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]<br></code></pre></td></tr></table></figure><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><p>接口一般用来描述对象、函数、构造器、索引类型（对象、class、数组）等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口可以被继承</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-attr">phone</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">peron</span>:<span class="hljs-title class_">IPerson2</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;xxx.xx.com&#x27;</span>,<br>    <span class="hljs-attr">phone</span>: <span class="hljs-string">&#x27;1xxxxxxxxx&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还可以被实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口索引签名"><a href="#接口索引签名" class="headerlink" title="接口索引签名"></a>接口索引签名</h3><p>当遇到一个对象有多个属性，并且属性名不确定的情况，可以通过索引签名来处理未知的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    [<span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">IPerson</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>    <span class="hljs-attr">phone</span>: <span class="hljs-string">&#x27;xxxxxx&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="interface-和-type-区别"><a href="#interface-和-type-区别" class="headerlink" title="interface 和 type 区别"></a>interface 和 type 区别</h3><ol><li>type 能描述所有数据，interface 描述对象</li><li>interface 可以同名（视为扩展），type 不能重名</li><li>interface 可以继承（extends）和实现（implements）</li><li>interface 可以声明属性为可选或必填，type 不行。</li></ol><h1 id="类型装饰"><a href="#类型装饰" class="headerlink" title="类型装饰"></a>类型装饰</h1><h2 id="是否可选"><a href="#是否可选" class="headerlink" title="是否可选"></a>是否可选</h2><p>Typescript 中通过 ? 来声明一个属性是否为可选属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">IPerson</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>    <span class="hljs-comment">// age 为可选属性 非必选项</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="是否只读"><a href="#是否只读" class="headerlink" title="是否只读"></a>是否只读</h2><p>Typescript 通过 readonly 来声明一个值是只读的，当只读的属性被修改报错。<br><img src="https://z1.ax1x.com/2023/12/04/piyxtl8.png" alt="readonly.png"></p><h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>类型断言就是在 Typescript 分析的类型不符合预期时，自己手动指定一个类型。</p><h2 id="尖括号方法"><a href="#尖括号方法" class="headerlink" title="尖括号方法"></a>尖括号方法</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">len</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;value).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>通过尖括号的方法来将 any 类型的 value 断言为 string 类型，调用 string 的 length 属性</p><h2 id="as"><a href="#as" class="headerlink" title="as"></a>as</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">len</span>: <span class="hljs-built_in">number</span> = (value <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>as 语法进行断言应该更加常用。</p><h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><p>非空断言用来声明某个值一定不是 null 或 undefined。</p><p><img src="https://z1.ax1x.com/2023/12/12/piWD6XT.png"></p><p>这里的 name 可能不存在 ，所以 Typescript 警告属性可能为 undefined，此时我们就可以使用非空断言，声明值存在。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = &#123;<br>    name?: <span class="hljs-built_in">string</span>,<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>:<span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>!.<span class="hljs-property">length</span>)<br></code></pre></td></tr></table></figure><p>非空断言在处理某些属性为空值无法继续调用时很有用。</p><h1 id="类型运算"><a href="#类型运算" class="headerlink" title="类型运算"></a>类型运算</h1><h2 id="条件类型-extends"><a href="#条件类型-extends" class="headerlink" title="条件类型 extends"></a>条件类型 extends</h2><p>extends 一般用作泛型类型约束，和定义条件类型</p><ol><li>泛型类型约束 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToReadonly</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>    <span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]: T[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure>泛型类型约束就是限制传入参数的类型</li><li>定义条件类型 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsAny</span>&lt;T&gt; = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">extends</span> (<span class="hljs-string">&#x27;b&#x27;</span> &amp; T) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>定义条件类型就是在做类型运算的时候，对类型进行推导，可以简单理解为 extends 前的类型是否为后的子类型，然后通过 Javascript 里常用的三元表达式来得到计算结果。</li></ol><h2 id="推导-infer"><a href="#推导-infer" class="headerlink" title="推导 infer"></a>推导 infer</h2><p>infer 在做类型运算的时候，起到提取元素的作用，你也可以简单理解为，用 infer 声明一个变量，然后在计算中使用这个变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> reverseArr&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]&gt; = T <span class="hljs-keyword">extends</span> [...infer <span class="hljs-title class_">Fist</span>, infer <span class="hljs-title class_">Last</span>] ? [<span class="hljs-title class_">Last</span>, ...reverseArr&lt;<span class="hljs-title class_">Fist</span>&gt;] : T;<br></code></pre></td></tr></table></figure><h2 id="联合"><a href="#联合" class="headerlink" title="联合 |"></a>联合 |</h2><p>和 Javascript 中的 | 作用类似，代表满足多个类型中的一个即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumType</span> = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">num</span>:<span class="hljs-title class_">NumType</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="交叉"><a href="#交叉" class="headerlink" title="交叉 &amp;"></a>交叉 &amp;</h2><p>和 Javascript 中的 &amp; 作用类似，代表需要满足全部条件，对类型做合并。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Type</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125; &amp; &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>:<span class="hljs-title class_">Type</span> = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>另外不同类型无法合并</strong></p><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>映射类型用于从一个现有的类型中创建新类型的方式，就是在在现有类型基础上进行属性转换</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapType</span>&lt;T&gt; = &#123;<br>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]?: T[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>in</strong> 就是对 keyof T 进行遍历<br><strong>keyof</strong> 是取 T 的key，可以成为索引查询<br><strong>T[Key]</strong> 是取值，成为索引访问</p><p>那么通过现有类型如何创建新类型呢</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapType</span>&lt;T&gt; = &#123;<br>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]?: [T[<span class="hljs-title class_">Key</span>], T[<span class="hljs-title class_">Key</span>]]<br>&#125;<br></code></pre></td></tr></table></figure><p>首先可以对索引的 value 进行修改，这里让每个值变成相同类型的长度为2的数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapType</span>&lt;T&gt; = &#123;<br>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer A&#125;</span><span class="hljs-subst">$&#123;infer B&#125;</span>`</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;A&#125;</span>_<span class="hljs-subst">$&#123;B&#125;</span>`</span> : <span class="hljs-built_in">never</span>]?: [T[<span class="hljs-title class_">Key</span>], T[<span class="hljs-title class_">Key</span>]]<br>&#125;<br></code></pre></td></tr></table></figure><p>索引当然也可以修改，通过 as 做重映射，重新定义索引名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">test</span>:<span class="hljs-title class_">MapType</span>&lt;&#123;<span class="hljs-attr">ab</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">cd</span>: <span class="hljs-built_in">number</span>&#125;&gt; = &#123;<br>    <span class="hljs-attr">a_b</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],<br>    <span class="hljs-attr">c_d</span>: [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h1><p>先看一段代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processValue</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Value is not a string.&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码我们判断入参 value 是否为 string 类型，这时在 if 内 value 已经是 string 类型。所以可以调用字符串的 toUpperCase 方法，下面我们把校验的过程抽离出来。<br><img src="https://z1.ax1x.com/2023/12/05/pi6cI9x.png"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processValue</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isString</span>(value)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Value is not a string.&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时发现类型错误，value 还是 unknown 并没有因为校验而更改类型。<br><img src="https://z1.ax1x.com/2023/12/12/piWDbnO.png"><br>Typescript 通过 <strong>is</strong> 关键字来处理这种情况</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>): value is <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>isString 这种方法称之为类型守卫，想要通过类型守卫获得参数类型，需要通过 <strong>参数 + is + 预期类型</strong>来显示声明，这样才能在判断中矫正参数类型。</p><p><code>使用 is 也有一些注意的地方</code></p><ul><li>必须返回一个布尔值。</li><li>通常结合 if、else 等条件语句使用，以根据类型进行不同的逻辑处理。</li><li>使用 is 编译器会智能推断变量类型，就不用再显示声明了</li></ul><h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><h2 id="结构化类型系统"><a href="#结构化类型系统" class="headerlink" title="结构化类型系统"></a>结构化类型系统</h2><p>TypeScript 的类型系统是一种<strong>结构化类型系统</strong>，那什么是结构化类型系统？看看 ai 怎么说：<br><img src="https://z1.ax1x.com/2023/12/12/piWDeOO.png" alt="结构化类型系统"></p><p>好的，没看懂，下面用代码来体验一下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Father</span> &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Son</span> &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>   <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">son</span>: <span class="hljs-title class_">Son</span> = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">param:Father</span>)&#123;&#125;<br><span class="hljs-title function_">test</span>(son);<br><br></code></pre></td></tr></table></figure><p>test 方法的参数明明是 Father 类型，但我们传入的 Son 类型却没有报错，这是因为这两个接口都有相同的 name 属性，并且 Son 在 Father 的基础上多了一个 age 而已，结构化类型系统会认为 Son 是 Father 的子类 。这也就是上图中的<strong>如果两个类型的成员结构相同（即它们拥有相同的属性和方法），那么它们被认为是兼容的</strong>。另外这种子类型可以赋值给父类型的情况叫做<strong>协变</strong>。</p><h1 id="分布式类型"><a href="#分布式类型" class="headerlink" title="分布式类型"></a>分布式类型</h1><p><img src="https://z1.ax1x.com/2023/12/12/piWDu0e.png" alt="分布式类型"><br>图中代码使用联合类型作为参数，Typescript 遇到这种情况会把联合类型分别传入进行类型运算，然后再合并成新的联合类型，这就是分布式类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, Y <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    T <span class="hljs-keyword">extends</span> Y<br>        ? <span class="hljs-literal">true</span><br>        : <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Test</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>正常情况下 <code>&#39;a&#39; | &#39;b&#39; extends &#39;a&#39;</code> 结果应该为 false，但当我们把他们分别当作参数传入 Test 的时候，结果却发生了变化<br><img src="https://z1.ax1x.com/2023/12/12/piWrwDO.png"><br>结果变成了 <code>boolean</code> 这就是因为分布式的作用所致，当我们把 <code>&#39;a&#39;|&#39;b&#39;</code> 传入时，等同于分别传入 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 得到结果后再联合，<code>&#39;a&#39;</code> 得到的结果是 true，<code>&#39;b&#39;</code>得到的结果是 false，联合起来就是 boolean 类型。</p><h2 id="关闭分布式"><a href="#关闭分布式" class="headerlink" title="关闭分布式"></a>关闭分布式</h2><p>以上得到的结果显然是不对的，那我们如何关闭分布式，让他直接对比呢</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, Y <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    [T] <span class="hljs-keyword">extends</span> [Y]<br>        ? <span class="hljs-literal">true</span><br>        : <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Test</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>这里把 <code>T extends Y</code> 改成 <code>[T] extends [Y] </code> 关闭分布式，让联合类型不再分别做类型运算，而是直接进行运算，这样就可以直接运算得到符合预期的结果了。</p><h1 id="内置高级类型"><a href="#内置高级类型" class="headerlink" title="内置高级类型"></a>内置高级类型</h1><ul><li>Parameters<T> 获取函数类型 T 的参数类型组成的元组。 </li><li>ReturnType<T> 获取函数类型 T 的返回值类型。</li><li>ConstructorParameters<T>  获取构造函数类型 T 的参数类型组成的元组。</li><li>InstanceType<T>   获取构造函数类型 T 的实例类型。</li><li>ThisParameterType</li><li>OmitThisParameter</li><li>Partial<T>    将类型 T 的所有属性变为可选。</li><li>Required<T>   将类型 T 的所有属性变为必填。</li><li>Readonly<T>   将类型 T 的所有属性变为只读。</li><li>Pick&lt;T, K&gt;    从类型 T 中选取指定的属性 K。</li><li>Omit&lt;T, K&gt;    从类型 T 中排除指定的属性 K。</li><li>Record&lt;K, T&gt;  创建一个键为 K、值为 T 的对象类型。</li><li>Exclude&lt;T, U&gt; 从类型 T 中排除可以赋值给 U 的类型。</li><li>Extract&lt;T, U&gt; 从类型 T 中提取可以赋值给 U 的类型。</li><li>Awaited</li><li>NonNullable<T>    从类型 T 中排除 null 和 undefined。</li><li>Uppercase、Lowercase、Capitalize、Uncapitaliz*</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式(五)：装饰器模式</title>
    <link href="/2023/10/17/desigin-decorator/"/>
    <url>/2023/10/17/desigin-decorator/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>是一种结构型设计模式。在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求。</p><h1 id="装饰函数"><a href="#装饰函数" class="headerlink" title="装饰函数"></a>装饰函数</h1><p>装饰函数可以让我们在不修改原方法的情况加对原函数进行包装，增加额外的功能。在日常开发中难免遇到原来的需求现在要增加新的功能，如果原来的代码是自己写的还好，如果是接手别人写的代码，直接修改源代码就很冒风险，甚至有可能导致其他功能异常。</p><h2 id="保存原引用方法"><a href="#保存原引用方法" class="headerlink" title="保存原引用方法"></a>保存原引用方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">const</span> _method = method1;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">newMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">_method</span>();<br>    <span class="hljs-comment">// 新功能...</span><br>&#125;<br><span class="hljs-title function_">newMethod</span>();<br></code></pre></td></tr></table></figure><p>以上我们通过中间变量保存原方法的引用，然后把它放进新方法中就可以做到既不修改原方法，还可以添加额外功能。但这种方式存在一些弊端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _getElementById = <span class="hljs-variable language_">document</span>.<span class="hljs-property">getElementById</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">getElementById</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_getElementById</span>(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>document.getElementById 方法内部用到了 this 正常我们调用 document.getElementById 它的内部 this 指向 document<br>，但我们执行 _getElementById 时，this 指向了 window，这时就会发生报错。</p><h2 id="使用-AOP-Aspect-Oriented-Programming"><a href="#使用-AOP-Aspect-Oriented-Programming" class="headerlink" title="使用 AOP(Aspect Oriented Programming)"></a>使用 AOP(Aspect Oriented Programming)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> before = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, beforeFn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 指向正确的 this</span><br>        beforeFn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">beforFn</span> () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;before&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">getElementById</span> = <span class="hljs-title function_">before</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">getElementById</span>, beforFn);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br></code></pre></td></tr></table></figure><p>把新增的 beforeFn 通过 before 装饰起来，在 before 中会确保 this 指向正确。</p><h1 id="使用装饰器模式做表单校验"><a href="#使用装饰器模式做表单校验" class="headerlink" title="使用装饰器模式做表单校验"></a>使用装饰器模式做表单校验</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> username = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br><span class="hljs-keyword">const</span> password = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;password&#x27;</span>);<br><span class="hljs-keyword">const</span> submit = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;submit&#x27;</span>);<br><span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> ( username.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;&#x27;</span> )&#123;<br>        <span class="hljs-keyword">return</span> alert ( <span class="hljs-string">&#x27;用户名不能为空&#x27;</span> );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( password.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;&#x27;</span> )&#123;<br>        <span class="hljs-keyword">return</span> alert ( <span class="hljs-string">&#x27;密码不能为空&#x27;</span> );<br>    &#125;<br>    <span class="hljs-keyword">const</span> params = &#123;<br>        <span class="hljs-attr">username</span>: username.<span class="hljs-property">value</span>,<br>        <span class="hljs-attr">password</span>: password.<span class="hljs-property">value</span>,<br>    &#125;<br>    <span class="hljs-comment">//  提交 params ...</span><br>&#125;<br>submit.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleSubmit);<br></code></pre></td></tr></table></figure><p>这是一个用户登录时的一个表单校验，在 handleSubmit 方法中进行了表单校验和整合数据最后提交的过程，这样写会让 handleSubmit 方法过于臃肿，尤其是在表单校验过多或者数据整合逻辑复杂的情况下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> before = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, beforeFn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!beforeFn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> validate = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> ( username.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;&#x27;</span> )&#123;<br>        alert ( <span class="hljs-string">&#x27;用户名不能为空&#x27;</span> )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( password.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;&#x27;</span> )&#123;<br>        alert ( <span class="hljs-string">&#x27;密码不能为空&#x27;</span> )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">let</span> handleSubmit = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> params = &#123;<br>        <span class="hljs-attr">username</span>: username.<span class="hljs-property">value</span>,<br>        <span class="hljs-attr">password</span>: password.<span class="hljs-property">value</span>,<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params)<br>    <span class="hljs-comment">//  提交 params ...</span><br>&#125;<br>handleSubmit = <span class="hljs-title function_">before</span>(handleSubmit, validate)<br></code></pre></td></tr></table></figure><p>首先定义一个 before 用来将表单校验装饰进提交方法，然后把表单校验的过程抽离出来，这样更方便维护，提交方法只需要做提交的逻辑即可。</p><h1 id="和代理模式的区别"><a href="#和代理模式的区别" class="headerlink" title="和代理模式的区别"></a>和代理模式的区别</h1><p>装饰器模式用起来感觉和代理模式很像，都是在访问或操作一个对象时通过这两种模式来进行一些额外的操作。但两者的目的就不相同，代理模式是因为不希望直接访问或者操作原对象，而是希望通过代理来使用，装饰器模式是原对象不满足我现在的使用需求，但又不好直接修改原对象，只能通过装饰对原对象进行扩展。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>装饰器模式在不改变原对象的情况下，给对象动态扩展额外的功能，这点比对象的继承更具优势。另外也更方便功能的移植，因为我们只是在个性化的场景使用装饰强化功能，基础功能不会受到任何影响。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式(四)：发布-订阅模式、观察者模式</title>
    <link href="/2023/10/13/design-observer/"/>
    <url>/2023/10/13/design-observer/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>我们暂且把发布订阅模式和观察者模式理解成相同的，是行为型模式的一种，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。<br>在日常生活中也有例子，例如我们办理银行卡时，如果订阅了手机短信功能，那么每次消费后都会给我们发送短信。</p><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>我们先来简单模拟实现一个发布订阅模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> observer = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> listeners = [];<br>    <span class="hljs-comment">// 订阅事件</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span> (sub) &#123;<br>        listeners.<span class="hljs-title function_">push</span>(sub);<br>    &#125;<br>    <span class="hljs-comment">// 发布通知</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">notify</span>(<span class="hljs-params">message</span>) &#123;<br>        listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title function_">item</span>(message));<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>        subscribe,<br>        notify,<br>    &#125;;<br>&#125;)()<br><br>observer.<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我订阅了了消息&quot;</span>, message)<br>&#125;)<br><br>observer.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;发布了一条信息。。。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>以上代码通过 listeners 存放订阅信息，subscribe 方法来订阅信息，notify 方法来发布信息。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p>EventBus 就是基于发布-订阅模式实现的，由三个主要元素构成，事件、发布者、订阅者。<br>实现一个简易的 EventBus 需要几个关键因素</p><ol><li>定义一个 tasks 来管理事件</li><li>on 方法来订阅事件</li><li>off 方法来退订</li><li>once 方法只订阅一次<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBus</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 初始化一个 tasks 存放事件名和对应的事件</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span> = &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 订阅事件</span><br>    <span class="hljs-title function_">on</span>(<span class="hljs-params">type, event</span>) &#123;<br>        <span class="hljs-comment">// 第一次订阅前先初始化</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type]) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type] = [];<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type].<span class="hljs-title function_">push</span>(event);<br>    &#125;<br>    <span class="hljs-comment">// 发布</span><br>    <span class="hljs-title function_">emit</span>(<span class="hljs-params">type, ...rest</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type]) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 循环执行所有回调</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> <span class="hljs-title function_">event</span>(...rest));<br>    &#125;<br>    <span class="hljs-comment">// 取消订阅</span><br>    <span class="hljs-title function_">off</span>(<span class="hljs-params">type, event</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type]) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 找到对应索引进行删除</span><br>        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type].<span class="hljs-title function_">indexOf</span>(event);<br>        <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>[type].<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 单次注册 执行完一次需要销毁</span><br>    <span class="hljs-title function_">once</span>(<span class="hljs-params">type, event</span>) &#123;<br>        <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-comment">// 对原方法包装一下 在 _once 方法内执行 event 执行完就删除 订阅用的也是 _once 方法</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_once</span>(<span class="hljs-params">...rest</span>) &#123;<br>            event.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>);<br>            that.<span class="hljs-title function_">off</span>(type, _once);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(type, _once);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventBus</span>();<br><br>tasks.<span class="hljs-title function_">once</span>(<span class="hljs-string">&#x27;sayHello&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>))<br>tasks.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;sayYes&#x27;</span>, <span class="hljs-function">()=&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;yes&#x27;</span>))<br><br>tasks.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;sayHello&#x27;</span>)<br>tasks.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;sayYes&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>我们常用的状态管理工具 <a href="https://l1ushun.github.io/2023/05/29/redux-source/">Redux</a> 中就使用到了观察者模式，使用 subscribe 进行订阅，dispatch 进行发布。</p><h1 id="发布订阅模式和观察者模式的区别"><a href="#发布订阅模式和观察者模式的区别" class="headerlink" title="发布订阅模式和观察者模式的区别"></a>发布订阅模式和观察者模式的区别</h1><p>一句话简单解释就是<strong>发布订阅模式需要一个中间商，观察者模式不需要</strong>，形象化解释就是小组都需要一个文件，观察者模式就是领导直接把文件发送给你，发布订阅模式就是领导把文件放在某个公有文件夹中你自己去下载。另外如果是观察者模式，那么可能把所有文件都发给了你，而发布订阅模式，你就可以按需选择你用到的文件下载即可。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>发布-订阅模式应用的比较广泛，他帮助我们对模块间进行解耦，但同时也会会消耗空间内存，当你订阅了事件但从未触发，这个事件依旧占用着内存，造成浪费，所以合理使用也很重要。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式(三)：代理模式</title>
    <link href="/2023/10/11/design-proxy/"/>
    <url>/2023/10/11/design-proxy/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><p>简单理解就是你想使用一个东西，但是你不能直接用，你必须通过一个中间商来使用，就像你想要找老板加工资，但不让你直接见老板，而是需要去找老板的助理，通过助理反馈给老板让他给你加工资。</p><p>代理模式其实也很常见，我们在写页面时，一个父节点下有很多子节点，每次点击子节点都需要触发事件，我们肯定不会挨个子节点去添加事件，而是会在让他的父节点做代理，通过冒泡到父节点触发事件。</p><h1 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h1><blockquote><p>通过代理过滤掉一些根本不符合执行条件的情况。</p></blockquote><p>例如我们有个方法去请求一些数据，后面突然需要加一些判断条件，不满足条件的就没必要再发送一次无用的请求了，这里就可以通过保护代理的方式，将筛选条件放在代理中去过滤，原本的方法还是纯粹的请求数据逻辑。<br>这样处理的好处就是不会去破环原来的逻辑，把筛选的逻辑放在代理中单独处理也更方便定位问题，代码更加清晰。</p><h1 id="虚拟代理：使用代理模式实现图片预加载"><a href="#虚拟代理：使用代理模式实现图片预加载" class="headerlink" title="虚拟代理：使用代理模式实现图片预加载"></a>虚拟代理：使用代理模式实现图片预加载</h1><blockquote><p>通过代理，在真正需要执行方法的时候再触发。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myImage = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> imgNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>(<span class="hljs-number">500</span>,<span class="hljs-number">500</span>);<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(imgNode);<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">setSrc</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">src</span>) &#123;<br>            imgNode.<span class="hljs-property">src</span> = src;<br>        &#125;<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>首先创建一个 Image 对象，把他的 setSrc 方法暴露出去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proxyImage = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br>    img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        myImage.<span class="hljs-title function_">setSrc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">src</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">setSrc</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">src</span>) &#123;<br>            myImage.<span class="hljs-title function_">setSrc</span>(<span class="hljs-string">&#x27;./loading.gif&#x27;</span>);<br>            img.<span class="hljs-property">src</span> = src;<br>        &#125;<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>接着在定义一个代理对象，该方法同时也拥有 setSrc 方法，只不过在这里代理了设置原对象的方法，在真正的图片加载完成之前，会用其他图片代替展示，避免出现页面空白的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">proxyImage.<span class="hljs-title function_">setSrc</span>(<span class="hljs-string">&#x27;https://www.bing.com/th?id=OHR.JohnDayFossil_EN-CN3221993722_tmb.jpg&#x27;</span>);<br></code></pre></td></tr></table></figure><p>最后我们通过代理对象来设置图片的 src ，代理对象相当于拦截了对于真正对象的操作，在图片加载完成后才执行真正的赋值。</p><h1 id="缓存代理：使用代理模式实做数据缓存"><a href="#缓存代理：使用代理模式实做数据缓存" class="headerlink" title="缓存代理：使用代理模式实做数据缓存"></a>缓存代理：使用代理模式实做数据缓存</h1><blockquote><p>缓存代理主要就是对于一些计算开销比较的大的时候，通过代理实现缓存，减少重复计算。</p></blockquote><p>先实现一个计算斐波那契数列的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">let</span> fib = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        fib[i] = fib[i - <span class="hljs-number">1</span>] + fib[i - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> fib[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>然后加入代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxyFibonacci = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> cache = &#123;&#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;<br>       <span class="hljs-keyword">if</span> (!cache[num]) &#123;<br>           cache[num] = <span class="hljs-title function_">fibonacci</span>(num);<br>       &#125;<br>       <span class="hljs-keyword">return</span> cache[num];<br>   &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure><p>在代理里面我们使用闭包，用 cache 来缓存计算值，这样计算过的值我们通过代理直接读取缓存即可，减少计算的过程，提高性能。这种方式在计算方法开销很大的情况下很有用。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式(二)：策略模式</title>
    <link href="/2023/10/10/design-strategy/"/>
    <url>/2023/10/10/design-strategy/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h1><blockquote><p><strong>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换</strong>。</p></blockquote><p>简单说就是对于不同的场景，我们才采取不同的方式来应对。举几个简单的小例子：</p><ol><li>我们要组装一台电脑，如果预算充足的话，那就可以什么都用顶配，如果预算不够，那就追求性价比，用最少的预算获得最高的性能，如果基本没有什么预算，那就只能楼下网吧对付一下了，对于不同的预算就需要不同的策略。</li><li>在网购过程中，我们买的东西越多，相应的满减金额越多，能用的红包金额越大，省的钱越多。对于不同的金额，需要不同的计算策略。</li><li>年底计算绩效，不同的评分队对应不同的等级，需要不同的计算策略。</li></ol><h1 id="传统的策略模式"><a href="#传统的策略模式" class="headerlink" title="传统的策略模式"></a>传统的策略模式</h1><p>传统的策略模式一般分成两个部分，一个是接受调用，然后委托给某个策略来完成相应的功能，另一个部分就是把一系列的算法封装成一个个策略类。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我们去某商场购物，如果拥有该商场的 vip 那么就能在总价的基础上进行打折，vip 分为 S 等级和 A 等级。</p><p>首先我们把不同的等级的计算策略封装起来，S 等级的 vip 可以打8折，A 等级的 vip 可以打九折。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">VipS</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-title class_">VipS</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">discount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">totalPrice</span>) &#123;<br>    <span class="hljs-keyword">return</span> totalPrice * <span class="hljs-number">0.8</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">VipA</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-title class_">VipA</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">discount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">totalPrice</span>) &#123;<br>    <span class="hljs-keyword">return</span> totalPrice * <span class="hljs-number">0.9</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再来写商品总价的类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">GoodsPrice</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-title class_">GoodsPrice</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setTotalPrice</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">totalPrice</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalPrice</span> = totalPrice;<br>&#125;<br><br><span class="hljs-title class_">GoodsPrice</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setCalculateMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">calculateMethod</span> = obj.<span class="hljs-property">discount</span>;<br>&#125;<br><br><span class="hljs-title class_">GoodsPrice</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getActualAmount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">calculateMethod</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateMethod</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">totalPrice</span>) : <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalPrice</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 setTotalPrice 方法来设置原价的金额，通过 setCalculateMethod 方法来设置我们要执行的策略，最后通过 getActualAmount 来计算出应付金额。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> goods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoodsPrice</span>();<br>goods.<span class="hljs-title function_">setTotalPrice</span>(<span class="hljs-number">1000</span>);<br>goods.<span class="hljs-title function_">setCalculateMethod</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VipS</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(goods.<span class="hljs-title function_">getActualAmount</span>())    <span class="hljs-comment">// 800</span><br></code></pre></td></tr></table></figure><p>由于我们的场景逻辑比较单一，所以使用策略模式反而看起来反而把问题搞复杂了，但如果在复杂的逻辑场景，例如我们在以上的场景下增加更多更细致的优惠方案策略，使用策略模式能让我们的代码逻辑更加清晰。</p><h1 id="Javascript-的策略模式"><a href="#Javascript-的策略模式" class="headerlink" title="Javascript 的策略模式"></a>Javascript 的策略模式</h1><p>在 Javascript 语言中，函数也是对象，我们可以把 n 个策略直接放到一个对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> strategies = &#123;<br>    <span class="hljs-string">&#x27;vipS&#x27;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">totalPrice</span>) &#123;<br>        <span class="hljs-keyword">return</span> totalPrice * <span class="hljs-number">0.8</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;vipA&#x27;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">totalPrice</span>) &#123;<br>        <span class="hljs-keyword">return</span> totalPrice * <span class="hljs-number">0.9</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> calculateActualAmount = <span class="hljs-keyword">function</span>(<span class="hljs-params"> level, price </span>)&#123;<br>    <span class="hljs-keyword">return</span> level ? strategies[ level ]( price ) : price;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">calculateActualAmount</span>( <span class="hljs-string">&#x27;vipS&#x27;</span>, <span class="hljs-number">1000</span> ) );<br></code></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>策略模式主要解决的就是很多相同的算法，我们一个个去使用 if…else… 去判断很麻烦，而且也不容易维护，代码可读性不高，所以我们把每个分支拆解成策略，避免使用多重判断。但还要注意的是如果策略过多的话，可能使用策略模式也并不那么合适，就需要考虑其他的设计模式来解决问题了。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式(一)：单例模式、工厂模式</title>
    <link href="/2023/09/13/design-mode/"/>
    <url>/2023/09/13/design-mode/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h1><ul><li>单一功能原则（Single Responsibility Principle）</li><li>开放封闭原则（Opened Closed Principle）</li><li>里式替换原则（Liskov Substitution Principle）</li><li>接口隔离原则（Interface Segregation Principle）</li><li>依赖反转原则（Dependency Inversion Principle）</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>使用单例模式保证了只存在一个实例，每次获取返回的都是这个实例</strong>，当我们对一个类通过 new 关键字生成多个对象，这些对象其实都是同一个，也就是第一次 new 创建的实例。</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">static</span> getInstance = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span>) &#123;<br>            <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>();<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这里的 s1 和 s2 都是通过 getInstance 方法创建的，getInstance 方法其实一直返回的都是 Singleton.instance 当初次调用 getInstance 方法时会创建一个 Singleton 实例赋值给 Singleton.instance 以后每次调用该方法返回的都是这个对象。</p><h2 id="方式二（闭包）"><a href="#方式二（闭包）" class="headerlink" title="方式二（闭包）"></a>方式二（闭包）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-title class_">Singleton</span>.<span class="hljs-property">getInstance</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!instance) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;)();<br><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>();<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)<br></code></pre></td></tr></table></figure><p>上面两种方法有一个共同的缺点，就是我们获取实例还需要去调用 getInstance 方法，这其实带来很多不便，而且也不够直观透明，下面我们通过使用代理类的方式来创建一个透明的单例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProxySingleton</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!instance)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;)()<br><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySingleton</span>();<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySingleton</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)<br></code></pre></td></tr></table></figure><p>使用代理类后，我们直接获取代理类的实例，而代理类返回的就是我们 Singleton 的实例，这里就是通过<strong>创建一个构造方法的实例时，如果该方法返回的是一个 object 则实例就是这个返回值</strong>的小tips来实现我们的这个功能。</p><p>可以看到无论是哪种方法，最重要的一点就是要有一个值来存实例，每次返回的都是这个实例，这样才能保证每次都是相同的值。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式就是把我们重复的操作交给<strong>工厂</strong>来帮我们完成，使用工厂函数就需要我们去考虑哪些东西是不变的，又有哪些是变化的，不变的东西是不是就可以抽离出来单独封装。</p><p>例如我们现在有一个做蛋糕的工厂，需要对每款蛋糕信息进行统计</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CakeA</span> (name, price) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">material</span> = [<span class="hljs-string">&#x27;黄油&#x27;</span>, <span class="hljs-string">&#x27;巧克力&#x27;</span>, <span class="hljs-string">&#x27;面粉&#x27;</span>]<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CakeB</span> (name, price) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">material</span> = [<span class="hljs-string">&#x27;黄油&#x27;</span>, <span class="hljs-string">&#x27;芒果&#x27;</span>, <span class="hljs-string">&#x27;奶油&#x27;</span>, <span class="hljs-string">&#x27;面粉&#x27;</span>]<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CakeFactory</span> (name, price, type) &#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CakeA</span>(name, price);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CakeB</span>(name, price);<br>        <span class="hljs-comment">//.....</span><br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-comment">//.....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码我们创建了两款蛋糕，再通过 CakeFactory 工厂来根据不同的类型创建不同的类型蛋糕。不过以上代码存在一个致命的问题，目前只有两款蛋糕还好说，如果有几十种岂不是要创建几十个蛋糕构造函数吗，对于不同类型的蛋糕来说，他们的”变”不就是材料的区别么，那我们把他们的名称，价格单独拿出来，只是根据类型去判断它的原材料不就可以了么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cake</span>(<span class="hljs-params">name, price, material</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">material</span> = material;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CakeFactory</span> (name, price, type) &#123;<br>    <span class="hljs-keyword">let</span> material;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span>:<br>            material = [<span class="hljs-string">&#x27;黄油&#x27;</span>, <span class="hljs-string">&#x27;巧克力&#x27;</span>, <span class="hljs-string">&#x27;面粉&#x27;</span>];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span>:<br>            material = [<span class="hljs-string">&#x27;黄油&#x27;</span>, <span class="hljs-string">&#x27;芒果&#x27;</span>, <span class="hljs-string">&#x27;奶油&#x27;</span>, <span class="hljs-string">&#x27;面粉&#x27;</span>];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//.....</span><br>        <span class="hljs-attr">default</span>:<br>        <span class="hljs-comment">//.....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>首先理解抽象的概念，在 Java 中可以通过 abstract 来定义一个抽象类，继承该类就必须要实现它内部的抽象方法。那我们在 Javascript 中如何模拟呢？</p><p>还是一个蛋糕工厂，我们制作蛋糕就需要面粉和黄油，而面粉和黄油又各自有自己的工厂，下面我们用代码来模拟实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 蛋糕工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CakeFactory</span> &#123;<br>    <span class="hljs-title function_">createButter</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You need to make it happen yourself&quot;</span>)<br>    &#125;<br>    <span class="hljs-title function_">createFlour</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You need to make it happen yourself&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过<strong>抛出错误来模拟抽象类</strong>的效果，蛋糕工厂必须要有黄油和面粉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlourFactory</span> &#123;<br>    <span class="hljs-title function_">getType</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You need to make it happen yourself&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeAFlourFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FlourFactory</span> &#123;<br>    <span class="hljs-title function_">getType</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A类型面粉&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ButterFactory</span> &#123;<br>    <span class="hljs-title function_">getType</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You need to make it happen yourself&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeAButterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ButterFactory</span> &#123;<br>    <span class="hljs-title function_">getType</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A类型黄油&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后面粉和黄油又各自有工厂并实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCakeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">CakeFactory</span> &#123;<br>    <span class="hljs-title function_">createButter</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeAButterFactory</span>();<br>    &#125;<br>    <span class="hljs-title function_">createFlour</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeAFlourFactory</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们制作蛋糕就使用到了面粉和黄油工厂的产物</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cake = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCakeFactory</span>();<br><span class="hljs-keyword">const</span> cakeFlour = cake.<span class="hljs-title function_">createFlour</span>();<br><span class="hljs-keyword">const</span> cakeButter = cake.<span class="hljs-title function_">createButter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`这个蛋糕由<span class="hljs-subst">$&#123;cakeFlour.getType()&#125;</span>和<span class="hljs-subst">$&#123;cakeButter.getType()&#125;</span>做成的`</span>) <span class="hljs-comment">// 这个蛋糕由A类型面粉和A类型面粉做成的</span><br></code></pre></td></tr></table></figure><p>最后完成制作蛋糕的过程。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React事件系统</title>
    <link href="/2023/08/19/react-event/"/>
    <url>/2023/08/19/react-event/</url>
    
    <content type="html"><![CDATA[<h1 id="React-独特的事件系统"><a href="#React-独特的事件系统" class="headerlink" title="React 独特的事件系统"></a>React 独特的事件系统</h1><p>首先要明确的是，React为了兼容全部的浏览器，模拟实现了一套自己的事件系统，也就是我们现在看到的事件都是被React处理过后的，给元素的事件也并不是真正的事件处理函数，所以原生事件中像 return false 阻止默认行为这种方式在 React 中是不生效的。</p><p>在 v17 之前，React事件绑定在 document 上，之后绑定在应用对应容器 container 上，可以理解为事件委托，当然也不是所有事件都会进行事件委托，例如 scroll 等还是直接绑定在DOM上的。并且 React 将事件源 event 进行了重写，所以我们拿到的不是真正的事件源。</p><h1 id="事件合成"><a href="#事件合成" class="headerlink" title="事件合成"></a>事件合成</h1><p>上面提到我们写的事件都绑定在了 document 或 container 上,并且一个事件可能由多个原生事件组成,<br>registrationNameDependencies 对象保存了每个事件是由哪写原生事件组成的,例如我们绑定一个 onChange,React 会绑定 blur change click … 方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-attr">onBlur</span>: [<span class="hljs-string">&#x27;blur&#x27;</span>],<br>    <span class="hljs-attr">onClick</span>: [<span class="hljs-string">&#x27;click&#x27;</span>],<br>    <span class="hljs-attr">onClickCapture</span>: [<span class="hljs-string">&#x27;click&#x27;</span>],<br>    <span class="hljs-attr">onChange</span>: [<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;focus&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;selectionchange&#x27;</span>],<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事件插件"><a href="#事件插件" class="headerlink" title="事件插件"></a>事件插件</h1><p>registrationNameModules 对象保存了每个事件和处理该事件插件的映射,当触发某个事件就会通过这个对象找到对应的插件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> registrationNameModules = &#123;<br>    <span class="hljs-attr">onBlur</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,<br>    <span class="hljs-attr">onClick</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,<br>    <span class="hljs-attr">onClickCapture</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><blockquote><p>老版本事件系统：事件监听(addEventListener) -&gt; 捕获阶段执行 -&gt; 冒泡阶段执行<br>新版本事件系统：捕获阶段执行 -&gt; 事件监听 -&gt; 冒泡阶段执行</p></blockquote><p>老版本的事件系统模拟的冒泡和捕获阶段，其实都是在浏览器的冒泡阶段执行的，新版本的事件系统在创建 fiberRoot 时通过 listenToAllSupportedEvents 方法将全部事件注册完成事件代理，分别绑定了捕获和冒泡事件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// listenToAllSupportedEvents 是事件绑定的开始</span><br><span class="hljs-comment">// rootContainerElement 为根节点</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">listenToAllSupportedEvents</span>(<span class="hljs-params">rootContainerElement: EventTarget</span>) &#123;<br>    <span class="hljs-keyword">if</span> (enableEagerRootListeners) &#123;<br>        <span class="hljs-comment">// 优化处理，防止多次触发</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>)[listeningMarker]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        (<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>)[listeningMarker] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// allNativeEvents 保存了大多数的浏览器事件（set集合，v18 保存了81个事件）</span><br>        allNativeEvents.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">domEventName</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// nonDelegatedEvents 保存了不冒泡的事件</span><br>            <span class="hljs-keyword">if</span> (!nonDelegatedEvents.<span class="hljs-title function_">has</span>(domEventName)) &#123;<br>                <span class="hljs-comment">// 冒泡阶段绑定事件</span><br>                <span class="hljs-title function_">listenToNativeEvent</span>(domEventName, <span class="hljs-literal">false</span>, ((<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">Element</span>), <span class="hljs-literal">null</span>,);<br>            &#125;<br>            <span class="hljs-comment">// 捕获阶段绑定事件</span><br>            <span class="hljs-title function_">listenToNativeEvent</span>(domEventName, <span class="hljs-literal">true</span>, ((<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">Element</span>), <span class="hljs-literal">null</span>,);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 listenToNativeEvent 方法调用到最后就是通过 addEventCaptureListener 和 addEventBubbleListener 来注册冒泡&#x2F;捕获的事件，本质都是原生的 addEventListener。</p><p>另外我们定义的事件函数最后都会保存在都会保存在 DOM 对应 fiber 的 memoizedProps 上</p><p><img src="/img/react-memoizedProps.png" alt="memoizedProps.png"></p><h1 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h1><p>绑定事件后，只要触发就会首先执行 React 的统一的事件处理函数 dispatchEvent，该方法调用会依次执行 dispatchEventForPluginEventSystem -&gt; batchedUpdates -&gt; dispatchEventsForPlugins</p><h2 id="dispatchEventsForPlugins-触发"><a href="#dispatchEventsForPlugins-触发" class="headerlink" title="dispatchEventsForPlugins 触发"></a>dispatchEventsForPlugins 触发</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 参数（事件名，冒泡阶段/捕获阶段，事件源，fiber，根节点）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventsForPlugins</span>(<span class="hljs-params">domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer</span>) &#123;<br>    <span class="hljs-comment">// 找到发生事件的元素的事件源</span><br>    <span class="hljs-keyword">var</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);<br>    <span class="hljs-comment">// 事件队列</span><br>    <span class="hljs-keyword">var</span> dispatchQueue = [];<br>    <span class="hljs-comment">// 收集事件</span><br>    <span class="hljs-title function_">extractEvents</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);<br>    <span class="hljs-comment">// 执行事件</span><br>    <span class="hljs-title function_">processDispatchQueue</span>(dispatchQueue, eventSystemFlags);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="extractEvents-收集"><a href="#extractEvents-收集" class="headerlink" title="extractEvents 收集"></a>extractEvents 收集</h2><p>其中 extractEvents 会根据不同的事件使用不同的插件生成对应的事件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents</span>(<span class="hljs-params"></span><br><span class="hljs-params">    dispatchQueue: DispatchQueue,</span><br><span class="hljs-params">    domEventName: DOMEventName,</span><br><span class="hljs-params">    targetInst: <span class="hljs-literal">null</span> | Fiber,</span><br><span class="hljs-params">    nativeEvent: AnyNativeEvent,</span><br><span class="hljs-params">    nativeEventTarget: <span class="hljs-literal">null</span> | EventTarget,</span><br><span class="hljs-params">    eventSystemFlags: EventSystemFlags,</span><br><span class="hljs-params">    targetContainer: EventTarget,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-comment">//  合成事件名</span><br>    <span class="hljs-keyword">const</span> reactName = topLevelEventsToReactNames.<span class="hljs-title function_">get</span>(domEventName);<br>    <span class="hljs-keyword">if</span> (reactName === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 合成函数的构造函数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticEvent</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">reactEventType</span>: <span class="hljs-built_in">string</span> = domEventName;<br><br>    <span class="hljs-keyword">const</span> inCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> accumulateTargetOnly = !inCapturePhase &amp;&amp; domEventName === <span class="hljs-string">&#x27;scroll&#x27;</span>;<br>    <span class="hljs-comment">// 收集当前阶段的所有事件.</span><br>    <span class="hljs-keyword">const</span> listeners = <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(<br>        targetInst,<br>        reactName,<br>        nativeEvent.<span class="hljs-property">type</span>,<br>        inCapturePhase,<br>        accumulateTargetOnly,<br>    );<br>    <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 构造合成事件插入队列</span><br>        <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEventCtor</span>(<br>            reactName,<br>            reactEventType,<br>            <span class="hljs-literal">null</span>,<br>            nativeEvent,<br>            nativeEventTarget,<br>        );<br>        dispatchQueue.<span class="hljs-title function_">push</span>(&#123;event, listeners&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="accumulateSinglePhaseListeners"><a href="#accumulateSinglePhaseListeners" class="headerlink" title="accumulateSinglePhaseListeners"></a>accumulateSinglePhaseListeners</h2><p>accumulateSinglePhaseListeners 找到 fiber 的 props 对应的事件加入到监听集合，然后进行递归知直到根节点，如果事件不冒泡就停止。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(<span class="hljs-params"></span><br><span class="hljs-params">  targetFiber: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  reactName: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  nativeEventType: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  inCapturePhase: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  accumulateTargetOnly: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">DispatchListener</span>&gt; &#123;<br>  <span class="hljs-keyword">const</span> captureName = reactName !== <span class="hljs-literal">null</span> ? reactName + <span class="hljs-string">&#x27;Capture&#x27;</span> : <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> reactEventName = inCapturePhase ? captureName : reactName;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">listeners</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">DispatchListener</span>&gt; = [];<br><br>  <span class="hljs-keyword">let</span> instance = targetFiber;<br>  <span class="hljs-keyword">let</span> lastHostComponent = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 从targetFiber开始, 向上遍历, 直到 root 为止·</span><br>  <span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; stateNode, tag &#125; = instance;<br>    <span class="hljs-comment">// 当节点类型是HostComponent时(如: div, span, button等类型)</span><br>    <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="hljs-literal">null</span>) &#123;<br>      lastHostComponent = stateNode;<br>      <span class="hljs-keyword">if</span> (reactEventName !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 获取标准的监听函数 (如onClick , onClickCapture等)</span><br>        <span class="hljs-keyword">const</span> listener = <span class="hljs-title function_">getListener</span>(instance, reactEventName);<br>        <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">null</span>) &#123;<br>          listeners.<span class="hljs-title function_">push</span>(<br>            <span class="hljs-title function_">createDispatchListener</span>(instance, listener, lastHostComponent),<br>          );<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果只收集目标节点, 则不用向上遍历, 直接退出</span><br>    <span class="hljs-keyword">if</span> (accumulateTargetOnly) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    instance = instance.<span class="hljs-property">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> listeners;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="processDispatchQueue-执行"><a href="#processDispatchQueue-执行" class="headerlink" title="processDispatchQueue 执行"></a>processDispatchQueue 执行</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueue</span>(<span class="hljs-params"></span><br><span class="hljs-params">  dispatchQueue: DispatchQueue,</span><br><span class="hljs-params">  eventSystemFlags: EventSystemFlags,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-comment">//   是否是捕获阶段</span><br>  <span class="hljs-keyword">const</span> inCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dispatchQueue.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> &#123; event, listeners &#125; = dispatchQueue[i];<br>    <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(event, listeners, inCapturePhase);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(<span class="hljs-params"></span><br><span class="hljs-params">  event: ReactSyntheticEvent,</span><br><span class="hljs-params">  dispatchListeners: <span class="hljs-built_in">Array</span>&lt;DispatchListener&gt;,</span><br><span class="hljs-params">  inCapturePhase: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">let</span> previousInstance;<br>  <span class="hljs-keyword">if</span> (inCapturePhase) &#123;<br>    <span class="hljs-comment">// 捕获事件倒序遍历listeners</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = dispatchListeners.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];<br>      <span class="hljs-keyword">if</span> (instance !== previousInstance &amp;&amp; event.<span class="hljs-title function_">isPropagationStopped</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">executeDispatch</span>(event, listener, currentTarget);<br>      previousInstance = instance;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 冒泡事件顺序遍历listeners</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dispatchListeners.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];<br>      <span class="hljs-keyword">if</span> (instance !== previousInstance &amp;&amp; event.<span class="hljs-title function_">isPropagationStopped</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">executeDispatch</span>(event, listener, currentTarget);<br>      previousInstance = instance;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断是捕获阶段，然后遍历事件列表执行 processDispatchQueueItemsInOrder 如果是捕获事件，倒序执行，冒泡事件正序执行。</p><h1 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h1><p>v16: document 捕获 &#x3D;&gt; 原生捕获 &#x3D;&gt; 原生冒泡 &#x3D;&gt; 合成事件（react）捕获 &#x3D;&gt; 合成事件（react）冒泡 &#x3D;&gt; document 元素冒泡</p><p>v17&#x2F;v18: document 捕获 &#x3D;&gt; 合成事件（react）捕获 &#x3D;&gt; 原生捕获 &#x3D;&gt; 原生冒泡 &#x3D;&gt; 合成事件（react）冒泡 &#x3D;&gt; document 元素冒泡</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite-进阶篇</title>
    <link href="/2023/08/17/vite-05/"/>
    <url>/2023/08/17/vite-05/</url>
    
    <content type="html"><![CDATA[<h1 id="Module-Federation"><a href="#Module-Federation" class="headerlink" title="Module Federation"></a>Module Federation</h1><p>简单说就是提出一个模块作为“远程模块”，”本地模块“可以导入这个模块使用，同时”本地模块“也可以作为其他模块的”远程模块“</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>只是作为引用， 不会参与本地模块打包，减小产物体积</li><li>可以做到按需加载</li><li>每个模块单独存在，可以单独进行开发、测试等</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>首先说一下大概的流程：</p><ol><li>新建 remote host 项目（官方是同vue，我们也是用vue）</li><li>remote 作为远程模块，我们通过打包，预览打包后的产物来模拟上线</li><li>host 作为本地模块，引入远程模块使用</li></ol><h3 id="使用-vite-plugin-federation-插件"><a href="#使用-vite-plugin-federation-插件" class="headerlink" title="使用 vite-plugin-federation 插件"></a>使用 vite-plugin-federation 插件</h3><p>remote 和 host 分别安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm install @originjs/vite-plugin-federation -D<br></code></pre></td></tr></table></figure><h3 id="处理-remote"><a href="#处理-remote" class="headerlink" title="处理 remote"></a>处理 remote</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-title function_">vue</span>(),<br>        <span class="hljs-title function_">federation</span>(&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;remote-app&#x27;</span>,<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;remoteEntry.js&#x27;</span>,<br>            <span class="hljs-comment">// 需要暴露的模块</span><br>            <span class="hljs-attr">exposes</span>: &#123;<br>                <span class="hljs-string">&#x27;./App&#x27;</span>: <span class="hljs-string">&#x27;./src/App.vue&#x27;</span>,<br>            &#125;,<br>            <span class="hljs-attr">shared</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>]<br>        &#125;)<br>    ],<br>    <span class="hljs-attr">build</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;esnext&quot;</span>,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>执行打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm run build<br></code></pre></td></tr></table></figure><p>预览,执行前先将 package.json 的 preview 设置为 “vite preview –port&#x3D;3030 –strictPort”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm run preview<br></code></pre></td></tr></table></figure><h3 id="处理-host"><a href="#处理-host" class="headerlink" title="处理 host"></a>处理 host</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-title function_">vue</span>(),<br>        <span class="hljs-title function_">federation</span>(&#123;<br>            <span class="hljs-comment">// 远程模块声明</span><br>            <span class="hljs-attr">remotes</span>: &#123;<br>                <span class="hljs-attr">remote_app</span>: <span class="hljs-string">&quot;http://localhost:3030/assets/remoteEntry.js&quot;</span>,<br>            &#125;,<br>            <span class="hljs-comment">// 共享依赖声明</span><br>            <span class="hljs-attr">shared</span>: [<span class="hljs-string">&quot;vue&quot;</span>],<br>        &#125;),<br>    ],<br>    <span class="hljs-attr">build</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;esnext&quot;</span>,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用远程模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import RemoteApp from &quot;remote_app/App&quot;;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h1&gt;Host App&lt;/h1&gt;<br>    &lt;RemoteApp /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>启动后效果<br><a href="https://imgse.com/i/piEAYAe"><img src="https://z1.ax1x.com/2023/10/24/piEAYAe.png" alt="piEAYAe.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite-架构篇（Rollup）</title>
    <link href="/2023/08/12/vite-04/"/>
    <url>/2023/08/12/vite-04/</url>
    
    <content type="html"><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化项目</span><br>pnpm init -y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 rollup</span><br>pnpm install rollup<br></code></pre></td></tr></table></figure><p>根目录下新建 rollup 的配置文件 rollup.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;src/main.js&#x27;</span>,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">file</span>: <span class="hljs-string">&#x27;dist/bundle.js&#x27;</span>,<br>        <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;cjs&#x27;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>新建 src&#x2F;main.js src&#x2F;util.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  main.js</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./util&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><span class="hljs-comment">//  util.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">multi</span> = (<span class="hljs-params">a, b</span>) =&gt; a * b;<br></code></pre></td></tr></table></figure><p>package.json 增加 build (部分代码省略)，这里如果是 windows 环境，建议先安装 rimraf，将 rm -rf 替换成 rimraf ，我们在 build 时需要先将 dist 目录删掉重新生成</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm -rf dist &amp;&amp; rollup -c&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>安装 rimraf 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm install rimraf --save-dev<br></code></pre></td></tr></table></figure><p>现在执行 pnpm run build 就能看到在 dist 目录下生成 bundle.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>打包后的文件可以看到代码已经放到一起了，并且我们在 util 中声明的方法 multi 并没又出现在打包后的文件中，因为 rollup 自带 Tree-Shaking 功能。<br>Tree-Shaking 也可以翻译为”摇树“，把一些不需要的东西抖落下来，本质就是在打包时，将一些没有用到的代码（也称 Dead Code）消除掉。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>详细文档：<a href="https://www.rollupjs.com/guide/big-list-of-options">选项大列表</a></p><h2 id="多产物配置"><a href="#多产物配置" class="headerlink" title="多产物配置"></a>多产物配置</h2><p>通过 format 指定不同的输出格式，可以同时打包出不同格式的产物，这里的 format 支持 amd、cjs、es、iife、umd、system</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;src/main.js&#x27;</span>, <span class="hljs-string">&#x27;src/util.js&#x27;</span>],<br>    <span class="hljs-attr">output</span>: [<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/es&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;es&quot;</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/amd&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;amd&quot;</span>,<br>        &#125;,<br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="多入口配置-input"><a href="#多入口配置-input" class="headerlink" title="多入口配置 input"></a>多入口配置 input</h2><blockquote><p>类型：string | string [] | { [entryName: string]: string }</p></blockquote><p>如果有多个入口就需要用 数组&#x2F;对象 的形式来定义了，需要注意的是，使用多入口时，产物需要定义 dir 指定输出目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;src/main.js&#x27;</span>, <span class="hljs-string">&#x27;src/util.js&#x27;</span>],<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/es&quot;</span>,<br>        <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;es&quot;</span>,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果想要定制每个入口的配置，可以通过导出数组的方式，来定义多个配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mainBuild = &#123;<br>    <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;src/main.js&#x27;</span>, <span class="hljs-string">&#x27;src/util.js&#x27;</span>],<br>    <span class="hljs-attr">output</span>: [<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>        &#125;,<br>    ]<br>&#125;<br><br><span class="hljs-keyword">const</span> utilBuild = &#123;<br>    <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;src/util.js&#x27;</span>],<br>    <span class="hljs-attr">output</span>: [<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/amd&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;amd&quot;</span>,<br>        &#125;,<br>    ]<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [mainBuild, utilBuild];<br></code></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件有两种定义方式，第一种定义在 output 中，定义在这里的插件需要使用了 Output 阶段的钩子，第二种就是定义在 output 同级。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mainBuild = &#123;<br>    <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;src/main.js&#x27;</span>, <span class="hljs-string">&#x27;src/util.js&#x27;</span>],<br>    <span class="hljs-attr">output</span>: [<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>            <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">terser</span>()]<br>        &#125;,<br>    ],<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">resolve</span>(), <span class="hljs-title function_">commonjs</span>()]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过引入插件的方式来解决一些问题，例如使用到第三方依赖使用的是 CommonJs 格式的产物，rollup 有把 ESM 打包成 CommonJs 的能力，但他却不能反向处理，这时候就需要引入插件来处理了。</p><h1 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h1><p>当我们需要扩展 Rollup 本身，或者自己定制打包过程，需要使用 JavaScript API , rollup 提供了两个 API rollup.rollup 和 rollup.watch</p><h2 id="rollup-rollup"><a href="#rollup-rollup" class="headerlink" title="rollup.rollup"></a>rollup.rollup</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rollup = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;rollup&#x27;</span>);<br><span class="hljs-comment">// 输出配置项</span><br><span class="hljs-keyword">const</span> outputOptions = [<br>    &#123;<br>        <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs&quot;</span>,<br>        <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>        <span class="hljs-comment">// 省略更多配置。。。</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;,<br>]<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> bundle = <span class="hljs-keyword">await</span> rollup.<span class="hljs-title function_">rollup</span>(&#123;<br>        <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<span class="hljs-string">&#x27;./src/util.js&#x27;</span>],<br>    &#125;);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> output <span class="hljs-keyword">of</span> outputOptions) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> bundle.<span class="hljs-title function_">generate</span>(output);<br>            <span class="hljs-keyword">await</span> bundle.<span class="hljs-title function_">write</span>(output);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>        <span class="hljs-comment">// 忽略错误处理</span><br>    &#125;<br>    <span class="hljs-keyword">await</span> bundle.<span class="hljs-title function_">close</span>();<br>&#125;<br><span class="hljs-title function_">build</span>();<br></code></pre></td></tr></table></figure><p>首先通过 rollup.rollup 存储各个模块之前的内容依赖关系，完成模块图构建和 tree-shaking，返回一个 bundle 对象<br>然后遍历输出配置项，分别执行 bundle.generate 输出产物<br>最后通过 bundle.write 把产物写进磁盘</p><h2 id="rollup-watch"><a href="#rollup-watch" class="headerlink" title="rollup.watch"></a>rollup.watch</h2><p>当检测到磁盘单个模块发生变化，进行重构 bundle，我们来新建一个 watcher.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// watcher.js</span><br><span class="hljs-keyword">const</span> rollup = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;rollup&#x27;</span>);<br><span class="hljs-comment">// watch 的配置项</span><br><span class="hljs-keyword">const</span> watchOptions = &#123;<br>    <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<span class="hljs-string">&#x27;./src/util.js&#x27;</span>],<br>    <span class="hljs-attr">output</span>: [<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/amd&quot;</span>,<br>            <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;amd&quot;</span>,<br>        &#125;,<br>    ],<br>    <span class="hljs-attr">watch</span>: &#123;<br>        <span class="hljs-attr">exclude</span>: [<span class="hljs-string">&quot;node_modules/**&quot;</span>],<br>        <span class="hljs-attr">include</span>: [<span class="hljs-string">&quot;src/**&quot;</span>],<br>    &#125;,<br>&#125;;<br><span class="hljs-keyword">const</span> watcher = rollup.<span class="hljs-title function_">watch</span>(watchOptions);<br><br>watcher.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`watch 到了 <span class="hljs-subst">$&#123;event.code&#125;</span>`</span>)<br>&#125;);<br><br><span class="hljs-comment">// 停止监听</span><br><span class="hljs-comment">// watcher.close();</span><br></code></pre></td></tr></table></figure><p>watch 的配置项和我们写的输入输出配置项相同，只是多了一个 watch 项<br>通过 rollup.watch 返回监听对象，通过 watcher.on 进行监听。</p><blockquote><p>event.code:<br>    START        — 监听器正在启动（重启）<br>    BUNDLE_START — 构建单个 bundle<br>    BUNDLE_END   — 完成 bundle 构建<br>    END          — 完成所有bundle构建<br>    ERROR        — 构建时遇到错误</p></blockquote><h1 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h1><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>在前文的 JavaScript API 的 rollup.rollup 自定义构建中，能大概看出 rollup 经历了 <strong>Input &#x3D;&gt; Build &#x3D;&gt; Output</strong>，另外在真正的打包是在 Output 阶段，也就是执行 generate &#x2F; write 的时候</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>Build Hook：在build阶段执行的 hook，主要进行了代码转换，AST解析，模块依赖解析<br>Output Generation Hook：进行代码打包</p><h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><ol><li>Async：异步钩子函数</li><li>Sync：同步钩子函数</li><li>Parallel：并行钩子函数，底层使用 Promise.all 实现，处理没有依赖关系的插件</li><li>Sequential：串行钩子函数，处理有依赖关系的插件</li><li>First：当多个插件实现了这个 Hook ，会依次执行，直到返回值不为 null&#x2F;undefined</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite-优化篇</title>
    <link href="/2023/08/07/vite-02/"/>
    <url>/2023/08/07/vite-02/</url>
    
    <content type="html"><![CDATA[<h1 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h1><h2 id="单-chunk-打包存在的问题"><a href="#单-chunk-打包存在的问题" class="headerlink" title="单 chunk 打包存在的问题"></a>单 chunk 打包存在的问题</h2><p>Vite 默认会将 js 打包到一个 index.js 文件中，即单 chunk 打包。<br><img src="/img/vite-build1.png" alt="单chunk打包.png"><br>这样其实会导致一些问题</p><ol><li>包体积会很大，当前没使用的包也被打包进去了，没办法做到按需加载。</li><li>缓存复用率很低，单 chunk 打包基本上不会命中缓存，因为只要改动就重新打包，打包后的 url 改变，浏览器会当作新的资源去请求。</li></ol><h2 id="自定义拆包"><a href="#自定义拆包" class="headerlink" title="自定义拆包"></a>自定义拆包</h2><h3 id="配置-manualChunks"><a href="#配置-manualChunks" class="headerlink" title="配置 manualChunks"></a>配置 manualChunks</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">build</span>: &#123;<br>        <span class="hljs-attr">rollupOptions</span>: &#123;<br>            <span class="hljs-attr">output</span>: &#123;<br>                <span class="hljs-attr">manualChunks</span>: &#123;<br>                    <span class="hljs-comment">// React 相关库打包</span><br>                    <span class="hljs-string">&quot;react-vendor&quot;</span>: [<span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;react-dom&quot;</span>],<br>                    <span class="hljs-comment">// Lodash 库打包</span><br>                    <span class="hljs-string">&quot;lodash&quot;</span>: [<span class="hljs-string">&quot;lodash-es&quot;</span>],<br>                    <span class="hljs-comment">// 组件库打包</span><br>                    <span class="hljs-string">&quot;library&quot;</span>: [<span class="hljs-string">&quot;antd&quot;</span>],<br>                    <span class="hljs-comment">// Moment 库打包</span><br>                    <span class="hljs-string">&quot;moment&quot;</span>: [<span class="hljs-string">&quot;moment&quot;</span>]<br>                &#125;,<br>            &#125;,<br>        &#125;<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>对 manualChunks 进行配置，key 代表 chunk 的名称， value 是第三方包的包名的数组。</p><p><img src="/img/vite-build2.png" alt="自定义拆包.png"></p><p>可以清楚看到原来的一个大的 chunk 被拆分成多个 chunk ，当更新时，也只更新其中一个 chunk ，其他的 chunk 则会读取缓存，提高了缓存命中率。</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>首先安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm i vite-plugin-chunk-split -D<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; chunkSplitPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite-plugin-chunk-split&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-title function_">chunkSplitPlugin</span>(&#123;<br>            <span class="hljs-comment">// 指定拆包策略</span><br>            <span class="hljs-attr">customSplitting</span>: &#123;<br>                <span class="hljs-comment">// 1. 支持填包名。</span><br>                <span class="hljs-string">&quot;react-vendor&quot;</span>: [<span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;react-dom&quot;</span>],<br>                <span class="hljs-comment">// 2. 支持填正则表达式。src 中 components 和 utils 下的所有文件被会被打包为`component-util`</span><br>                <span class="hljs-string">&quot;components-util&quot;</span>: [<span class="hljs-regexp">/src\/components/</span>, <span class="hljs-regexp">/src\/utils/</span>],<br>                <span class="hljs-string">&quot;lodash&quot;</span>: [<span class="hljs-string">&quot;lodash-es&quot;</span>],<br>                <span class="hljs-string">&quot;library&quot;</span>: [<span class="hljs-string">&quot;antd&quot;</span>],<br>                <span class="hljs-string">&quot;moment&quot;</span>: [<span class="hljs-string">&quot;moment&quot;</span>]<br>            &#125;<br>        &#125;),<br>        <span class="hljs-comment">// ...</span><br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="语法降级-和-Polyfill"><a href="#语法降级-和-Polyfill" class="headerlink" title="语法降级 和 Polyfill"></a>语法降级 和 Polyfill</h1><p>简单来说就是低版本的浏览器对一些JS代码无法识别，需要对JS语法进行降级，详细定义：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Polyfill">Polyfill</a></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>安装官方插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm i @vitejs/plugin-legacy -D<br></code></pre></td></tr></table></figure><p>使用插件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-title function_">chunkSplitPlugin</span>(&#123;<br>            <span class="hljs-comment">// 指定拆包策略</span><br>            <span class="hljs-attr">customSplitting</span>: &#123;<br>                <span class="hljs-comment">// 1. 支持填包名。`react` 和 `react-dom` 会被打包到一个名为`render-vendor`的 chunk 里面(包括</span><br>                <span class="hljs-string">&quot;react-vendor&quot;</span>: [<span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;react-dom&quot;</span>],<br>                <span class="hljs-comment">// 2. 支持填正则表达式。src 中 components 和 utils 下的所有文件被会被打包为`component-util`</span><br>                <span class="hljs-string">&quot;components-util&quot;</span>: [<span class="hljs-regexp">/src\/components/</span>, <span class="hljs-regexp">/src\/utils/</span>],<br>                <span class="hljs-string">&quot;lodash&quot;</span>: [<span class="hljs-string">&quot;lodash-es&quot;</span>],<br>                <span class="hljs-string">&quot;library&quot;</span>: [<span class="hljs-string">&quot;antd&quot;</span>],<br>                <span class="hljs-string">&quot;moment&quot;</span>: [<span class="hljs-string">&quot;moment&quot;</span>]<br>            &#125;<br>        &#125;),<br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>执行打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm run build<br></code></pre></td></tr></table></figure><p>在 dist 目录下的 index.html 可以看到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当使用现代浏览器时加载 type&#x3D;”module” 的 script，当使用低版本的浏览器加载 nomodule 的 script，这样就能够对低版本浏览器进行兼容了。</p><h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><h2 id="使用-HTTP2"><a href="#使用-HTTP2" class="headerlink" title="使用 HTTP2"></a>使用 HTTP2</h2><p>插件 vite-plugin-mkcert</p><ol><li>安装 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm i vite-plugin-mkcert -D<br></code></pre></td></tr></table></figure></li><li>配置<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>   <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>(), <span class="hljs-title function_">mkcert</span>()],<br>   <span class="hljs-attr">server</span>: &#123;<br>     <span class="hljs-attr">https</span>: <span class="hljs-literal">true</span>,<br>   &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h2 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h2><h1 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h1><p>使用 rollup-plugin-visualizer 对打包的产物进行分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm i  rollup-plugin-visualizer -D<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>   <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-title function_">visualizer</span>(&#123;<br>         <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>      &#125;),<br>   ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>执行打包后会自动带开浏览器</p><h1 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h1><p>如果项目存在图片的静态文件，在打包时一定会增加包的大小，一般情况下我们需要在打包时对图片进行压缩处理</p><p>一个 Vite 插件 vite-plugin-imagemin 可以帮我们来做这件事</p><p>安装</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pnpm <span class="hljs-selector-tag">i</span> vite-plugin-imagemin -D<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-title function_">viteImagemin</span>(&#123;<br>            <span class="hljs-comment">// 无损压缩配置</span><br>            <span class="hljs-attr">optipng</span>: &#123;<br>                <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span><br>            &#125;,<br>            <span class="hljs-comment">// 有损压缩配置</span><br>            <span class="hljs-attr">pngquant</span>: &#123;<br>                <span class="hljs-attr">quality</span>: [<span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>],<br>            &#125;,<br>            <span class="hljs-comment">// svg 优化</span><br>            <span class="hljs-attr">svgo</span>: &#123;<br>                <span class="hljs-attr">plugins</span>: [<br>                    &#123;<br>                        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;removeViewBox&quot;</span><br>                    &#125;,<br>                    &#123;<br>                        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;removeEmptyAttrs&quot;</span>,<br>                        <span class="hljs-attr">active</span>: <span class="hljs-literal">false</span><br>                    &#125;<br>                ]<br>            &#125;<br>        &#125;)<br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后执行 build</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pmpm <span class="hljs-built_in">run</span> build<br></code></pre></td></tr></table></figure><p><img src="/img/vite-console.png" alt="控制台信息.png"></p><p>控制台可以看到我们的配置生效了</p><h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1><p>gzip 可以对我们的代码体积进行压缩，提高性能</p><ol><li><p>安装插件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pnpm <span class="hljs-selector-tag">i</span> vite-plugin-compression -D<br></code></pre></td></tr></table></figure></li><li><p>配置</p></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> viteCompression <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite-plugin-compression&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br><span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br><span class="hljs-title function_">viteCompression</span>()<br>],<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="/img/vite-gzip.png" alt="控制台信息.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite-快速入门</title>
    <link href="/2023/08/04/vite-01/"/>
    <url>/2023/08/04/vite-01/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite-的特性"><a href="#Vite-的特性" class="headerlink" title="Vite 的特性"></a>Vite 的特性</h1><p>直接放官网上的</p><p><img src="/img/vite-idea.png" alt="vite特性.png">、</p><h1 id="Vite-为什么快"><a href="#Vite-为什么快" class="headerlink" title="Vite 为什么快"></a>Vite 为什么快</h1><p>首先要说明的是，Vite 是在开发环境下比较快，原因：</p><ol><li>浏览器支持 ESM，Vite 在开发阶段采用 esbuild 依赖预构建，实现了按需加载，而不用整体对项目进行打包。</li><li>esbuild 采用 Go 语言开发，Go 是编译型语言，代码直接被编译为原生机器码，不需要像 JavaScript 还要解析成字节码再转成机器码。</li></ol><h1 id="依赖预构建"><a href="#依赖预构建" class="headerlink" title="依赖预构建"></a>依赖预构建</h1><p>Vite 在执行前会先进行预构建，首先找到依赖模块，将其转换成 ESM 规范，最后生成的预构建产物放在 node_modules 下的 .vite文件夹，在构建时会将第三方库的多个文件打包成一个文件 如引入 lodash 打包时，会将 lodash 包内的文件打包成一个文件。另外打包后会将第三方库的引用路径进行重写，使用我们预构建后的路径。对于依赖请求结果会进行强缓存，再次请求直接读取缓存。</p><h2 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h2><p>Vite 对于已构建的的依赖进行了 <strong>文件系统缓存</strong>（存储在 node_modules&#x2F;.vite 中） 和 <strong>浏览器缓存</strong>（使用 HTTP 头 max-age&#x3D;31536000, immutable 进行强缓存），当缓存后，再次请求直接读取缓存来提高性能。</p><h2 id="手动开启预构建"><a href="#手动开启预构建" class="headerlink" title="手动开启预构建"></a>手动开启预构建</h2><p>默认情况下，Vite 会自动帮我们开启预构建，如果不希望使用本地缓存，还可以手动清除缓存，然后手动进行预构建</p><ol><li>删除 node_modules&#x2F;.vite</li><li>配置 vite.config.ts <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">optimizeDeps</span>: &#123;<br>        <span class="hljs-comment">// 设置为 true 可以强制依赖预构建，而忽略之前已经缓存过的、已经优化过的依赖</span><br>        <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure></li><li>行执行 npx vite –force 或者 npx vite optimize</li></ol><h2 id="optimizeDeps"><a href="#optimizeDeps" class="headerlink" title="optimizeDeps"></a>optimizeDeps</h2><p>详细文档： <a href="https://cn.vitejs.dev/config/dep-optimization-options.html#optimizedeps-force">依赖优化选项</a></p><h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h3><p>用来定义预构建的入口文件，支持多种类型文件</p><h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p>在预构建中强制排除的依赖项。</p><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>定义预构建的依赖项，使用场景在于一般情况不对 node_modules 外的包进行预构建的，这可能会导致在运行时发现新的依赖（例如使用动态import）这时<br>Vite 会二次预构建并且刷新页面，很耗费性能，所以通过 include 手动去定义。</p><h3 id="esbuildOptions"><a href="#esbuildOptions" class="headerlink" title="esbuildOptions"></a>esbuildOptions</h3><p>自定义 esbuild 配置，一般用来加入 esbuild 插件</p><h3 id="force"><a href="#force" class="headerlink" title="force"></a>force</h3><p>上面提到的是否忽略缓存的依赖</p><h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3><p>禁用依赖优化，一般在开发阶段才会开启</p><h3 id="needsInterop"><a href="#needsInterop" class="headerlink" title="needsInterop"></a>needsInterop</h3><p>定义一些依赖，Vite 会强制把他们进行 ESM 转换，加快冷启动速度</p><h2 id="预构建解决了什么问题"><a href="#预构建解决了什么问题" class="headerlink" title="预构建解决了什么问题"></a>预构建解决了什么问题</h2><ol><li>解决不同模块的兼容性，Vite 会将 CommonJS 或 UMD 等形式提供的依赖项转换为 ES 模块</li><li>提高性能：上面有提到过的，Vite 会将一个包内多个文件打包成单独的文件，对于一个 import 来说，相当于发出一次 HTTP<br>请求，打包成单独的文件能够减少大量 HTTP 请求</li></ol><h1 id="使用-Vite-快速搭建前端项目"><a href="#使用-Vite-快速搭建前端项目" class="headerlink" title="使用 Vite 快速搭建前端项目"></a>使用 Vite 快速搭建前端项目</h1><p>前置工具：<br>安装 node<br>使用 yarn&#x2F;pnpm 作为包管理工具，推荐 pnpm<br>编辑器 webStorm&#x2F;vscode</p><h2 id="使用命令初始化"><a href="#使用命令初始化" class="headerlink" title="使用命令初始化"></a>使用命令初始化</h2><blockquote><p>npm create vite</p></blockquote><p>执行后一次输入<strong>项目名</strong>、要选择的框架、使用的语言，这里我们选择 React + TypeScript<br>然后就是安装依赖，启动。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/img/vite-catalogue.png" alt="vite目录结构.png"></p><p>其中 index.html 是入口文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.tsx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该文件除了 id 为 root 的 div 作为根节点外，还有一个 script 标签，该标签 type 为 “module”，标志着使用的是 ESM，另外还指向一个 main.tsx 文件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.tsx&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)!).<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span>,<br>)<br></code></pre></td></tr></table></figure><p>首先，正常情况下我们写 html 文件，是无法引入 .tsx 文件的，浏览器根本不会识别，但在这里，Vite 对 .tsx 和 .jsx 通过 esbuild 进行了编译，返回浏览器可以识别的代码。这里就体现了 Vite 的 no-bundle 特性，使用 ESM 进行按需加载，对比 Webpack 需要将项目整体进行打包后加载，显然 Vite 省掉了复杂的打包过程，这也是它在开发环境更快的原因之一。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在 package.json 中我们可以看到生成项目时，已经帮我们安装了 react、react-dom、eslint 等一系列包。主要看下 scripts 我们执行的命令有哪些</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tsc &amp;&amp; vite build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;preview&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite preview&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>首先第一个命令 dev 就是我们在本地启动的命令，build 是我们对项目进行打包的命令，lint是对代码进行检查，preview 是启动我们打包后的产物</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>vite.config.ts 就是 Vite 的配置文件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;defineConfig&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>&#125;)<br></code></pre></td></tr></table></figure><p>在我们生成项目时选择的 React，这里会自动帮我们配置 React 插件对我们的项目进行编译等功能。</p><h1 id="关于样式方案"><a href="#关于样式方案" class="headerlink" title="关于样式方案"></a>关于样式方案</h1><p>Vite 对于 CSS 的预处理器做了内部支持</p><h2 id="SASS-SCSS"><a href="#SASS-SCSS" class="headerlink" title="SASS&#x2F;SCSS"></a>SASS&#x2F;SCSS</h2><p>首先安装 SASS</p><blockquote><p>pnpm i sass -D</p></blockquote><p>对于 SASS、LESS 这种预处理器是可以定义变量来做到对多处用到的样式进行统一处理</p><p>我们在 src 目录下创建 variable.scc 作为样式抽离的文件，在其中定义</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$theme-color</span>: red;<br></code></pre></td></tr></table></figure><p>然后在 src&#x2F;component 创建一个组件 Header 在其目录下定义 index.tsx index.scss 文件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;header&#x27;</span>&gt;</span>Header<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;../../variable.scss&#x27;</span>;<br><br><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$theme-color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 App.tsx 文件中引入后启动，打开界面就能看到效果 一个红色的 Header</p><p>对于变量 theme-color ，如果多个地方使用到了，每个文件都需要引入比较繁琐，Vite 提供了一个方案可以自动注入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> variablePath = <span class="hljs-title function_">normalizePath</span>(<span class="hljs-string">&#x27;./src/variable.scss&#x27;</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>    <span class="hljs-attr">css</span>: &#123;<br>        <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>            <span class="hljs-attr">scss</span>: &#123;<br>                <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@import &quot;<span class="hljs-subst">$&#123;variablePath&#125;</span>&quot;;`</span><br>            &#125;,<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里的 additionalData 会自动在每个 scss 文件注入，这时我们删掉 index.scss 的引入会发现依旧好用。</p><h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>在 Header 组件下新建 index.module.scss，在 index.tsx 中引入</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// index.tsx</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;header&#x27;</span>&gt;</span>Header<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.font&#125;</span>&gt;</span>Font<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// index.module.scss</span><br><span class="hljs-selector-class">.font</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打开开发者工具可以看到第二个 p 标签的 class 已经变成哈希值，说明 CSS Modules 生效。对于这个哈希值，Vite 提供了让我们自定义格式的方案</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>    <span class="hljs-attr">css</span>: &#123;<br>        <span class="hljs-attr">modules</span>: &#123;<br>            <span class="hljs-attr">generateScopedName</span>: <span class="hljs-string">&quot;[name]__[local]___[hash:base64:5]&quot;</span><br>        &#125;,<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过 generateScopedName 来自定义格式，name代表文件名，loacal代表类名，除了字符串，还支持 function。</p><h1 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h1><p>首先需要在项目中安装 ESLint 并且初始化</p><blockquote><p>pnpm i eslint -D<br>npx eslint –init</p></blockquote><p>最后会生成 .eslintrc.cjs 文件，这个就是 ESLint 的配置文件</p><figure class="highlight cjs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cjs"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-string">&quot;env&quot;</span>: &#123;<br><span class="hljs-string">&quot;browser&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;es2021&quot;</span>: <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-string">&quot;extends&quot;</span>: [<br><span class="hljs-string">&quot;eslint:recommended&quot;</span>,<br><span class="hljs-string">&quot;plugin:@typescript-eslint/recommended&quot;</span>,<br><span class="hljs-string">&quot;plugin:react/recommended&quot;</span><br>],<br><span class="hljs-string">&quot;overrides&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;env&quot;</span>: &#123;<br><span class="hljs-string">&quot;node&quot;</span>: <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-string">&quot;files&quot;</span>: [<br><span class="hljs-string">&quot;.eslintrc.&#123;js,cjs&#125;&quot;</span><br>],<br><span class="hljs-string">&quot;parserOptions&quot;</span>: &#123;<br><span class="hljs-string">&quot;sourceType&quot;</span>: <span class="hljs-string">&quot;script&quot;</span><br>&#125;<br>&#125;<br>],<br><span class="hljs-string">&quot;parser&quot;</span>: <span class="hljs-string">&quot;@typescript-eslint/parser&quot;</span>,<br><span class="hljs-string">&quot;parserOptions&quot;</span>: &#123;<br><span class="hljs-string">&quot;ecmaVersion&quot;</span>: <span class="hljs-string">&quot;latest&quot;</span>,<br><span class="hljs-string">&quot;sourceType&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;plugins&quot;</span>: [<br><span class="hljs-string">&quot;@typescript-eslint&quot;</span>,<br><span class="hljs-string">&quot;react&quot;</span><br>],<br><span class="hljs-string">&quot;rules&quot;</span>: &#123;<br><span class="hljs-string">&quot;indent&quot;</span>: [<br><span class="hljs-string">&quot;error&quot;</span>,<br><span class="hljs-string">&quot;tab&quot;</span><br>],<br><span class="hljs-string">&quot;linebreak-style&quot;</span>: [<br><span class="hljs-string">&quot;error&quot;</span>,<br><span class="hljs-string">&quot;unix&quot;</span><br>],<br><span class="hljs-string">&quot;quotes&quot;</span>: [<br><span class="hljs-string">&quot;error&quot;</span>,<br><span class="hljs-string">&quot;double&quot;</span><br>],<br><span class="hljs-string">&quot;semi&quot;</span>: [<br><span class="hljs-string">&quot;error&quot;</span>,<br><span class="hljs-string">&quot;always&quot;</span><br>]<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>env 是我们的运行环境<br>extends 是继承配置项，有三种情况：</p><ol><li>继承 ESLint 本身</li><li>从 npm 包继承</li><li>从插件继承</li></ol><p>overrides 是针对文件部分禁用<br>parser 是解析器，默认使用 Espree<br>parserOptions - 解析器选项<br>rules 代码启用的规则及其各自的错误级别<br>plugins 插件</p><h3 id="在-Vite-中接入-ESLint"><a href="#在-Vite-中接入-ESLint" class="headerlink" title="在 Vite 中接入 ESLint"></a>在 Vite 中接入 ESLint</h3><p>安装 ESLint 插件</p><blockquote><p>pnpm i vite-plugin-eslint -D</p></blockquote><p>在配置文件中配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-title function_">react</span>(),<br>        <span class="hljs-title function_">viteEslint</span>(),<br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样控制台就会提示错误信息了</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>Vite 默认存在四个环境变量</p><ul><li>MODE</li><li>BASE_URL</li><li>PROD</li><li>DEV</li></ul><h2 id="自定义环境变量"><a href="#自定义环境变量" class="headerlink" title="自定义环境变量"></a>自定义环境变量</h2><p>在根目录下新建 .env .env.development .env.production 这就是我们自定义环境变量的文件</p><p>.env 是通用的环境变量<br>.env.development: 开发环境需要用到的环境变量<br>.env.production: 生产环境需要用到的环境变量</p><p>需要注意的是，定义环境变量必须 VITE_ 开头。如果出现重名，.env 的环境变量将会被覆盖。</p><p>我们在 .env 中定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs env">VITE_TITLE=HELLO<br></code></pre></td></tr></table></figure><p>在 App.tsx 中输出 import.meta.env 就能看到 VITE_TITLE 这个变量了。</p><h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><h2 id="特殊资源后缀"><a href="#特殊资源后缀" class="headerlink" title="特殊资源后缀"></a>特殊资源后缀</h2><p>我们在导入资源时，可以加特定的后缀来标志这是什么资源，例如：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./assets/xxx?url&#x27;</span><br><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./assets/xxx?raw&#x27;</span><br><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./assets/xxx?worker&#x27;</span><br><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./assets/xxx?inline&#x27;</span><br></code></pre></td></tr></table></figure><p>?url 代表该资源的路径，例如可以在 img 标签的 src 指向该引入<br>?raw 代表原始文件内容<br>?worker 代表是 Web Worker 脚本<br>?inline 代表资源强关联</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>Vite 支持直接导入 JSON 文件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> json <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../package.json&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123;config&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../package.json&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h1><h2 id="什么是-HMR？"><a href="#什么是-HMR？" class="headerlink" title="什么是 HMR？"></a>什么是 HMR？</h2><p>Hot Module Replacement，也叫模板热替换，简单来说就是在页面发生变化时，进行局部更新和状态保存。</p><h2 id="如何访问"><a href="#如何访问" class="headerlink" title="如何访问"></a>如何访问</h2><p>Vite 通过 import.meta.hot 暴露手动 HMR API，通过该属性访问 HMR 的属性和方法。另外在使用 HMR API 时，要先判断 import.meta.hot，因为该属性在生产环境中为 undefined 无需热更新，加判断可以在生产环境被 tree-shaking</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>) &#123;<br>  <span class="hljs-comment">// HMR 代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们使用 Vite 创建 React &#x2F; Vue 项目，会看到 Vite 已经帮我们安了 react &#x2F; vue 的插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// react</span><br><span class="hljs-attr">plugins</span>: [<br>   <span class="hljs-title function_">react</span>(),<br>]<br><span class="hljs-comment">// vue</span><br><span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>(), <span class="hljs-title function_">vueJsx</span>()]<br></code></pre></td></tr></table></figure><p>插件默认会开启 HMR ，如果你想手动处理，通过 server 来配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">server : &#123;<br>    <span class="hljs-attr">hmr</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="hot-accept-cb"><a href="#hot-accept-cb" class="headerlink" title="hot.accept(cb)"></a>hot.accept(cb)</h3><p>接收模块自身更新，参数是已更新模块的回调函数，接受的模块就是 HMR 的边界。简单来说就是通过该方法让我们手动 HMR，更新的 module 会作为 cb 的参数</p><h3 id="hot-accept-deps-cb"><a href="#hot-accept-deps-cb" class="headerlink" title="hot.accept(deps, cb)"></a>hot.accept(deps, cb)</h3><p>接收依赖模块更新，deps 是依赖的路径，当依赖模块发生更新，会把更新后的新模块作为 cb 的参数。</p><p>另外，deps 也可以是一个 Array，接收多个依赖模块更新，随之 cb 是一个和 deps 一一对应的 Array</p><h3 id="hot-dispose-cb"><a href="#hot-dispose-cb" class="headerlink" title="hot.dispose(cb)"></a>hot.dispose(cb)</h3><p>在模块更新、旧模块需要销毁时需要做的一些事情，如果旧模块存在一些副作用，如定时器等，可以在这个方法内清除。</p><h3 id="hot-data"><a href="#hot-data" class="headerlink" title="hot.data"></a>hot.data</h3><p>可以理解为模块更新中的持久化存储，在模块更新时，hot.data 内的数据会保留。</p><h3 id="hot-prune-cb"><a href="#hot-prune-cb" class="headerlink" title="hot.prune(cb)"></a>hot.prune(cb)</h3><p>模块从页面上被删除时，使用此方法进行清理。</p><h3 id="hot-invalidate-message-string"><a href="#hot-invalidate-message-string" class="headerlink" title="hot.invalidate(message?: string)"></a>hot.invalidate(message?: string)</h3><p>指定某个模块是不可热更新的。</p><h3 id="hot-on-event-cb"><a href="#hot-on-event-cb" class="headerlink" title="hot.on(event, cb)"></a>hot.on(event, cb)</h3><p>监听 HMR 事件。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React流程图（完善ing...）</title>
    <link href="/2023/07/31/react-flow/"/>
    <url>/2023/07/31/react-flow/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/React%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="React流程图.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React原理之diff流程</title>
    <link href="/2023/07/21/diff/"/>
    <url>/2023/07/21/diff/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是-diff？"><a href="#什么是-diff？" class="headerlink" title="什么是 diff？"></a>什么是 diff？</h2><p>我们写的 JSX 文件，会变成 vDom 也就是 React Element 实例，<strong>在 render 时进行调和变成 fiber</strong>，<br>我们知道 React 采用了双缓存，正在页面中的是 current Fiber，本次渲染的是 workInProgress Fiber，<br>在渲染时会用 workInProgress Fiber 直接替换 current Fiber，<strong>而 diff 做的就是比较 vDom 和 current Fiber 来生成 workInProgress Fiber，</strong><br>另外在<strong>初始化</strong>的时候，不存在 current Fiber ，也就<strong>不需要进行 diff</strong>。</p><h1 id="三个设计思想"><a href="#三个设计思想" class="headerlink" title="三个设计思想"></a>三个设计思想</h1><ol><li>永远只比较同层节点</li><li>不同节点产生不同的树，如果节点改变了，直接删除原节点，创建新节点</li><li>开发者通过 key 标记哪些是同个节点，在 diff 时会根据 key 进行判断（这也说明了key值必须唯一）</li></ol><h1 id="单节点-diff"><a href="#单节点-diff" class="headerlink" title="单节点 diff"></a>单节点 diff</h1><p><img src="/img/%E5%8D%95%E7%82%B9diff.png" alt="单点diff.png"></p><ul><li>首先看上次更新时是否存在当前的DOM节点，如果没有证明进行了新增节点，直接创建新Fiber并返回</li><li>然后比较 key 值是否相等，我们可以自定义 key 值来表明哪些节点是稳定的，如果连 key 值都不相同，说明进行了删除操作，直接打上删除的 tag，创建新的 Fiber 返回</li><li>如果 key 相等，并且 type 也相等，证明该节点可以进行复用，直接返回即可。</li><li>如果 key 相等，type 不等，证明该节点发生了更新，需要将该 fiber 和他的兄弟 fiber 全部标记删除</li></ul><h2 id="当-key-相等，type-不等时，为什么不仅标记该-fiber-删除，还要标记兄弟-fiber-呢？？"><a href="#当-key-相等，type-不等时，为什么不仅标记该-fiber-删除，还要标记兄弟-fiber-呢？？" class="headerlink" title="当 key 相等，type 不等时，为什么不仅标记该 fiber 删除，还要标记兄弟 fiber 呢？？"></a>当 key 相等，type 不等时，为什么不仅标记该 fiber 删除，还要标记兄弟 fiber 呢？？</h2><p>首先我们要清楚一点，这里是单节点 diff，也就是说我们当前只有一个节点，我们比较 type 前已经比较过了 key，证明了是同一个节点，如果 type 不相等的话，其他的节点根本没有比较的必要了。举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br> // 变成了<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在确定该节点是由 key &#x3D; “1” 的 div 更新而来的，因为只有 p 一个单节点，后续也不会有节点继续和 key&#x3D;”1”的兄弟节点进行比较了，所以直接打上删除标签就好了。</p><h1 id="多节点-diff"><a href="#多节点-diff" class="headerlink" title="多节点 diff"></a>多节点 diff</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>第一阶段注主要处理更新的节点，步骤如下</p><ul><li>遍历 newChildren 和原来的 oldFiber ，首先比较 newChildren[i] 和 oldFiber，相同继续比较 newChildren[i+1] 和 oldFiber.sibling</li><li>如果能复用就直接复用了</li><li>不能复用有两种情况<ol><li>key不同：直接跳出第一阶段的遍历</li><li>key相同，type不同，说明发生了更新，遵循第二条思想，打上删除的 tag 继续遍历</li></ol></li></ul><p><strong>流程图</strong></p><p><img src="/img/first-traverse.png" alt="第一轮遍历.png"></p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>当经过第一阶段的遍历后可能出现以下情况</p><ul><li>newChildren 和 oldFiber 都遍历完了，说明不再需要第二轮的遍历了</li><li>newChildren 没遍历完，oldFiber 遍历完，说明新增了节点，这就需要再去遍历，标记上新增tag</li><li>newChildren遍历完，oldFiber没遍历完，说明有删除节点，所以需要遍历剩下的oldFiber，依次标记删除tag</li><li>newChildren与oldFiber都没遍历完，这说明有节点的位置发生了变化，举个例子</li></ul><blockquote><p>oldFiber: abcd<br>newChildren: acbd</p></blockquote><p>在第一轮遍历之后，a 可以复用，oldFiber 剩余 bcd，newChildren 剩余 cbd，此时将未处理的 oldFiber 存入以 key 为 key，oldFiber 为 value 的 Map 中，遍历 newChildren，通过newChildren[i].key就能在existingChildren 中找到 key 相同的 oldFiber，索引为 oldIndex，通过 lastPlacedIndex 来进行处理。</p><blockquote><p>lastPlacedIndex 代表当前newChildren项在 oldFiber 中的索引<br>如果 oldIndex &gt;&#x3D; lastPlacedIndex 代表该可复用节点不需要移动<br>并将 lastPlacedIndex &#x3D; oldIndex;<br>如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动</p></blockquote><p><strong>流程</strong></p><blockquote><p>oldFiber: abcd<br>newChildren: acbd</p></blockquote><p>经过第一次阶段遍历</p><blockquote><p>oldFiber: bcd<br>newChildren: cbd<br>查找 newChildren 的 c 在 oldFiber 中的索引为 2 ，所以 lastPlacedIndex &#x3D; 2，无需换位</p></blockquote><p>第一次查找后</p><blockquote><p>oldFiber: bd<br>newChildren: bd<br>查找 newChildren 的 b 在 oldFiber 中的索引为 1 ，所以 lastPlacedIndex &#x3D; 1，需要向右移动</p></blockquote><p>第二次查找后</p><blockquote><p>oldFiber: d<br>newChildren: d<br>查找 newChildren 的 b 在 oldFiber 中的索引为 3 ，所以 lastPlacedIndex &#x3D; 3，无需换位</p></blockquote><p>至此，Diff流程结束。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ahooks源码之useVirtualList</title>
    <link href="/2023/07/12/ahooks-useVirtualList/"/>
    <url>/2023/07/12/ahooks-useVirtualList/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于海量数据渲染起来很耗费性能，并且会造成页面卡顿，下面结合 ahooks 的 useVirtualList 源码，看一下如何实现一个虚拟列表。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> useVirtualList = &lt;T = <span class="hljs-built_in">any</span>&gt;<span class="hljs-function">(<span class="hljs-params">list: T[], options: Options&lt;T&gt;</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;containerTarget, wrapperTarget, itemHeight, overscan = <span class="hljs-number">5</span>&#125; = options;<br>    <span class="hljs-keyword">const</span> itemHeightRef = <span class="hljs-title function_">useLatest</span>(itemHeight);<br>    <span class="hljs-keyword">const</span> size = <span class="hljs-title function_">useSize</span>(containerTarget);<br>    <span class="hljs-keyword">const</span> scrollTriggerByScrollToFunc = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">const</span> [targetList, setTargetList] = useState&lt;&#123; <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">data</span>: T &#125;[]&gt;([]);<br>    <span class="hljs-keyword">const</span> [wrapperStyle, setWrapperStyle] = useState&lt;<span class="hljs-title class_">CSSProperties</span>&gt;(&#123;&#125;);<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getVisibleCount</span> = (<span class="hljs-params">containerHeight: <span class="hljs-built_in">number</span>, fromIndex: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getOffset</span> = (<span class="hljs-params">scrollTop: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getDistanceTop</span> = (<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>    <br>    <span class="hljs-keyword">const</span> totalHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;, [list]);<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">calculateRange</span> = (<span class="hljs-params"></span>) =&gt; &#123;<span class="hljs-comment">/*...*/</span>&#125;<br>    <br>    <span class="hljs-title function_">useUpdateEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;, [wrapperStyle]);<br><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;, [size?.<span class="hljs-property">width</span>, size?.<span class="hljs-property">height</span>, list]);<br><br>    <span class="hljs-title function_">useEventListener</span>(<span class="hljs-comment">/*...*/</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollTo</span> = (<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br><br>    <span class="hljs-keyword">return</span> [targetList, <span class="hljs-title function_">useMemoizedFn</span>(scrollTo)] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先来看下每个方法是做什么用的，后面再详细看实现</p><p><strong>itemHeightRef</strong>：获取最新行高<br><strong>size</strong>： 外部容器的宽高<br><strong>scrollTriggerByScrollToFunc</strong>：是否使用跳转（在跳转时会用到）<br><strong>targetList</strong>：真正需要渲染的列表<br><strong>wrapperStyle</strong>：样式信息<br><strong>getVisibleCount</strong>：计算可见的行数量<br><strong>getOffset</strong>：计算滚动上去了多少项<br><strong>getDistanceTop</strong>：根据index获取它上部的高度<br><strong>totalHeight</strong>：总高度<br><strong>calculateRange</strong>：计算并设置真正要渲染的列表<br><strong>scrollTo</strong>：根据 index 跳转</p><p>其中最重要的就是 <strong>calculateRange</strong> 方法。</p><h1 id="getVisibleCount"><a href="#getVisibleCount" class="headerlink" title="getVisibleCount"></a>getVisibleCount</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getVisibleCount</span> = (<span class="hljs-params">containerHeight: <span class="hljs-built_in">number</span>, fromIndex: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 如果 itemHeightRef.current 是 Number 类型，说明每项高度相同</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumber</span>(itemHeightRef.<span class="hljs-property">current</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(containerHeight / itemHeightRef.<span class="hljs-property">current</span>);<br>    &#125;<br>    <span class="hljs-comment">// 行高不同,就遍历加每项高度,直到溢出</span><br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> endIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = fromIndex; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> height = itemHeightRef.<span class="hljs-title function_">current</span>(i, list[i]);<br>        sum += height;<br>        endIndex = i;<br>        <span class="hljs-keyword">if</span> (sum &gt;= containerHeight) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> endIndex - fromIndex;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="getOffset"><a href="#getOffset" class="headerlink" title="getOffset"></a>getOffset</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getOffset</span> = (<span class="hljs-params">scrollTop: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 等高直接除</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumber</span>(itemHeightRef.<span class="hljs-property">current</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / itemHeightRef.<span class="hljs-property">current</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不等高就遍历去加</span><br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> height = itemHeightRef.<span class="hljs-title function_">current</span>(i, list[i]);<br>        sum += height;<br>        <span class="hljs-keyword">if</span> (sum &gt;= scrollTop) &#123;<br>            offset = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> offset + <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="getDistanceTop"><a href="#getDistanceTop" class="headerlink" title="getDistanceTop"></a>getDistanceTop</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getDistanceTop</span> = (<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 如果 itemHeightRef.current 是 Number 类型，说明每项高度相同</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumber</span>(itemHeightRef.<span class="hljs-property">current</span>)) &#123;<br>        <span class="hljs-keyword">const</span> height = index * itemHeightRef.<span class="hljs-property">current</span>;<br>        <span class="hljs-keyword">return</span> height;<br>    &#125;<br>    <span class="hljs-comment">// 如果高度不同, itemHeightRef 应该是 function,通过 reduce 累加计算高度</span><br>    <span class="hljs-keyword">const</span> height = list<br>        .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, index)<br>        .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, _, i</span>) =&gt;</span> sum + (itemHeightRef.<span class="hljs-property">current</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">ItemHeight</span>&lt;T&gt;)(i, list[i]), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> height;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="totalHeight"><a href="#totalHeight" class="headerlink" title="totalHeight"></a>totalHeight</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> totalHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果每项等高,直接高度*数量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumber</span>(itemHeightRef.<span class="hljs-property">current</span>)) &#123;<br>        <span class="hljs-keyword">return</span> list.<span class="hljs-property">length</span> * itemHeightRef.<span class="hljs-property">current</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不等高再通过 reduce 累加计算高度</span><br>    <span class="hljs-keyword">return</span> list.<span class="hljs-title function_">reduce</span>(<br>        <span class="hljs-function">(<span class="hljs-params">sum, _, index</span>) =&gt;</span> sum + (itemHeightRef.<span class="hljs-property">current</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">ItemHeight</span>&lt;T&gt;)(index, list[index]),<br>        <span class="hljs-number">0</span>,<br>    );<br>&#125;, [list]);<br></code></pre></td></tr></table></figure><h1 id="calculateRange"><a href="#calculateRange" class="headerlink" title="calculateRange"></a>calculateRange</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">calculateRange</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 获取外部容器</span><br>    <span class="hljs-keyword">const</span> container = <span class="hljs-title function_">getTargetElement</span>(containerTarget);<br><br>    <span class="hljs-keyword">if</span> (container) &#123;<br>        <span class="hljs-comment">// 获取滚动上去的高度,可见范围的高度</span><br>        <span class="hljs-keyword">const</span> &#123;scrollTop, clientHeight&#125; = container;<br>        <span class="hljs-comment">// 滚动上去的数量</span><br>        <span class="hljs-keyword">const</span> offset = <span class="hljs-title function_">getOffset</span>(scrollTop);<br>        <span class="hljs-comment">// 可见的数量</span><br>        <span class="hljs-keyword">const</span> visibleCount = <span class="hljs-title function_">getVisibleCount</span>(clientHeight, offset);<br>        <span class="hljs-comment">// 计算真正需要渲染的开始行索引</span><br>        <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, offset - overscan);<br>        <span class="hljs-comment">// 计算真正需要渲染的结束行索引</span><br>        <span class="hljs-keyword">const</span> end = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(list.<span class="hljs-property">length</span>, offset + visibleCount + overscan);<br><br>        <span class="hljs-keyword">const</span> offsetTop = <span class="hljs-title function_">getDistanceTop</span>(start);<br><br>        <span class="hljs-title function_">setWrapperStyle</span>(&#123;<br>            <span class="hljs-attr">height</span>: totalHeight - offsetTop + <span class="hljs-string">&#x27;px&#x27;</span>,<br>            <span class="hljs-attr">marginTop</span>: offsetTop + <span class="hljs-string">&#x27;px&#x27;</span>,<br>        &#125;);<br>        <span class="hljs-comment">// 真正需要渲染的数据</span><br>        <span class="hljs-title function_">setTargetList</span>(<br>            list.<span class="hljs-title function_">slice</span>(start, end).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">ele, index</span>) =&gt;</span> (&#123;<br>                <span class="hljs-attr">data</span>: ele,<br>                <span class="hljs-attr">index</span>: index + start,<br>            &#125;)),<br>        );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>计算的核心代码，通过该方法来计算真正要渲染的列表并让滚动条滚动。</p><h1 id="useUpdateEffect"><a href="#useUpdateEffect" class="headerlink" title="useUpdateEffect"></a>useUpdateEffect</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">useUpdateEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取内部容器</span><br>    <span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">getTargetElement</span>(wrapperTarget) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;<br>    <span class="hljs-keyword">if</span> (wrapper) &#123;<br>        <span class="hljs-comment">// 添加样式</span><br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(wrapperStyle).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> (wrapper.<span class="hljs-property">style</span>[key] = wrapperStyle[key]));<br>    &#125;<br>&#125;, [wrapperStyle]);<br></code></pre></td></tr></table></figure><p>只有在 wrapperStyle 变化时才触发，只有在重新计算的时候才改变了 wrapperStyle，主要作用是设置滚动条。</p><h1 id="useEventListener-监听滚动事件"><a href="#useEventListener-监听滚动事件" class="headerlink" title="useEventListener 监听滚动事件"></a>useEventListener 监听滚动事件</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">useEventListener</span>(<br>    <span class="hljs-string">&#x27;scroll&#x27;</span>,<br>    <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果直接根据 index 跳转的，关闭跳转标志然后 return</span><br>        <span class="hljs-keyword">if</span> (scrollTriggerByScrollToFunc.<span class="hljs-property">current</span>) &#123;<br>            scrollTriggerByScrollToFunc.<span class="hljs-property">current</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        e.<span class="hljs-title function_">preventDefault</span>();<br>        <span class="hljs-comment">// 重新计算</span><br>        <span class="hljs-title function_">calculateRange</span>();<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">target</span>: containerTarget,<br>    &#125;,<br>);<br></code></pre></td></tr></table></figure><h1 id="scrollTo-滚动跳转"><a href="#scrollTo-滚动跳转" class="headerlink" title="scrollTo 滚动跳转"></a>scrollTo 滚动跳转</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollTo</span> = (<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 获取外部容器</span><br>    <span class="hljs-keyword">const</span> container = <span class="hljs-title function_">getTargetElement</span>(containerTarget);<br>    <span class="hljs-keyword">if</span> (container) &#123;<br>        <span class="hljs-comment">// 开启跳转标志</span><br>        scrollTriggerByScrollToFunc.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 设置滚动</span><br>        container.<span class="hljs-property">scrollTop</span> = <span class="hljs-title function_">getDistanceTop</span>(index);<br>        <span class="hljs-title function_">calculateRange</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到主要实现就是通过监听滚动事件，计算滚动上去的高度 + margin 实现让滚动条滚动，计算出可显示的行数量加上缓冲区的数量，成为真正要渲染的列表。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ahooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ahooks源码之useRequest</title>
    <link href="/2023/07/11/ahooks-useRequest/"/>
    <url>/2023/07/11/ahooks-useRequest/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们日常开发 React 项目时，不可避免的要发送很多请求，那如何提炼出一个满足大部分场景，并且又能够优雅使用的 Hooks<br>来提高我们开发的效率呢，接下来我们来通过源码看一下目前应用很广泛的 ahooks 的 useRequest 是如何做的。</p><h1 id="useRequest"><a href="#useRequest" class="headerlink" title="useRequest"></a>useRequest</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> useRequest&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt;(<br>    <span class="hljs-attr">service</span>: <span class="hljs-title class_">Service</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;,<br>    options?: <span class="hljs-title class_">Options</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;,<br>    plugins?: <span class="hljs-title class_">Plugin</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;[],<br>) &#123;<br>    <span class="hljs-keyword">return</span> useRequestImplement&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;(service, options, [<br>        ...(plugins || []),<br>        useDebouncePlugin,<br>        useLoadingDelayPlugin,<br>        usePollingPlugin,<br>        useRefreshOnWindowFocusPlugin,<br>        useThrottlePlugin,<br>        useAutoRunPlugin,<br>        useCachePlugin,<br>        useRetryPlugin,<br>    ] <span class="hljs-keyword">as</span> <span class="hljs-title class_">Plugin</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;[]);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先可以看到 useRequest 实际上返回了一个 useRequestImplement 的执行结果 这里比较特殊的是第三个参数，它是一个插件数组。</p><p>useRequest 提供了 Loading Delay、轮询、Ready 等等一系列功能，那这些功能其实都对应着一个插件，这样通过插件的机制很大程度上降低了各个功能之间的耦合度。</p><p>另外我们需要了解下这些插件执行后返回了什么，这个后面会用到。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">useCachePlugin</span>: <span class="hljs-title class_">Plugin</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>[]&gt; = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-comment">/*...*/</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">onBefore</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> &#123; <span class="hljs-comment">/*...*/</span><br>        &#125;,<br>        <span class="hljs-attr">onRequest</span>: <span class="hljs-function">(<span class="hljs-params">service, args</span>) =&gt;</span> &#123; <span class="hljs-comment">/*...*/</span><br>        &#125;,<br>        <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">(<span class="hljs-params">data, params</span>) =&gt;</span> &#123; <span class="hljs-comment">/*...*/</span><br>        &#125;,<br>        <span class="hljs-attr">onMutate</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123; <span class="hljs-comment">/*...*/</span><br>        &#125;,<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里用 useCachePlugin 插件做例子，可以看到他的返回值是一些回调钩子，其实他的意思就是在对应的钩子执行对应的方法。</p><p>接下来我们看下 useRequestImplement 是如何实现的。</p><h1 id="useRequestImplement"><a href="#useRequestImplement" class="headerlink" title="useRequestImplement"></a>useRequestImplement</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> useRequestImplement&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt;(<br>    <span class="hljs-attr">service</span>: <span class="hljs-title class_">Service</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;,<br>    <span class="hljs-attr">options</span>: <span class="hljs-title class_">Options</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt; = &#123;&#125;,<br>    <span class="hljs-attr">plugins</span>: <span class="hljs-title class_">Plugin</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;[] = [],<br>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;manual = <span class="hljs-literal">false</span>, ...rest&#125; = options;<br>    <span class="hljs-keyword">const</span> fetchOptions = &#123;<br>        manual,<br>        ...rest,<br>    &#125;;<br>    <span class="hljs-keyword">const</span> serviceRef = <span class="hljs-title function_">useLatest</span>(service);<br>    <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">useUpdate</span>();<br>    <span class="hljs-keyword">const</span> fetchInstance = <span class="hljs-title function_">useCreation</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;, []);<br>    fetchInstance.<span class="hljs-property">options</span> = fetchOptions;<br>    fetchInstance.<span class="hljs-property">pluginImpls</span> = plugins.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-title function_">p</span>(fetchInstance, fetchOptions));<br>    <span class="hljs-title function_">useMount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;);<br>    <span class="hljs-title function_">useUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> &#123;<br>        loading,<br>        data,<br>        error,<br>        params,<br>        cancel,<br>        refresh,<br>        refreshAsync,<br>        run,<br>        runAsync,<br>        mutate,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>首先看参数<br>service 是真正要请求的方法，<br>options 是配置项<br>plugins 是插件数组</p></li><li><p>再看内部定义的一些变量和方法<br>manual 是作为是否默认执行 useRequest 的依据，为 true 时，不会默认执行，需要手动触发<br>fetchOptions 是将配置项整合<br>serviceRef 返回当前最新的 service<br>update 可以理解为 forceUpdate， 让组件重新渲染<br>这里最重要的就是 fetchInstance ，返回的所有值都要基于 fetchInstance 。</p></li></ol><h2 id="useMount-useUnmount"><a href="#useMount-useUnmount" class="headerlink" title="useMount &#x2F; useUnmount"></a>useMount &#x2F; useUnmount</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组件初始化执行</span><br><span class="hljs-title function_">useMount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!manual) &#123;<br>        <span class="hljs-keyword">const</span> params = fetchInstance.<span class="hljs-property">state</span>.<span class="hljs-property">params</span> || options.<span class="hljs-property">defaultParams</span> || [];<br>        fetchInstance.<span class="hljs-title function_">run</span>(...params);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 组件卸载执行</span><br><span class="hljs-title function_">useUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    fetchInstance.<span class="hljs-title function_">cancel</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里看到hooks的名字应该也能猜到，这是两个生命周期，在组件初始化时，如果设置了 manual 为 true，就执行请求， 在组件销毁时，取消请求</p><h2 id="fetchInstance"><a href="#fetchInstance" class="headerlink" title="fetchInstance"></a>fetchInstance</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> fetchInstance = <span class="hljs-title function_">useCreation</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> initState =<br>        plugins.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p?.<span class="hljs-property">onInit</span>?.(fetchOptions)).<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fetch</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;(<br>        serviceRef,<br>        fetchOptions,<br>        update,<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, ...initState),<br>    );<br>&#125;, []);<br>fetchInstance.<span class="hljs-property">options</span> = fetchOptions;<br><span class="hljs-comment">// 执行所有的插件，将结果返回给 pluginImpls 属性</span><br>fetchInstance.<span class="hljs-property">pluginImpls</span> = plugins.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-title function_">p</span>(fetchInstance, fetchOptions));<br></code></pre></td></tr></table></figure><p>fetchInstance 是一个通过 useCreation 创建出来的一个常量对象，这个对象是通过 new Fetch<br>创建的。然后将配置项和插件的执行结果赋值给对象的属性。fetchInstance 的一系列属性方法都是来自这个 Fetch。</p><h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fetch</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt; &#123;<br>    <span class="hljs-attr">pluginImpls</span>: <span class="hljs-title class_">PluginReturn</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;[];<br>    <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-attr">state</span>: <span class="hljs-title class_">FetchState</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt; = &#123;<br>        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">error</span>: <span class="hljs-literal">undefined</span>,<br>    &#125;;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">        <span class="hljs-keyword">public</span> serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,</span><br><span class="hljs-params">        <span class="hljs-keyword">public</span> options: Options&lt;TData, TParams&gt;,</span><br><span class="hljs-params">        <span class="hljs-keyword">public</span> subscribe: Subscribe,</span><br><span class="hljs-params">        <span class="hljs-keyword">public</span> initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,</span><br><span class="hljs-params">    </span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>,<br>            <span class="hljs-attr">loading</span>: !options.<span class="hljs-property">manual</span>,<br>            ...initState,<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">setState</span>(<span class="hljs-params">s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-params">event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">runAsync</span>(...<span class="hljs-attr">params</span>: <span class="hljs-title class_">TParams</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">TData</span>&gt; &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-title function_">run</span>(<span class="hljs-params">...params: TParams</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-title function_">refresh</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-title function_">refreshAsync</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-title function_">mutate</span>(<span class="hljs-params">data?: TData | ((oldData?: TData) =&gt; TData | <span class="hljs-literal">undefined</span>)</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先在创建实例时，传入了四个参数，从 fetchInstance 中创建实例的时候可以看到这四个值分别对应什么，</p><ul><li>serviceRef 就是要请求的 service</li><li>options 是配置项</li><li>subscribe 是让组件重新渲染</li><li>initState 是初始化的 state 值</li></ul><p>然后在 constructor 中初始化了 state。<br>剩下的除了 runPluginHandler 是内部使用的方法，其他都是在 useRequestImplement 抛出提供给我们使用的方法。<br>最重要的两个方法应该是 runPluginHandler 和 runAsync。</p><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">setState</span>(<span class="hljs-params">s</span><br><span class="hljs-params">:</span><br><span class="hljs-params">Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;</span><br><span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>        ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>,<br>        ...s,<br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">subscribe</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法没什么好说的，就是更新 state，然后触发重新渲染。</p><h2 id="runPluginHandler"><a href="#runPluginHandler" class="headerlink" title="runPluginHandler"></a>runPluginHandler</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-params">event</span><br><span class="hljs-params">:</span><br><span class="hljs-params">keyof</span><br><span class="hljs-params">PluginReturn&lt;TData, TParams&gt;,</span><br><span class="hljs-params">...</span><br><span class="hljs-params">rest: <span class="hljs-built_in">any</span>[]</span><br><span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-comment">// 执行存在 event 生命周期的插件，返回成功回调的结果，进行浅拷贝并返回</span><br>    <span class="hljs-keyword">const</span> r = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pluginImpls</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i[event]?.(...rest)).<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, ...r);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在开始的时候有介绍给插件的返回值是什么，runPluginHandler 就是在特定的阶段执行对应的插件方法，event 就是代表要执行的阶段。<br>我们来看一下 PluginReturn 类型，了解一下到底有多少个阶段。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PluginReturn</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt; &#123;<br>    onBefore?: <span class="hljs-function">(<span class="hljs-params">params: TParams</span>) =&gt;</span><br>        | (&#123;<br>        stopNow?: <span class="hljs-built_in">boolean</span>;<br>        returnNow?: <span class="hljs-built_in">boolean</span>;<br>    &#125; &amp; <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">FetchState</span>&lt;<span class="hljs-title class_">TData</span>, <span class="hljs-title class_">TParams</span>&gt;&gt;)<br>        | <span class="hljs-built_in">void</span>;<br><br>    onRequest?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        service: Service&lt;TData, TParams&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        params: TParams,</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) =&gt;</span> &#123;<br>        servicePromise?: <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">TData</span>&gt;;<br>    &#125;;<br><br>    onSuccess?: <span class="hljs-function">(<span class="hljs-params">data: TData, params: TParams</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>    onError?: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">Error</span>, params: TParams</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>    onFinally?: <span class="hljs-function">(<span class="hljs-params">params: TParams, data?: TData, e?: <span class="hljs-built_in">Error</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>    onCancel?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>    onMutate?: <span class="hljs-function">(<span class="hljs-params">data: TData</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h2><p>runAsync 就是真正去执行请求的方法，接下来我们根据不同的阶段来分别说明是如何处理的</p><h3 id="onBefore"><a href="#onBefore" class="headerlink" title="onBefore"></a>onBefore</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123;<br>    stopNow = <span class="hljs-literal">false</span>,<br>    returnNow = <span class="hljs-literal">false</span>,<br>    ...state<br>&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onBefore&#x27;</span>, params);<br><br><span class="hljs-keyword">if</span> (stopNow) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 更新 state</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>,<br>    params,<br>    ...state,<br>&#125;);<br><br><span class="hljs-comment">// 如果开启缓存并且缓存没过期直接返回缓存值</span><br><span class="hljs-keyword">if</span> (returnNow) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(state.<span class="hljs-property">data</span>);<br>&#125;<br><span class="hljs-comment">// 执行我们自定义的传入的 onBefore 函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">onBefore</span>?.(params);<br></code></pre></td></tr></table></figure><p>onBefore 阶段可以理解为在发起真正请求之前做的事情，首先说一下 stopNow、returnNow 分别代表了什么</p><ul><li>stopNow：ready（可以在option中配置，默认为true） 为 false 时，stopNow 为 true，不会发出请求，直接返回</li><li>returnNow：该值在开启缓存时，并且缓存没有过期时为 true，这样就会把缓存的值返回</li></ul><p>OnBefore 执行流程就是 判读是否需要请求 -&gt; 更新 state -&gt; 是否缓存可用 -&gt; 自定义 onBefore 函数</p><h3 id="onRequest"><a href="#onRequest" class="headerlink" title="onRequest"></a>onRequest</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 读取缓存</span><br><span class="hljs-keyword">let</span> &#123;servicePromise&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onRequest&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">serviceRef</span>.<span class="hljs-property">current</span>, params);<br><span class="hljs-comment">// 未使用缓存就执行 service</span><br><span class="hljs-keyword">if</span> (!servicePromise) &#123;<br>    servicePromise = <span class="hljs-variable language_">this</span>.<span class="hljs-property">serviceRef</span>.<span class="hljs-title function_">current</span>(...params);<br>&#125;<br><br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> servicePromise;<br></code></pre></td></tr></table></figure><p>onRequest 是真正发起请求的阶段<br>servicePromise 就是请求方法，因为只有缓存插件 useCachePlugin 有 onRequest 阶段，所以初始化 servicePromise 时首先判断是否缓存能用，<br>如果没有缓存，就执行请求方法</p><h3 id="onSuccess"><a href="#onSuccess" class="headerlink" title="onSuccess"></a>onSuccess</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 判断是否 cancel 了</span><br><span class="hljs-keyword">if</span> (currentCount !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;<br>    <span class="hljs-comment">// prevent run.then when request is canceled</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 如果成功就更新 state，执行自定义传入的 onSuccess 方法</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">data</span>: res,<br>    <span class="hljs-attr">error</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>&#125;);<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">onSuccess</span>?.(res, params);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onSuccess&#x27;</span>, res, params);<br></code></pre></td></tr></table></figure><p>onSuccess 阶段就是请求成功后的阶段，我们会发现很多地方用到了 currentCount !&#x3D;&#x3D; this.count 这个判断，<br>这个判断实际上就是用来校验当前的 runAsync 是否被打断了，如果在执行 runAsync 的时候，我们手动通过 cancel<br>去取消，那么就会通过这个校验，结束本次执行。</p><h3 id="onFinally"><a href="#onFinally" class="headerlink" title="onFinally"></a>onFinally</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">onFinally</span>?.(params, res, <span class="hljs-literal">undefined</span>);<br><span class="hljs-comment">// 判断是否 cancel 了</span><br><span class="hljs-keyword">if</span> (currentCount === <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onFinally&#x27;</span>, params, res, <span class="hljs-literal">undefined</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>onFinally 阶段就是最后触发的一个阶段，执行一下我们自定义的 onFinally。</p><h3 id="onError-错误处理"><a href="#onError-错误处理" class="headerlink" title="onError 错误处理"></a>onError 错误处理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 判断是否 cancel 了</span><br><span class="hljs-keyword">if</span> (currentCount !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;<br>    <span class="hljs-comment">// prevent run.then when request is canceled</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    &#125;);<br>&#125;<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    error,<br>    <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>&#125;);<br><span class="hljs-comment">// 如果自定义传入错误处理就执行</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">onError</span>?.(error, params);<br><span class="hljs-comment">// 执行插件的错误处理</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onError&#x27;</span>, error, params);<br><span class="hljs-comment">// 即使捕获到错误 onFinally 依然正常最后执行</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">onFinally</span>?.(params, <span class="hljs-literal">undefined</span>, error);<br><span class="hljs-keyword">if</span> (currentCount === <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onFinally&#x27;</span>, params, <span class="hljs-literal">undefined</span>, error);<br>&#125;<br><br><span class="hljs-keyword">throw</span> error;<br></code></pre></td></tr></table></figure><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">run</span>(<span class="hljs-params">...params</span><br><span class="hljs-params">:</span><br><span class="hljs-params">TParams</span><br><span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runAsync</span>(...params).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">onError</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>run本质就是执行 runAsync ，只不过不需要我们再手动处理异常了。</p><h2 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onCancel&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>cancel 就是在 runAsync 说到的手动取消的方法，他改变了 count 的值，导致 count 和 currentCount 不相等，跳出 runAsync。</p><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">refresh</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>(...(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">params</span> || []));<br>&#125;<br></code></pre></td></tr></table></figure><p>refresh 刷新，使用上次请求的参数重新请求一次。</p><h2 id="refreshAsync"><a href="#refreshAsync" class="headerlink" title="refreshAsync"></a>refreshAsync</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">refreshAsync</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runAsync</span>(...(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">params</span> || []));<br>&#125;<br></code></pre></td></tr></table></figure><p>refresh 对应 run ，refreshAsync 对应 runAsync。</p><h2 id="mutate"><a href="#mutate" class="headerlink" title="mutate"></a>mutate</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts">  <span class="hljs-title function_">mutate</span>(<span class="hljs-params">data ? : TData | ((oldData?: TData) =&gt; TData | <span class="hljs-literal">undefined</span>)</span>)<br>&#123;<br>    <span class="hljs-keyword">const</span> targetData = <span class="hljs-title function_">isFunction</span>(data) ? <span class="hljs-title function_">data</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">data</span>) : data;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runPluginHandler</span>(<span class="hljs-string">&#x27;onMutate&#x27;</span>, targetData);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">data</span>: targetData,<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 data 的值，传入的可以是个值，也可以是个函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们来梳理一下 useRequest 到底做了什么，他本身返回的是 useRequestImplement 执行结果，传入了真正的请求方法，用户自定义配置，以及一个插件数组，而 useRequestImplement 又依赖于 Fetch 这个构造方法。整个请求过程都有一条时间线，插件执行的结果就是每个时间节点对应要做的操作，通过 runPluginHandler 统一触发执行，在有的节点允许用户自定义要执行的方法，关于请求的数据的被存在 Fetch 的 state 中，是不是有点像之前的 Redux，最后再将用户操作和请求有关的数据暴露出去。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ahooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux源码之createStore</title>
    <link href="/2023/05/29/redux-source/"/>
    <url>/2023/05/29/redux-source/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文会按照 createStore 的源码，由上至下分别从参数、内部定义的变量、getState、subScribe订阅、dispatch派发、replaceReducer 替换 reducer 几个方面进行介绍。关于combineReducers applyMiddleware 的源码在<a href="https://l1ushun.github.io/2023/05/26/create-redux/">快速入门Redux</a>有进行说明。</p><h1 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">createStore</span>(reducer, preloadedState, enhancer)<br></code></pre></td></tr></table></figure><p>createStore 接收三个参数：reducer、初始化的 state、中间件（加强dispatch）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// reducer 必须是 function</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducer !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-comment">/*...*/</span>)<br>&#125;<br><span class="hljs-comment">// 第二、三个参数不能同时为 function</span><br><span class="hljs-keyword">if</span> (<br>    (<span class="hljs-keyword">typeof</span> preloadedState === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;function&#x27;</span>) ||<br>    (<span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">3</span>] === <span class="hljs-string">&#x27;function&#x27;</span>)<br>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-comment">/*...*/</span>)<br>&#125;<br><span class="hljs-comment">// 如果只传了两个参数，并且第二个参数是 function，那么默认第二个参数就是 enhancer</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> preloadedState === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    enhancer = preloadedState<br>    preloadedState = <span class="hljs-literal">undefined</span><br>&#125;<br><span class="hljs-comment">// 如果有第三个参数并且是个 function 就执行这个 function，这里是对中间件的处理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-comment">/*...*/</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">enhancer</span>(createStore)(<br>        reducer,<br>        preloadedState,<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码可以看到，第二个参数 preloadedState 不是必须传的，那当不传第二个参数，state 是如何初始化的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">INIT</span> &#125;);<br></code></pre></td></tr></table></figure><p>在 createStore 底部执行了一次 type 为随机的派发，这时执行 reducer，返回结果就会赋给 currentState 完成初始化</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentReducer = reducer<br><span class="hljs-keyword">let</span> currentState = preloadedState<br><span class="hljs-keyword">let</span> currentListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">let</span> nextListeners = currentListeners<br><span class="hljs-keyword">let</span> listenerIdCounter = <span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> isDispatching = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><ul><li>currentReducer 就是我们传入 createStore 的 reducer</li><li>currentState 就是初始化的 state</li><li>currentListeners 是一个 map用来存放订阅事件</li><li>nextListeners 是 currentListeners 的副本</li><li>isDispatching 用来判断是否处于 dispatch</li></ul><h1 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (isDispatching) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;You may not call store.getState() while the reducer is executing. &#x27;</span> +<br>          <span class="hljs-string">&#x27;The reducer has already received the state as an argument. &#x27;</span> +<br>          <span class="hljs-string">&#x27;Pass it down from the top reducer instead of reading it from the store.&#x27;</span><br>      )<br>    &#125;<br>    <span class="hljs-keyword">return</span> currentState;<br>  &#125;<br></code></pre></td></tr></table></figure><p>getState 就是在不是 dispatch 的状态下，执行返回当前的 state。</p><h1 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener: () =&gt; <span class="hljs-keyword">void</span></span>) &#123;<br>    <span class="hljs-comment">// listener 必须是一个 function</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> listener !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>            <span class="hljs-string">`Expected the listener to be a function. Instead, received: &#x27;<span class="hljs-subst">$&#123;kindOf(</span></span><br><span class="hljs-subst"><span class="hljs-string">                listener</span></span><br><span class="hljs-subst"><span class="hljs-string">            )&#125;</span>&#x27;`</span><br>        )<br>    &#125;<br>    <span class="hljs-comment">// 在 dispatch 时不可以订阅</span><br>    <span class="hljs-keyword">if</span> (isDispatching) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>            <span class="hljs-string">&#x27;You may not call store.subscribe() while the reducer is executing. &#x27;</span> +<br>            <span class="hljs-string">&#x27;If you would like to be notified after the store has been updated, subscribe from a &#x27;</span> +<br>            <span class="hljs-string">&#x27;component and invoke store.getState() in the callback to access the latest state. &#x27;</span> +<br>            <span class="hljs-string">&#x27;See https://redux.js.org/api/store#subscribelistener for more details.&#x27;</span><br>        )<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> isSubscribed = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// 确保下次的监听队列是最新的</span><br>    <span class="hljs-title function_">ensureCanMutateNextListeners</span>()<br>    <span class="hljs-comment">// 向 nextListeners 加入新的 listener</span><br>    <span class="hljs-keyword">const</span> listenerId = listenerIdCounter++<br>    nextListeners.<span class="hljs-title function_">set</span>(listenerId, listener)<br>    <span class="hljs-comment">// 退订</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 如果没订阅，直接返回</span><br>        <span class="hljs-keyword">if</span> (!isSubscribed) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// dispatch 中不能退订</span><br>        <span class="hljs-keyword">if</span> (isDispatching) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>                <span class="hljs-string">&#x27;You may not unsubscribe from a store listener while the reducer is executing. &#x27;</span> +<br>                <span class="hljs-string">&#x27;See https://redux.js.org/api/store#subscribelistener for more details.&#x27;</span><br>            )<br>        &#125;<br><br>        isSubscribed = <span class="hljs-literal">false</span><br><br>        <span class="hljs-title function_">ensureCanMutateNextListeners</span>()<br>        <span class="hljs-comment">// 将退订的方法从新的监听队列移除</span><br>        nextListeners.<span class="hljs-title function_">delete</span>(listenerId)<br>        <span class="hljs-comment">// 清空当前监听队列</span><br>        currentListeners = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ensureCanMutateNextListeners"><a href="#ensureCanMutateNextListeners" class="headerlink" title="ensureCanMutateNextListeners"></a>ensureCanMutateNextListeners</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureCanMutateNextListeners</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 判断新监听队列和当前队列是否指向同一地址</span><br>    <span class="hljs-keyword">if</span> (nextListeners === currentListeners) &#123;<br>        <span class="hljs-comment">// 浅拷贝一份 currentListeners。currentListeners 和 nextListeners 不再指向同一地址 后面会在 nextListeners 里面进行新的监听事件添加。</span><br>        nextListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>        currentListeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">listener, key</span>) =&gt;</span> &#123;<br>            nextListeners.<span class="hljs-title function_">set</span>(key, listener)<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么采用两个监听队列"><a href="#为什么采用两个监听队列" class="headerlink" title="为什么采用两个监听队列"></a>为什么采用两个监听队列</h2><p>currentListeners 代表的是当前的监听队列,nextListeners代表的是下次要执行的监听队列,那么为什么需要两个监听队列呢?<br>我们设想一个场景,如果我们在订阅时进行嵌套,如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一次订阅&quot;</span>)<br>    <span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;嵌套订阅&quot;</span>)<br>    &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里在 subscribe 订阅时嵌套 再次订阅，嵌套订阅并不会立即执行，而是会被保存在 nextListeners 在下次执行<br>这样可以保证在订阅过程中任何新订阅和取消订阅不会对当前的监听产生影响。</p><h1 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-comment">// 首先判断 action 是否是一个纯对象</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPlainObject</span>(action)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">`Actions must be plain objects. Instead, the actual type was: &#x27;<span class="hljs-subst">$&#123;kindOf(</span></span><br><span class="hljs-subst"><span class="hljs-string">          action</span></span><br><span class="hljs-subst"><span class="hljs-string">        )&#125;</span>&#x27;. You may need to add middleware to your store setup to handle dispatching other values, such as &#x27;redux-thunk&#x27; to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`</span><br>      )<br>    &#125;<br>    <span class="hljs-comment">// 判断 action 是否存在 type 属性</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;Actions may not have an undefined &quot;type&quot; property. You may have misspelled an action type string constant.&#x27;</span><br>      )<br>    &#125;<br>    <span class="hljs-comment">// 判断 action 的 type 是否是一个 string</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">`Action &quot;type&quot; property must be a string. Instead, the actual type was: &#x27;<span class="hljs-subst">$&#123;kindOf(</span></span><br><span class="hljs-subst"><span class="hljs-string">          action.type</span></span><br><span class="hljs-subst"><span class="hljs-string">        )&#125;</span>&#x27;. Value was: &#x27;<span class="hljs-subst">$&#123;action.type&#125;</span>&#x27; (stringified)`</span><br>      )<br>    &#125;<br>    <span class="hljs-comment">// 如果正处于 dispatch 状态，不可以再进行 dispatch 会抛出错误</span><br>    <span class="hljs-keyword">if</span> (isDispatching) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Reducers may not dispatch actions.&#x27;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 到这里就可以开始进行 dispatch 了，首先把状态设置为 正在 dispatch</span><br>      isDispatching = <span class="hljs-literal">true</span><br>      <span class="hljs-comment">// 执行 reducer，传入 旧的state 和 action，将执行结果也就是新的 state 赋值给 currentState</span><br>      currentState = <span class="hljs-title function_">currentReducer</span>(currentState, action)<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 无论是否成功，最后都要关闭 dispatch 状态</span><br>      isDispatching = <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// 将 nextListeners 赋值给 currentListeners，此时他们指向同一地址</span><br>    <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners)<br>    <span class="hljs-comment">// 遍历执行所有的监听函数</span><br>    listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">listener</span>()<br>    &#125;)<br>    <span class="hljs-keyword">return</span> action<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="isPlainObject"><a href="#isPlainObject" class="headerlink" title="isPlainObject"></a>isPlainObject</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPlainObject</span>(<span class="hljs-params">obj</span>): boolean &#123;<br>  <span class="hljs-comment">// action 必须是个非空对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <br>  <span class="hljs-keyword">let</span> proto = obj<br>  <span class="hljs-comment">// 获取到 obj 原型链非 null 的顶层，赋值给 proto</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto) !== <span class="hljs-literal">null</span>) &#123;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto)<br>  &#125;<br>  <span class="hljs-comment">// 判断 obj 的原型是否为 proto action。其实就是判断 obj 是否存在继承关系，存在则返回 false</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === proto<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceReducer</span>(<span class="hljs-params">nextReducer</span>) &#123;<br>  <span class="hljs-comment">// 新的 reducer 必须是一个 function</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextReducer !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>      <span class="hljs-string">`Expected the nextReducer to be a function. Instead, received: &#x27;<span class="hljs-subst">$&#123;kindOf(</span></span><br><span class="hljs-subst"><span class="hljs-string">        nextReducer</span></span><br><span class="hljs-subst"><span class="hljs-string">      )&#125;</span>`</span><br>    )<br>  &#125;<br>  <span class="hljs-comment">// 进行替换</span><br>  currentReducer = nextReducer<br>  <span class="hljs-comment">// 进行一次派发</span><br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">REPLACE</span> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>replaceReducer 就是简单的进行替换然后进行一次派发。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速入门Redux</title>
    <link href="/2023/05/26/create-redux/"/>
    <url>/2023/05/26/create-redux/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文采用例子 + 部分源码 的方式，一步步实现一个简单的 redux。其中还包括 combineReducers、applyMiddleware 等源码解析。</p><h1 id="如何改变一个值"><a href="#如何改变一个值" class="headerlink" title="如何改变一个值"></a>如何改变一个值</h1><p>首先我们来想一个很简单的问题，我们如何改变一个值呢？ 一下想到的肯定是定义变量，然后去修改这个变量的值，那如果我想控制这个变量的修改规则，只能按照我的意愿限制他怎么被修改呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> initState = &#123;<br>  <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>,<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">countReducer</span>(<span class="hljs-params">preState, action</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type, data &#125; = action;<br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123;...preState, <span class="hljs-attr">num</span>: preState.<span class="hljs-property">num</span> + data&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123;...preState, <span class="hljs-attr">num</span>: preState.<span class="hljs-property">num</span> - data&#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> preState;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeCount</span>(<span class="hljs-params">type, data</span>) &#123;<br>    initState = <span class="hljs-title function_">countReducer</span>(initState, &#123; type, data&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 initState 就是我们声明的变量，countReducer 就是我们去修改它的工具，这个工具限制他只能通过 ‘increment’ 或者 ‘decrement’ 的方式来得到新的值。<br>到这里又产生一个问题，initState 的值确实被改变了，但我怎么知道它被改了呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> listeners = [];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener</span>) &#123;<br>  listeners.<span class="hljs-title function_">push</span>(listener);<br>&#125;<br><br><span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`state的count值发生改变了，新的值为<span class="hljs-subst">$&#123;initState.count&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeCount</span>(<span class="hljs-params">type, data</span>) &#123;<br>  initState = <span class="hljs-title function_">countReducer</span>(initState, &#123; type, data&#125;);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; listeners.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> listener = listeners[i];<br>    <span class="hljs-title function_">listener</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了发布订阅思想，在原来代码的基础上，我们增加了 subScribe 方法来进行订阅，监听 initState 的值发生了变化，在每次改变 initState 值的时候，我们去遍历一下 listeners 进行发布，通知值被改变了</p><p>现在我们将这部分代码整合起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createStore</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> initState = &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">1</span><br>  &#125;;<br>  <span class="hljs-keyword">let</span> listeners = [];<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener</span>) &#123;<br>    listeners.<span class="hljs-title function_">push</span>(listener);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">countReducer</span>(<span class="hljs-params">preState, action</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; type, data &#125; = action;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:<br>        <span class="hljs-keyword">return</span> &#123;...preState, <span class="hljs-attr">count</span>: preState.<span class="hljs-property">count</span> + data&#125;;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:<br>        <span class="hljs-keyword">return</span> &#123;...preState, <span class="hljs-attr">count</span>: preState.<span class="hljs-property">count</span> - data&#125;;<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">return</span> preState;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeCount</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; type, data &#125; = action;<br>    initState = <span class="hljs-title function_">countReducer</span>(initState, &#123; type, data &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; listeners.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> listener = listeners[i];<br>      <span class="hljs-title function_">listener</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 外界是需要获取到 state 值的，这里我们向外暴露一个 getState 方法</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getState</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> initState;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    subscribe,<br>    changeCount,<br>    getState,<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>();<br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> state = store.<span class="hljs-title function_">getState</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`state的count值发生改变了，新的值为<span class="hljs-subst">$&#123;state.count&#125;</span>`</span>);<br>&#125;);<br>store.<span class="hljs-title function_">changeCount</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-attr">data</span>: <span class="hljs-number">10</span> &#125;);<br></code></pre></td></tr></table></figure><p>这里我们在调用 changeCount 的时候，type需要手动写入，很容易出现单词输入错误的情况，那我们就用一个 action 来将这些类型收集起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createIncrementAction</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;increment&quot;</span>, data &#125;;<br>&#125;;<br>store.<span class="hljs-title function_">changeCount</span>(<span class="hljs-title function_">createIncrementAction</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><p>至此我们可以稍微总结一下， initState 就是我们存放变量的仓库，我们通过调用 changeCount 的方法来更改 state 中的值，同时使用 subScribe 来进行订阅，监听 initState 发生的变化</p><h1 id="combineReducers-整合-reducer"><a href="#combineReducers-整合-reducer" class="headerlink" title="combineReducers 整合 reducer"></a>combineReducers 整合 reducer</h1><p>接下来我们再给他进行升级，这里的 reducer 独立存在的 我们可以将它抽离出来。那在有多个 reducer 的情况下改如何处理呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combineReducers</span> (reducers) &#123;<br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">conbineReducer</span>(<span class="hljs-params">state =&#123;&#125;, action</span>) &#123;<br>    <span class="hljs-keyword">const</span> nextState = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> key = keys[i];<br>      <span class="hljs-keyword">const</span> reducer = reducers[key];<br>      nextState[key] = <span class="hljs-title function_">reducer</span>(state[key], action);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      ...state,<br>      ...nextState,<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// combineReducers 参数是一个对象，key、value 分别是 initState 中对应的变量名和它的 reducer</span><br><span class="hljs-keyword">const</span> reducers = <span class="hljs-title function_">combineReducers</span>(&#123; <span class="hljs-attr">count</span>: countReducer, <span class="hljs-attr">info</span>: infoReducer&#125;);<br></code></pre></td></tr></table></figure><p>combineReducers 返回了一个 conbineReducer 的方法，当我们每次调用 reducers 去修改值的时候，就会执行这个方法，他首先遍历了 reducers，找到 key 值，执行 reducer 将值赋给 state 中的 同名属性，这也就是我们在执行 combineReducers 传入的对象的 key 值和 state 中的属性名需要对应的原因。</p><p>我们通过 combineReducers 方法来将多个 reducer 合并，然后将 changeCount 中的 countReducer 改成 reducers，由于不再是单独的改变 count 的方法了，这个方法还叫 changeCount 就不合适了，我们将他改为 dispatch</p><h1 id="中间件-middleware"><a href="#中间件-middleware" class="headerlink" title="中间件 middleware"></a>中间件 middleware</h1><p>中间件简单来说就是对 dispatch 进行强化<br>比如我想在 dispatch 时，看一下 dispatch 的 type 是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMiddleware</span>(<span class="hljs-params">next</span>)&#123;<br>    <span class="hljs-comment">/* 返回增强后的dispatch */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">action</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">const</span> &#123; type &#125; = action<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`进行了了一个 type 为 <span class="hljs-subst">$&#123;type&#125;</span> 的操作`</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(action)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> &#123;<br>    subscribe,<br>    <span class="hljs-attr">dispatch</span>: <span class="hljs-title function_">logMiddleware</span>(dispatch),<br>    getState,<br>&#125;<br></code></pre></td></tr></table></figure><p>但肯定不能每次只加强一个功能，如果我想要的更多呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">...middlewares</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">createStore</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">reducer, preloadedState</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, preloadedState)<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>          <span class="hljs-string">&#x27;Dispatching while constructing your middleware is not allowed. &#x27;</span> +<br>          <span class="hljs-string">&#x27;Other middleware would not be applied to this dispatch.&#x27;</span><br>      )<br>    &#125;<br>    <span class="hljs-keyword">const</span> middlewareAPI = &#123;<br>      <span class="hljs-attr">getState</span>: store.<span class="hljs-property">getState</span>,<br>      <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">action, ...args</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(action, ...args)<br>    &#125;<br>    <span class="hljs-keyword">const</span> chain = middlewares.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">middleware</span> =&gt;</span> <span class="hljs-title function_">middleware</span>(middlewareAPI))<br>    dispatch = <span class="hljs-title function_">compose</span>(...chain)(store.<span class="hljs-property">dispatch</span>)<br>    <span class="hljs-keyword">return</span> &#123;<br>      ...store,<br>      dispatch<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候就需要用 applyMiddleware 来将我们的中间件进行整合，这个方法其实就是将我们原本 createStore 返回的 dispatch 重写了一下，再把新的 createStore 返回，</p><p>这里主要使用到 compose 对我们的 dispatch 进行强化，我们来看下compose 是怎么实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) &#123;<br>    <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> arg<br>    &#125;<br>    <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<br>        <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span><br>            <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span><br>                <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args))<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>compose 这个方法很简单，首先就是对传入的 middleware 进行判断，如果有多个 middleware 就用 reduce 方法依次执行。</p><p>这时候我们的 createStore 就需要重写一下了，这里需要注意下，initState 不是必传的，如果我们将 reducers 抽离出去，并且各自的 state 单独管理，这里就不需要 initState 了，所以再加一层判断第二、三个参数传的是什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createStore</span> = (<span class="hljs-params">reducers, initState, enhancer</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> initState === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        enhancer = initState;<br>        initState = <span class="hljs-literal">undefined</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (middleware) &#123;<br>        <span class="hljs-keyword">const</span> createNewStore = <span class="hljs-title function_">enhancer</span>(createStore);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createNewStore</span>(reducers, initState);<br>    &#125;<br>    <span class="hljs-comment">// ...剩下的不变</span><br>&#125;<br><span class="hljs-keyword">const</span> middleWare = <span class="hljs-title function_">applyMiddleware</span>(logMiddleware)(createStore);<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducers, initState, middleWare);<br></code></pre></td></tr></table></figure><p>至此一个简化版的 redux 就大功告成了。</p><h1 id="总结一下需要注意的点"><a href="#总结一下需要注意的点" class="headerlink" title="总结一下需要注意的点"></a>总结一下需要注意的点</h1><ol><li>state 只读</li><li>redux 中的数据是单向流动的</li><li>reducer 必须是纯函数</li><li>redux 和 react 没有关系，redux 只是一个应用状态管理库，如果你想的话，你可以在任何框架中使用它</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 精度问题的原因和解决方案</title>
    <link href="/2023/03/11/lodash-round/"/>
    <url>/2023/03/11/lodash-round/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><h2 id="数值精度丢失问题"><a href="#数值精度丢失问题" class="headerlink" title="数值精度丢失问题"></a>数值精度丢失问题</h2><p>Javascript 是使用二进制进行计算的，并且有长度限制。另外对于整数和小数转换成二进制的形式是不一样的。<br>整数转换成二进制使用的是<strong>除二取余</strong>，小数转成二进制使用的是<strong>将小数乘以二取整</strong></p><p>我们通过 toPrecision 方法指定精度来查看我们写的数值对象的字符串表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// &#x27;9.00000000000000000000000000000&#x27;</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-number">9.55</span>).<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// &#x27;9.55000000000000071054273576010&#x27;</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-number">9.555</span>).<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// &#x27;9.55499999999999971578290569596&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到我们定义的小数，在用到这个值时实际取出的值是有偏差的，对此还有一个经典的问题：0.1 + 0.2 !&#x3D;&#x3D; 0.3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>(<span class="hljs-number">0.1</span>).<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// &#x27;0.100000000000000005551115123126&#x27;</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-number">0.2</span>).<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// &#x27;0.200000000000000011102230246252&#x27;</span><br><span class="hljs-comment">// 以上两个值相加</span><br><span class="hljs-number">0.100000000000000005551115123126</span> + <span class="hljs-number">0.200000000000000011102230246252</span> <span class="hljs-comment">// 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>可以看到 0.1 和 0.2 都有误差，计算时就不准确了，那其他小数呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>(<span class="hljs-number">0.4</span>).<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// &#x27;0.400000000000000022204460492503&#x27;</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-number">0.5</span>).<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// &#x27;0.500000000000000000000000000000&#x27;</span><br><span class="hljs-comment">// 以上两个值相加</span><br><span class="hljs-number">0.400000000000000022204460492503</span> + <span class="hljs-number">0.500000000000000000000000000000</span> <span class="hljs-comment">// 0.9</span><br></code></pre></td></tr></table></figure><p>可以看到 0.4 其实也不准，但他和 0.5 相加却可以准确的得出 0.9，这是因为 <strong>Javascript 数字在计算时，小数最大保存 17 位，整数最大保存 15 位</strong>，所以在计算时精度差在这个范围内是可以计算正确的。</p><h2 id="js的科学计数法"><a href="#js的科学计数法" class="headerlink" title="js的科学计数法"></a>js的科学计数法</h2><p>在 JavaScript 中使用 number 类型的变量时，当小数超过6位时，整数超过 21 位 js会自动转为科学计数法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0.0000001</span>) <span class="hljs-comment">// 1e-7</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5676543211234567899876</span>) <span class="hljs-comment">// 5.676543211234568e+21</span><br></code></pre></td></tr></table></figure><h1 id="Lodash-的-round-是如何处理精度问题的"><a href="#Lodash-的-round-是如何处理精度问题的" class="headerlink" title="Lodash 的 round 是如何处理精度问题的"></a>Lodash 的 round 是如何处理精度问题的</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRound</span>(<span class="hljs-params">methodName</span>) &#123;<br>  <span class="hljs-keyword">const</span> func = <span class="hljs-title class_">Math</span>[methodName]<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">number, precision</span>) =&gt;</span> &#123;<br>    precision = precision == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : (precision &gt;= <span class="hljs-number">0</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(precision, <span class="hljs-number">292</span>) : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(precision, -<span class="hljs-number">292</span>))<br>    <span class="hljs-comment">// 如果精度不为0</span><br>    <span class="hljs-keyword">if</span> (precision) &#123;<br>      <span class="hljs-comment">// pair 是将 number 转为科学计数法形式数组.第一位是 数值，第二位是指数</span><br>      <span class="hljs-keyword">let</span> pair = <span class="hljs-string">`<span class="hljs-subst">$&#123;number&#125;</span>e`</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;e&#x27;</span>)<br>      <span class="hljs-comment">// 将 number 扩大/缩小 精度倍数,然后通过 Math.round 对整数进行四舍五入</span><br>      <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">func</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;pair[<span class="hljs-number">0</span>]&#125;</span>e<span class="hljs-subst">$&#123;+pair[<span class="hljs-number">1</span>] + precision&#125;</span>`</span>)<br>      pair = <span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span>e`</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;e&#x27;</span>)<br>      <span class="hljs-comment">// 缩小/扩大 精度倍数</span><br>      <span class="hljs-keyword">return</span> +<span class="hljs-string">`<span class="hljs-subst">$&#123;pair[<span class="hljs-number">0</span>]&#125;</span>e<span class="hljs-subst">$&#123;+pair[<span class="hljs-number">1</span>] - precision&#125;</span>`</span><br>    &#125;<br>    <span class="hljs-comment">// 如果精度为 0 直接使用 Math.round 进行舍入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(number)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> round = <span class="hljs-title function_">createRound</span>(<span class="hljs-string">&#x27;round&#x27;</span>);<br></code></pre></td></tr></table></figure><p>其实实现方式很简单，就是将数字变成整数，使用 Math.round 进行舍入，最后变回原值即可。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片懒加载的几种方式</title>
    <link href="/2022/12/21/lazy-image-loading/"/>
    <url>/2022/12/21/lazy-image-loading/</url>
    
    <content type="html"><![CDATA[<h2 id="通过-img-标签"><a href="#通过-img-标签" class="headerlink" title="通过 img 标签"></a>通过 img 标签</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div style=&#123;&#123; <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;300px&#x27;</span>, <span class="hljs-attr">overflow</span>: <span class="hljs-string">&#x27;auto&#x27;</span>&#125;&#125;&gt;<br>    &#123;items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;item.src&#125;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">decoding</span>=<span class="hljs-string">&quot;async&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    ))&#125;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这里使用 react 来做实例，items 是一个图片数组，我们给 img 标签的 loading 属性设置 “lazy” 来开启懒加载。需要注意的是<a href="https://caniuse.com/loading-lazy-attr">该属性在浏览器的兼容性</a></p><h2 id="滚动上去的高度-浏览器可视区高度-图片距离文档顶部的高度"><a href="#滚动上去的高度-浏览器可视区高度-图片距离文档顶部的高度" class="headerlink" title="滚动上去的高度 + 浏览器可视区高度 &gt;&#x3D; 图片距离文档顶部的高度"></a>滚动上去的高度 + 浏览器可视区高度 &gt;&#x3D; 图片距离文档顶部的高度</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/1.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/2.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/3.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/4.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/5.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/6.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/7.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;img/8.jpg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/0.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//获取全部img标签</span><br><span class="hljs-keyword">var</span> images = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;img&quot;</span>);<br> <br> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//当发生滚动事件时调用ergodic事件</span><br>    <span class="hljs-title function_">ergodic</span>();<br>  &#125;);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ergodic</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 遍历每一张图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> images) &#123;<br>      <span class="hljs-comment">//判断当前图片是否在可视区内</span><br>      <span class="hljs-keyword">if</span> (i.<span class="hljs-property">offsetTop</span> &lt;= <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>) &#123;<br>          <span class="hljs-comment">//获取自定义data-src属性的值</span><br>          <span class="hljs-keyword">let</span> trueSrc = i.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;data-src&quot;</span>);<br>          <span class="hljs-comment">//把值赋值给图片的src属性</span><br>          i.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;src&quot;</span>, trueSrc);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//没发生滚动事件时也要先执行一次</span><br>  <span class="hljs-title function_">ergodic</span>();<br></code></pre></td></tr></table></figure><h2 id="使用-Intersection-Observer-API"><a href="#使用-Intersection-Observer-API" class="headerlink" title="使用 Intersection Observer API"></a>使用 Intersection Observer API</h2><p>首先，在页面中将所有需要懒加载的图片的 src 属性设置为占位符或者一个小的loading图。</p><p>使用 Intersection Observer API 来监测图片元素是否进入了可视区域，并在图片进入可视区域时加载真实的图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lazy-load&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Lazy-loaded image&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> lazyImages = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.lazy-load&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">lazyLoad</span> = target =&gt; &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">const</span> img = entry.<span class="hljs-property">target</span>;</span><br><span class="language-javascript">          <span class="hljs-keyword">const</span> src = img.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">          img.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>, src);</span><br><span class="language-javascript">          observer.<span class="hljs-title function_">disconnect</span>();</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    io.<span class="hljs-title function_">observe</span>(target);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  lazyImages.<span class="hljs-title function_">forEach</span>(lazyLoad);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先将需要懒加载的图片的真实路径存储在 data-src 属性中，<br>并添加一个具有 lazy-load 类名的标记。然后使用 JavaScript 遍历所有具有 lazy-load 类名的图片元素，<br>对每个图片元素应用 Intersection Observer，一旦图片元素进入视口（即可见），就将 data-src 的值赋给 src 属性以加载真实的图片。</p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写集合</title>
    <link href="/2022/12/03/write/"/>
    <url>/2022/12/03/write/</url>
    
    <content type="html"><![CDATA[<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-comment">//返回一个绑定this的函数，我们需要在此保存this</span><br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 可以支持柯里化传参，保存参数</span><br>    <span class="hljs-keyword">let</span> arg = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 返回一个函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//同样因为支持柯里化形式传参我们需要再次获取存储参数</span><br>        <span class="hljs-keyword">let</span> newArg = [...<span class="hljs-variable language_">arguments</span>];<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArg);<br>        <span class="hljs-comment">// 返回函数绑定this，传入两次保存的参数</span><br>        <span class="hljs-comment">//考虑返回函数有返回值做了return</span><br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context, arg.<span class="hljs-title function_">concat</span>(newArg));<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> context === <span class="hljs-literal">null</span>) &#123;<br>        context = <span class="hljs-variable language_">window</span><br>    &#125;<br>    context = context || <span class="hljs-variable language_">window</span>;<br>    <span class="hljs-keyword">const</span> symbol = <span class="hljs-title class_">Symbol</span>();<br>    context[symbol] = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> result = context[symbol](...args);<br>    <span class="hljs-keyword">delete</span> context[symbol];<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    context = context || <span class="hljs-variable language_">window</span>;<br>    <span class="hljs-keyword">const</span> symbol = <span class="hljs-title class_">Symbol</span>();<br>    context[symbol] = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context[symbol]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args);<br>    <span class="hljs-keyword">const</span> result = context[symbol](...args[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">delete</span> context[symbol];<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="deepClone"><a href="#deepClone" class="headerlink" title="deepClone"></a>deepClone</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span> (org, tar)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> org !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> org;<br>    &#125;<br>    <span class="hljs-keyword">var</span> tar = tar || &#123;&#125;,<br>        toStr = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>,<br>        arrType = <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> org) &#123;<br>        <span class="hljs-keyword">if</span> (org.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> org[key] === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; org[key] !== <span class="hljs-literal">null</span>) &#123;<br>                tar[key] = toStr.<span class="hljs-title function_">call</span>(org[key]) === arrType ? [] : &#123;&#125;;<br>                <span class="hljs-title function_">deepClone</span>(org[key], tar[key]);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                tar[key] = org[key];<br>            &#125;<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tar;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myFilter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = <span class="hljs-variable language_">this</span>,<br>        len = arr.<span class="hljs-property">length</span>,<br>        arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>,<br>        newArr = [],<br>        item;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        item = <span class="hljs-title function_">structuredClone</span>(arr[i]);<br>        <span class="hljs-keyword">var</span> flag = fn.<span class="hljs-title function_">apply</span>(arg2, [item, i, arr]);<br>        <br>        <span class="hljs-keyword">if</span> (flag) &#123;            <br>            newArr.<span class="hljs-title function_">push</span>(item)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMap</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = <span class="hljs-variable language_">this</span>,<br>        len = arr.<span class="hljs-property">length</span>,<br>        arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>,<br>        newArr = [],<br>        item;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        item = <span class="hljs-title function_">structuredClone</span>(arr[i]);<br>        <span class="hljs-keyword">var</span> newItem = fn.<span class="hljs-title function_">apply</span>(arg2, [item, i, arr]);<br>        newArr.<span class="hljs-title function_">push</span>(newItem);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* </span><br><span class="hljs-comment">    new 的过程都发生了什么</span><br><span class="hljs-comment">        1、新生成了一个对象</span><br><span class="hljs-comment">        2、链接到原型</span><br><span class="hljs-comment">        3、绑定 this</span><br><span class="hljs-comment">        4、返回新对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">Con</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Con</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Con</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象</span><br>  <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyProxy</span> (target, handler) &#123;<br><br>    <span class="hljs-keyword">let</span> _target = <span class="hljs-title function_">deepClone</span>(target);<br><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(_target).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(_target, key, &#123;<br>            get () &#123;<br>                <span class="hljs-keyword">return</span> handler.<span class="hljs-property">get</span> &amp;&amp; handler.<span class="hljs-title function_">get</span>(target, key);<br>            &#125;,<br>            set (newVal) &#123;<br>                handler.<span class="hljs-property">set</span> &amp;&amp; handler.<span class="hljs-title function_">set</span>(target, key, newVal);<br>            &#125;<br>        &#125;)<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> _target;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span> (org, tar)&#123;<br>        <span class="hljs-keyword">var</span> tar = tar || &#123;&#125;,<br>            toStr = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>,<br>            arrType = <span class="hljs-string">&#x27;[object, Array]&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> org) &#123;<br>            <span class="hljs-keyword">if</span> (org.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> org[key] === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; org[key] !== <span class="hljs-literal">null</span>) &#123;<br>                    tar[key] = toStr.<span class="hljs-title function_">call</span>(org[key]) === arrType ? [] : &#123;&#125;;<br>                    <span class="hljs-title function_">deepClone</span>(org[key], tar[key]);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    tar[key] = org[key];<br>                &#125;<br>            &#125; <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tar;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* </span><br><span class="hljs-comment">    reduce 是没有第三个参数修改 this 指向的</span><br><span class="hljs-comment">    重写方法 myReduce 加入了</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myReduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, intialValue</span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = <span class="hljs-variable language_">this</span>,<br>        len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>,<br>        arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>] || <span class="hljs-variable language_">window</span>,<br>        item;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        item = <span class="hljs-title function_">structuredClone</span>(arr[i]);<br>        intialValue = fn.<span class="hljs-title function_">apply</span>(arg2, [intialValue, item, i, arr]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intialValue;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="every"><a href="#every" class="headerlink" title="every"></a>every</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myEvery</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = <span class="hljs-variable language_">this</span>,<br>        len = arr.<span class="hljs-property">length</span>,<br>        arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">var</span> flag = fn.<span class="hljs-title function_">apply</span>(arg2, [arr[i], i, arr]);<br>        <span class="hljs-keyword">if</span>(!flag) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="some"><a href="#some" class="headerlink" title="some"></a>some</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mySome</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = <span class="hljs-variable language_">this</span>,<br>        len = arr.<span class="hljs-property">length</span>,<br>        arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">var</span> flag = fn.<span class="hljs-title function_">apply</span>(arg2, [arr[i], i, arr]);<br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myForEach</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = <span class="hljs-variable language_">this</span>,<br>        len = arr.<span class="hljs-property">length</span>,<br>        <span class="hljs-comment">// 如果没传第二个参数，this还是指向window</span><br>        arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;<br>        <span class="hljs-comment">// console.log(arr);</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-comment">// 如果传第二个参数，需要更改this指向</span><br>        fn.<span class="hljs-title function_">apply</span>(arg2, [arr[i], i, arr]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="debounce-防抖"><a href="#debounce-防抖" class="headerlink" title="debounce(防抖)"></a>debounce(防抖)</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            fn.<span class="hljs-title function_">apply</span>(context, args);<br>        &#125;, delay);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="throttle-节流"><a href="#throttle-节流" class="headerlink" title="throttle(节流)"></a>throttle(节流)</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> lastCall = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>        <span class="hljs-keyword">if</span> (now - lastCall &gt;= delay) &#123;<br>            <span class="hljs-title function_">fn</span>(...args);<br>            lastCall = now;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>时间复杂度 <strong>O(nlogn)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> array<br>  <span class="hljs-keyword">let</span> pivot = array[array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">let</span> left = array.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> v &lt;= pivot &amp;&amp; i != array.<span class="hljs-property">length</span> -<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">let</span> right = array.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v &gt; pivot)<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-title function_">quickSort</span>(left), pivot, ...<span class="hljs-title function_">quickSort</span>(right)]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度 <strong>O(n^2)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> length = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// i &lt; length - 1 是因为外层只需要 length-1 次就排好了，第 length 次比较是多余的。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> hasChange = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 提前退出冒泡循环的标志位</span><br>        <span class="hljs-comment">// j &lt; length - i - 1 是因为内层的 length-i-1 到 length-1 的位置已经排好了，不需要再比较一次。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]]<br>                hasChange = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示有数据交换</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!hasChange) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果 false 说明所有元素已经到位，没有数据交换，提前退出</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="睡眠函数"><a href="#睡眠函数" class="headerlink" title="睡眠函数"></a>睡眠函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">time</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)&#123;<br>        <span class="hljs-built_in">setTimeout</span>(resolve, time);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tasking</title>
    <link href="/2021/09/16/tasking/"/>
    <url>/2021/09/16/tasking/</url>
    
    <content type="html"><![CDATA[<h1 id="Taking的好处"><a href="#Taking的好处" class="headerlink" title="Taking的好处"></a>Taking的好处</h1><ol><li>梳理业务需求：高效沟通</li><li>进行复杂度估算：独立交付价值</li></ol><p>业务需求-&gt;Tasking-&gt;使用TDD开发</p><h1 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h1><p>实践过程中赋予TDD的三层含义</p><ol><li>Task-Driven Development</li><li>Test-Driven Development</li><li>Test-Driven Design</li></ol><h1 id="Tasking的不同视角"><a href="#Tasking的不同视角" class="headerlink" title="Tasking的不同视角"></a>Tasking的不同视角</h1><ol><li>面向技术实现的Tasking（根据业务场景的复杂度）</li><li>面向业务需求的Tasking（首先进行）</li></ol><h2 id="面向业务需求"><a href="#面向业务需求" class="headerlink" title="面向业务需求"></a>面向业务需求</h2><p>面向业务需求的Tasking需要穷举所有业务场景，包括边界条件</p><h3 id="面向业务需求的价值"><a href="#面向业务需求的价值" class="headerlink" title="面向业务需求的价值"></a>面向业务需求的价值</h3><ol><li>独立价值交付：具有独立价值交付，每完成一条即可进行交付</li><li>高效沟通：采用业务语言描述列表，有助于开发人员与业务人员更好的沟通</li></ol><h2 id="面向技术"><a href="#面向技术" class="headerlink" title="面向技术"></a>面向技术</h2><h3 id="基于技术实现的TDD是如何实现的"><a href="#基于技术实现的TDD是如何实现的" class="headerlink" title="基于技术实现的TDD是如何实现的"></a>基于技术实现的TDD是如何实现的</h3><p>例：Given 用户名密码When登录 Then 登录成功</p><ol><li>编写LoginController</li><li>集成Identity服务验证用户名、密码</li><li>生成Token并返回</li></ol><h1 id="Tasking场景的三个维度"><a href="#Tasking场景的三个维度" class="headerlink" title="Tasking场景的三个维度"></a>Tasking场景的三个维度</h1><ol><li>Happy Path     &#x2F;&#x2F;正常状态下</li><li>Alternate Path&#x2F;&#x2F;边界</li><li>Sad Path&#x2F;&#x2F;非法</li></ol><h1 id="TDD-实践"><a href="#TDD-实践" class="headerlink" title="TDD 实践"></a>TDD 实践</h1><p>测试案例三小步：</p><ol><li><p>红：保证测试案例没有编译错误，运行后报错    &#x2F;&#x2F;验证测试案例确实能捕获错误</p><p> <img src="https://s21.ax1x.com/2024/03/14/pFgE654.webp"></p></li><li><p>绿：修改被测代码到刚好通过        &#x2F;&#x2F;保证所有被测代码都被测试所覆盖</p><p> <img src="https://s21.ax1x.com/2024/03/14/pFgEDbT.webp"></p></li><li><p>重构：整理代码，消除重复    &#x2F;&#x2F;分离关注点，快速反馈</p><p> <img src="https://s21.ax1x.com/2024/03/14/pFgVFRs.jpg"><br> <img src="https://s21.ax1x.com/2024/03/14/pFgViGj.jpg"></p></li></ol><h1 id="TDD的价值"><a href="#TDD的价值" class="headerlink" title="TDD的价值"></a>TDD的价值</h1><ol><li>澄清目标：TDD不是“先写测试”，而是“先写需求”，明白自己要实现的目标是什么</li><li>及时反馈：每写完一小步就进行单元测试，可以很快就得到反馈</li><li>减少调试：由于进行了多个单元测试，可以减少90%的调试过程</li><li>优化设计：重构环节就保证了每小段代码的优化</li><li>构建安全网：TDD的测试案例覆盖率很高，修改任何代码，一键就可以对整个系统测试，有问题可以及时发现解决</li><li>提高开发体验：确保每小步都正确，合起来也极少会出现问题</li></ol><h1 id="怎样学好-TDD"><a href="#怎样学好-TDD" class="headerlink" title="怎样学好 TDD"></a>怎样学好 TDD</h1><p>遵循 守、破、离</p><p>Pair的方式<br>线下结对编程<br>线上通过Zoom以Navigator-Observer的形式<br>线上通过Zoom以Ping-Pong的形式<br>沟通产生统一Task，异步完成</p><h1 id="重构时常用的快捷键"><a href="#重构时常用的快捷键" class="headerlink" title="重构时常用的快捷键"></a>重构时常用的快捷键</h1><ul><li>重命名文件、方法、属性等（rename）：SHIFT+F6</li><li>提取当前选择为变量（extract variable）：CTRL+ALT+V</li><li>提取当前选择为属性（extract field）：CTRL+ALT+F</li><li>提取当前选择为常量（extract constant）：CTRL+ALT+C</li><li>提取当前选择为方法（extract method）：CTRL+ALT+M</li><li>提取当前选择为方法参数（extract parameter）：CTRL+ALT+P</li><li>重构类、方法（change signarture）：CTRL+F6</li><li>提取代码块至if、try等结构中（surround with）：CTRL+ALT+T</li><li>创建模块文件等（new）：CTRL+ALT+N</li><li>创建测试用例（test）：CTRL+SHIFT+T</li><li>重构菜单（refactor for this）：CTRL+T</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tasking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>团队协作中git的基本使用</title>
    <link href="/2021/09/15/git-01/"/>
    <url>/2021/09/15/git-01/</url>
    
    <content type="html"><![CDATA[<h1 id="git对于软件开发团队的意义"><a href="#git对于软件开发团队的意义" class="headerlink" title="git对于软件开发团队的意义"></a>git对于软件开发团队的意义</h1><p>在我们进行团队协作的软件开发时，我们的项目可能会分解成多个不同的模块、功能，这些模块、功能又会细分下去交给不同的人来进行开发，当多个人共同来完成一个项目的时候，我们如何同步进行呢？使用git就能完美的解决这个问题，我们可以在git上建立多个分支，多人来同时工作，同事也可以通过你上传的代码来实时同步我们的工作进度。</p><p>另外，当多人对一个文件进行修改时，必然会发生冲突，不同人的思想不同，开发一个逻辑也难免出现错误，而git的优势就在于，对代码质量把控、减少代码冲突。</p><p>又或者，我们在写代码的过程中，对于一段代码想要进行修改甚至删除，但又害怕将来出错需要恢复，这时候用git将是你最好的选择，git的定义就是一个开源的分布式版本控制系统，那什么是版本控制呢？通俗来讲，就是git可以将你的每次修改记录下来，形成一个版本，当你想要恢复你的代码时，只要找到对应的版本即可。</p><h1 id="git-和-github-的区别"><a href="#git-和-github-的区别" class="headerlink" title="git 和 github 的区别"></a>git 和 github 的区别</h1><p><img src="https://z1.ax1x.com/2023/12/13/pifKqVU.png"><br>git 是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。<br>简单来说，git就是一个帮助我们管理我们的代码版本控制工具。<br><img src="https://z1.ax1x.com/2023/12/13/pifKLaF.png"><br>而 gitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 git 作为唯一的版本库格式进行托管，所以叫 github。<br>我们可以将自己的项目提交到 github 上进行托管，也可以在上面查阅他人公开的项目，必要的时候可以拉下来进行学习。<br>简单来说，github 就是一个用来存放代码的仓库。</p><h1 id="本地仓库和远端仓库"><a href="#本地仓库和远端仓库" class="headerlink" title="本地仓库和远端仓库"></a>本地仓库和远端仓库</h1><p>本地仓库和远端仓库在本质上来说没有什么区别，甚至可以理解为一个是本地电脑，一个是远端的电脑，通常情况下，远端仓库不参与开发，主要作为托管中心。<br><img src="https://z1.ax1x.com/2023/12/13/pifMEPH.jpg" alt="图片来源自网络"></p><p>上图就能够很清晰的表明远程仓库、本地仓库、暂存区、工作区之间的关系。这其中出现的一些概念：<br><strong>workspace</strong>：工作区，我们进行编写代码的区域，可以通过pull将远端仓库的代码拉取下来，也可以通过checkout来切换分支。<br><strong>Index</strong>：暂存区，当我们代码完成一个阶段后，需要在本地仓库进行同步，即进行commit操作，但每次修改都进行commit会比较麻烦，所以git给我们提供一个暂存区，修改代码后进行add操作添加到缓存区，最后统一进行commit到本地仓库。<br><strong>Repository</strong>：本地仓库，本地用来存储代码的仓库，可以通过push将本地仓库文件上传到远程仓库，也可以通过fetch&#x2F;clone将远端仓库的文件拉取克隆下来。<br><strong>Remote</strong>：远程仓库，远端用来存储代码的仓库。</p><h1 id="代码如何上传到私有远端仓库"><a href="#代码如何上传到私有远端仓库" class="headerlink" title="代码如何上传到私有远端仓库"></a>代码如何上传到私有远端仓库</h1><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><ol><li>进行初始化本地仓库  git init</li><li>加到暂存区git add . &#x2F; git add *</li><li>提交到本地仓库git commit -m ‘文本’ </li><li>连接远程仓库git remote add origin  你的远程仓库的URL（在创建仓库中可以找到）</li><li>提交到远程仓库git push origin master</li></ol><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>首先在桌面右键打开 gitbash 输入ssh<br><img src="https://z1.ax1x.com/2023/12/13/pif1kIU.png"><br>出现如图代表git安装成功可以正常使用。</li><li>然后输入 ssh-keygen -t rsa 该命令是指定 rsa 算法生成密钥，输入命令后连续三个回车即可，默认情况下会生成两个文件 id_rsa 和 id_rsa.pub，id_rsa是密钥，id_rsa.pub是公钥。生成目录在执行命令后可以看到。</li><li>用记事本打开 id_rsa.pub 后 copy 全部内容。</li><li>进入远程仓库（用github示例），找到settings。</li><li>选择 SSH and GPG keys -&gt; New SSH key。<br><img src="https://z1.ax1x.com/2023/12/13/pifMVGd.png"></li><li>将（3）复制的内容粘贴到 Key 中，Title 可以空着不写，然后 Add SSH key。</li></ol><h3 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h3><ol><li>首先在 github 上创建新的仓库，然后复制SSH。</li><li>打开编译器终端依次输入如下命令<br> git init<br> git remote add origin 你复制的SSH<br> git add .<br> git commit -m’文本’<br> git push origin master<br> 进入到github仓库中查看是否上传成功。</li></ol><h1 id="代码怎么从远端仓库同步到本地"><a href="#代码怎么从远端仓库同步到本地" class="headerlink" title="代码怎么从远端仓库同步到本地"></a>代码怎么从远端仓库同步到本地</h1><p>第一种情况：将远端仓库代码克隆到本地<br>git clone 仓库的 http&#x2F;SSH</p><p>第二种情况：将远端仓库代码拉取下来合并到本地<br>git pull &#x2F; git pull origin master</p><h1 id="多人工作在同一代码库如何合并代码"><a href="#多人工作在同一代码库如何合并代码" class="headerlink" title="多人工作在同一代码库如何合并代码"></a>多人工作在同一代码库如何合并代码</h1><p>1、切换到其他分支：git checkout 分支名<br>2、将代码拉取下来：git pull<br>3、合并分支：git merge 分支名</p><h1 id="合并出现冲突怎么处理"><a href="#合并出现冲突怎么处理" class="headerlink" title="合并出现冲突怎么处理"></a>合并出现冲突怎么处理</h1><p>首先要知道为什么会产生代码冲突，假设我们现在有三次提交A.B.C<br><img src="https://z1.ax1x.com/2023/12/13/pifMFaD.png"><br>在远程分支 origin 的基础上创建一个名为 “mywork” 的分支并提交了（可以理解为我们自己进行了更改要进行提交），同时有其他人在 “origin” 上做了一些修改并提交了。<br><img src="https://z1.ax1x.com/2023/12/13/pifMCqK.png"><br>此时在 E 提交的时候就会产生代码冲突。</p><p>产生代码冲突后如何解决呢？</p><p>我们有两种方法可以用来解决代码冲突：</p><p>首先就是 git merge 方法，该方法就是使用 git pull 命令将 origin 分支上的修改拉取下来，再与本地的提交合并之后再提交，简单来说，就是将别人的修改和自己的修改合并成一个文件再进行提交。<br><img src="https://z1.ax1x.com/2023/12/13/pifMiVO.png"><br>因为是合并两个修改，所以会形成菱形。</p><p>另一种方法就是 git rebase，该方法就是废除掉我们要提交的修改，选择一个我们想要提交的正确的进行提交。</p><p><img src="https://z1.ax1x.com/2023/12/13/pifM9r6.png"><br>由于 E 被废除掉，所以用虚线表示，此时形成的是一条线而并非菱形。<br>在 rebase 过程中有时会出现 conflict，此时就需要用户自己手动来解决冲突后继续提交。</p><h1 id="关于-commit-的提交规范"><a href="#关于-commit-的提交规范" class="headerlink" title="关于 commit 的提交规范"></a>关于 commit 的提交规范</h1><ul><li>feat: 新的功能</li><li>fix: 修复 bug</li><li>refactor: 重构代码</li><li>chore: 不影响业务功能的一些操作</li><li>doc: 关于文档的修改</li><li>test: 测试代码</li><li>perf: 性能优化</li><li>style: 代码格式修改</li><li>ci: 持续集成</li><li>release: 发布新版本</li></ul><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ol><li>创建分支：git branch 分支名</li><li>创建并切换到分支：git checkout -b 分支名</li><li>查看分支：git branch</li><li>切换到其他分支：git checkout 分支名</li><li>创建并切换分支并与远端仓库分支进行关联：git checkout -b 分支名 远端仓库分支</li><li>删除分支：git branch -d 分支名  &#x2F;&#x2F;不能删除当前所在分支；已进行过提交的不能删除</li><li>强制删除分支：git branch -D 分支名 </li><li>删除分支并且推送远程仓库：git push origin –delete 分支名</li><li>合并分支：git merge 要合并的分支名</li><li>查看所有分支信息：git branch -av</li></ol><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ol><li>查看版本简写日志：git log –oneline</li><li>查看版本路线：git log –oneline –graph</li><li>从远端仓库拉取：git fetch</li></ol><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ol><li>打标签：git tag xxx</li><li>查看标签：git tag –list</li><li>删除标签：git tag -d xxx</li></ol><h2 id="操作失误回滚"><a href="#操作失误回滚" class="headerlink" title="操作失误回滚"></a>操作失误回滚</h2><h3 id="未提交到暂存区"><a href="#未提交到暂存区" class="headerlink" title="未提交到暂存区"></a>未提交到暂存区</h3><ol><li>使用命令git status 查看缓存区中未提交的文件，然后使用命令git checkout – 要还原的文件夹下的文件，执行命令后会自动还原</li></ol><h3 id="已提交到暂存区"><a href="#已提交到暂存区" class="headerlink" title="已提交到暂存区"></a>已提交到暂存区</h3><ol><li>使用命令 git reset HEAD 文件夹下的文件 ，把文件从暂存区撤销，然后使用未提交到暂存区的操作失误还原操作即可。</li></ol><h3 id="回滚到指定版本"><a href="#回滚到指定版本" class="headerlink" title="回滚到指定版本"></a>回滚到指定版本</h3><ol><li>git reset –hard HEAD^   &#x2F;&#x2F;一个^代表回归一个版本</li><li>先 git log 查看历史获取 commit 的 id，然后 git reset –hard 你要回到版本的commit的id</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
